{"/docs/":{"data":{"":" Build modern websites with Markdown and Hugo "},"title":"_index"},"/python-fundamentals/":{"data":{"":"Explore the following sections to learn Python basics:\n01. Python Basics 02. Control Flow 03. Data Structures 04. Functions 05. Modules and Packages 06. File Operations 07. Object-Oriented Programming 08. Error Handling 09. Practice Projects "},"title":"Python Programming for Beginners"},"/python-fundamentals/01-basics/":{"data":{"":"Explore the following sections on Python basics:\n01. Introduction to Python 02. Setup 03. Syntax Basics 04. Variables and Types 05. Operators and Expressions 06. Input and Output Operations "},"title":"Python Basics"},"/python-fundamentals/01-basics/01-introduction-to-python/":{"data":{"":"","features-and-advantages-of-python#Features and Advantages of Python":"Python offers numerous features that make it an excellent choice for beginners and professional developers alike:\n1. Easy to Learn and Read Python’s syntax is designed to be intuitive and similar to the English language. Its code is highly readable, making it easier for beginners to understand and for teams to collaborate.\n2. Interpreted Language Python code is executed line by line, which means you don’t need to compile your code before running it. This makes the development process faster and debugging easier.\n3. Dynamically Typed You don’t need to declare variable types when writing Python code. The interpreter automatically identifies the data type based on the value assigned.\n# Example of dynamic typing x = 10 # x is now an integer x = \"Hello\" # x is now a string x = [1, 2, 3] # x is now a list 4. Cross-Platform Compatibility Python runs on multiple platforms including Windows, macOS, Linux, and even on mobile devices and web browsers (through various implementations).\n5. Extensive Standard Library Python comes with a rich standard library that includes modules for various functionalities like file I/O, system calls, internet protocols, and more, reducing the need for external code.\n6. Support for Multiple Programming Paradigms Python supports procedural, object-oriented, and functional programming approaches, providing flexibility in how you structure your code.\n7. Large and Active Community A vibrant community contributes to Python’s ecosystem by developing libraries, providing support, and sharing knowledge through forums, documentation, and tutorials.\n8. Scalability Python can be used for small scripts as well as large, complex applications, making it suitable for various project sizes.","python-applications-and-use-cases#Python Applications and Use Cases":"Python’s versatility makes it suitable for a wide range of applications:\n1. Web Development Python frameworks like Django and Flask enable developers to build robust web applications. Companies like Instagram, Pinterest, and Mozilla use Python for their web applications.\n2. Data Science and Analysis Python has become the language of choice for data scientists. Libraries like NumPy, Pandas, and Matplotlib provide powerful tools for data manipulation and visualization.\n# Simple data analysis example import pandas as pd import matplotlib.pyplot as plt # Create a sample dataframe data = {'Year': [2010, 2011, 2012, 2013, 2014], 'Sales': [65000, 67000, 72000, 78000, 85000]} df = pd.DataFrame(data) # Plot the data plt.figure(figsize=(10,6)) plt.plot(df['Year'], df['Sales'], marker='o') plt.title('Annual Sales') plt.xlabel('Year') plt.ylabel('Sales ($)') plt.grid(True) plt.show() 3. Machine Learning and Artificial Intelligence Libraries like TensorFlow, PyTorch, and scikit-learn have made Python the dominant language in AI and ML development.\n4. Scientific Computing Python is widely used in scientific research for simulation, data processing, and visualization. Libraries like SciPy enhance its capabilities in this domain.\n5. Automation and Scripting Python excels at automating repetitive tasks, making it popular for writing scripts to handle system administration, file operations, and other routine processes.\n6. Game Development While not as common as C++ for game development, Python is used with libraries like Pygame for creating 2D games and prototyping.\n7. Desktop GUI Applications Libraries like Tkinter, PyQt, and wxPython enable the development of cross-platform desktop applications with graphical user interfaces.\n8. Internet of Things (IoT) Python can run on small devices like Raspberry Pi, making it suitable for IoT projects and physical computing.\n9. Finance and Trading Financial institutions use Python for quantitative analysis, algorithmic trading, and risk management due to its data processing capabilities.\nImportant: Python’s adoption continues to grow across industries, and understanding Python is increasingly becoming a fundamental skill for professionals in technology, data analysis, science, and many other fields.\nNote: While Python is excellent for many applications, it may not be the best choice for all scenarios. Applications requiring extreme performance optimization or low-level system access might benefit from languages like C or C++. However, Python often allows for integration with these languages when necessary.\nIn the upcoming sections, we’ll dive deeper into Python’s development environment, syntax fundamentals, and begin building our programming skills step by step.\nNext ","what-is-python-and-its-history#What is Python and its History":"Python is a high-level, interpreted programming language created by Guido van Rossum. It was first released in 1991, but its development began in the late 1980s. Van Rossum named the language after the British comedy group Monty Python, reflecting his intention to make programming fun and accessible.\nPython was designed with a philosophy emphasizing code readability and a syntax that allows programmers to express concepts in fewer lines of code than would be possible in languages like C++ or Java. This philosophy is summarized in “The Zen of Python,” a collection of guiding principles that influence the design of Python code.\nThe language has evolved significantly since its inception:\nPython 1.0 was released in January 1994 Python 2.0 was released in October 2000, introducing features like list comprehensions and garbage collection Python 3.0 was released in December 2008, representing a major revision that broke backward compatibility to address design flaws As of 2023, Python 3.x is the current series with regular updates and improvements Python is maintained by the Python Software Foundation, a non-profit organization dedicated to promoting, protecting, and advancing the Python programming language."},"title":"Introduction Python"},"/python-fundamentals/01-basics/02-setup/":{"data":{"":"","choosing-a-code-editor-or-ide#Choosing a Code Editor or IDE":"While you can write Python code in any text editor, using a specialized code editor or Integrated Development Environment (IDE) can significantly improve your productivity.\nPopular Options for Beginners Visual Studio Code (VS Code):\nFree, lightweight, and highly customizable Works on Windows, macOS, and Linux Install the Python extension for features like syntax highlighting, code completion, and debugging Download from code.visualstudio.com PyCharm:\nPowerful IDE specifically designed for Python Available in free Community Edition and paid Professional Edition Includes advanced features like intelligent code completion, on-the-fly error checking, and integrated debugging Download from jetbrains.com/pycharm Thonny:\nPython IDE designed for beginners Comes with Python built-in, so no need for separate installation Simple interface with helpful features for learning Download from thonny.org IDLE:\nComes bundled with Python installation Basic features but sufficient for beginners No additional installation required Important: Choose an environment that matches your comfort level. If you’re just starting, Thonny or IDLE might be less overwhelming, while VS Code or PyCharm offer more features as you advance.","installing-python#Installing Python":"Before you can start programming in Python, you need to set up your development environment. This process involves installing Python and optionally an Integrated Development Environment (IDE) or code editor to make your programming experience more efficient.\nInstalling Python on Windows Download the installer:\nVisit the official Python website at python.org Click on the “Download Python” button for the latest version Select the Windows installer (.exe) file Run the installer:\nOpen the downloaded file Check the box that says “Add Python to PATH” - this is very important as it allows you to run Python from the command prompt Click “Install Now” for a standard installation Verify the installation:\nOpen Command Prompt (search for “cmd” in the Start menu) Type python --version and press Enter You should see the Python version number displayed C:\\Users\\username\u003e python --version Python 3.11.4 Installing Python on macOS Using the official installer:\nVisit python.org Download the macOS installer (.pkg file) Open the downloaded file and follow the installation wizard Using Homebrew (recommended for developers):\nIf you don’t have Homebrew installed, open Terminal and run: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Install Python using Homebrew: brew install python Verify the installation:\nOpen Terminal Type python3 --version and press Enter You should see the Python version displayed Installing Python on Linux Most Linux distributions come with Python pre-installed. To verify and ensure you have the latest version:\nCheck the current version:\nOpen Terminal Type python3 --version Installing on Ubuntu/Debian:\nsudo apt update sudo apt install python3 python3-pip Installing on Fedora:\nsudo dnf install python3 python3-pip Installing on Arch Linux:\nsudo pacman -S python python-pip ","running-your-first-python-program#Running Your First Python Program":"Now that you have Python and a code editor installed, let’s write and run your first Python program.\nMethod 1: Using the Python Interactive Shell The Python interactive shell (also called the REPL - Read, Evaluate, Print, Loop) lets you execute Python commands line by line.\nOpen the interactive shell:\nOpen Command Prompt (Windows) or Terminal (macOS/Linux) Type python (Windows) or python3 (macOS/Linux) and press Enter You should see the Python prompt (\u003e\u003e\u003e) Write a simple command:\n\u003e\u003e\u003e print(\"Hello, Python!\") Press Enter to see the output:\nHello, Python! Exit the shell:\nType exit() or press Ctrl+Z (Windows) or Ctrl+D (macOS/Linux) followed by Enter Method 2: Creating and Running a Python File Create a new file: Open your chosen code editor Create a new file named hello.py Type the following code: # My first Python program print(\"Hello, Python!\") print(\"Welcome to the world of programming!\") # A simple calculation sum = 5 + 3 print(\"The sum of 5 and 3 is:\", sum) # Getting user input name = input(\"What is your name? \") print(\"Nice to meet you,\", name) Save the file to a location you can easily access, like your Desktop or Documents folder\nRun the program:\nUsing Command Line:\nOpen Command Prompt or Terminal Navigate to the directory where you saved the file using the cd command Run the program with: python hello.py # On Windows python3 hello.py # On macOS/Linux Using VS Code:\nWith the file open, click the “Run” button (triangle icon) in the top-right corner, or Right-click in the editor and select “Run Python File in Terminal” Using PyCharm:\nRight-click in the editor and select “Run ‘hello’” or Use the green “Run” button in the toolbar Using IDLE:\nWith the file open, press F5 or select “Run \u003e Run Module” from the menu View the output: The program will execute and you’ll see the output in the terminal or console window. You’ll also be prompted to enter your name, and then see a personalized greeting.\nExpected Output:\nHello, Python! Welcome to the world of programming! The sum of 5 and 3 is: 8 What is your name? [You type your name here] Nice to meet you, [Your name] Note: The input() function pauses the program and waits for the user to type something and press Enter. This allows for interactive programs that can respond to user input.","troubleshooting-common-installation-issues#Troubleshooting Common Installation Issues":"“Python is not recognized as an internal or external command” This typically means Python wasn’t added to your system’s PATH. You can fix this by:\nReinstalling Python and checking “Add Python to PATH” Manually adding Python to PATH (search online for instructions specific to your OS version) “pip is not recognized as an internal or external command” Similar to the above, pip might not be in your PATH. Try using:\npython -m pip install package_name Multiple Python Versions If you have multiple Python versions installed, you may need to specify which version to use:\npython3.9 script.py # Run with Python 3.9 In the next lesson, we’ll explore Python syntax fundamentals and start writing more sophisticated programs.","understanding-the-python-environment#Understanding the Python Environment":"Python Interpreter Python is an interpreted language, which means the Python interpreter reads and executes your code line by line. This is different from compiled languages where the entire program is translated to machine code before execution.\nPython Packages and pip Python’s functionality can be extended with packages (also called libraries or modules). The Python Package Index (PyPI) hosts thousands of third-party packages for various purposes.\nTo install packages, you use pip, Python’s package installer:\npip install package_name # On Windows pip3 install package_name # On macOS/Linux We’ll explore packages in more detail in later lessons.\nVirtual Environments As you advance in Python, you’ll learn about virtual environments, which allow you to create isolated Python environments for different projects. This is important for managing dependencies, but for now, the global Python installation is sufficient for learning the basics."},"title":"Setup Development Environment"},"/python-fundamentals/01-basics/03-syntax-basics/":{"data":{"":"Python’s syntax is designed to be readable and straightforward, making it an excellent language for beginners. Understanding the fundamental syntax rules is your first step toward writing effective Python code.","case-sensitivity#Case Sensitivity":"Python is case-sensitive, meaning that variables, function names, and all identifiers are sensitive to capitalization:\nname = \"John\" Name = \"Jane\" print(name) # Outputs: John print(Name) # Outputs: Jane # Case sensitivity applies to everything print(len(\"hello\")) # Works print(Len(\"hello\")) # NameError: name 'Len' is not defined ","checking-your-python-syntax#Checking Your Python Syntax":"Python offers several ways to check your syntax before executing code:\nPython Interpreter Checks\nPython checks syntax when you run a program and reports errors IDE Tools\nMost IDEs like PyCharm and VS Code highlight syntax errors as you type Linters\nTools like flake8, pylint, or pycodestyle check not only syntax but also style # Run the following in your terminal to check syntax without executing: python -m py_compile your_script.py ","comments#Comments":"Comments in Python start with the # character and extend to the end of the line:\n# This is a comment print(\"Hello\") # This is an inline comment Python also supports multi-line comments using triple quotes, which are technically multi-line strings but commonly used as comments:\n\"\"\" This is a multi-line comment. It spans multiple lines. Python technically treats this as a string that isn't assigned to anything. \"\"\" ","common-syntax-errors-for-beginners#Common Syntax Errors for Beginners":" Indentation Errors\nMixing tabs and spaces Inconsistent indentation levels Missing Colons\nForgetting the colon at the end of statements like if, for, def, etc. Incorrect Variable Names\nUsing Python keywords as variable names Starting variable names with numbers String Quote Mismatches\nStarting a string with one type of quote and ending with another Parentheses/Bracket Mismatches\nNot closing parentheses, brackets, or braces Example of common errors and fixes:\n# Error: Missing colon if x \u003e 5 print(\"x is greater than 5\") # Fix: if x \u003e 5: print(\"x is greater than 5\") # Error: Incorrect indentation if x \u003e 5: print(\"x is greater than 5\") # Fix: if x \u003e 5: print(\"x is greater than 5\") # Error: Invalid variable name 1st_name = \"John\" # Fix: first_name = \"John\" ","exercises#Exercises":"Exercise 1: Fix the syntax errors in the following code:\nif x = 10 print(x is equal to 10) def calculate_sum(a b): return a+b Exercise 2: Write a program that asks for a user’s name and age, then prints a message saying how old they will be in 10 years. Follow Python naming conventions and proper indentation.\nExercise 3: Create a function that converts temperature from Celsius to Fahrenheit. The formula is: F = C * 9/5 + 32. Make sure to include proper comments and docstrings.\nHint for Exercise 1: Look for missing colons, incorrect operators, and missing commas in function parameters.\nIn the next lesson, we’ll explore Python variables and data types in more detail, building on the syntax fundamentals we’ve covered here.","indentation#Indentation":"Unlike many programming languages that use braces {} to define blocks of code, Python uses indentation. This enforces clean, readable code but requires consistency.\n# Correct indentation if True: print(\"This is indented correctly\") if True: print(\"This is a nested block\") # Incorrect indentation will cause errors if True: print(\"This will cause an error\") # IndentationError Important: Python is strict about indentation. The standard practice is to use 4 spaces for each indentation level. Do not mix tabs and spaces, as this can lead to unexpected errors that are difficult to debug.","keywords#Keywords":"Python has a set of reserved keywords that cannot be used as variable names or identifiers:\nFalse await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield Note: To check if a word is a Python keyword, you can use the keyword module:\nimport keyword print(keyword.iskeyword(\"if\")) # True print(keyword.iskeyword(\"name\")) # False ","naming-conventions#Naming Conventions":"While not strictly syntax rules, Python has widely accepted naming conventions:\nVariable and function names should be lowercase, with words separated by underscores (snake_case): my_variable, calculate_total Class names should use CamelCase (start with a capital letter): MyClass, PersonData Constants are typically all uppercase: MAX_VALUE, PI Module names should be short, lowercase: math, sys, os Package names should be lowercase, preferably short: numpy, pandas # Variable names first_name = \"John\" last_name = \"Doe\" # Function name def calculate_area(radius): return 3.14 * radius ** 2 # Class name class Person: pass # Constant MAX_ATTEMPTS = 3 ","python-code-blocks#Python Code Blocks":"Python uses code blocks for structures like functions, loops, and conditional statements. A code block starts with a colon : and includes all indented lines that follow:\n# Function definition block def greet(name): print(\"Hello,\", name) print(\"Welcome to Python\") # If statement block age = 18 if age \u003e= 18: print(\"You are an adult\") print(\"You can vote\") else: print(\"You are a minor\") print(\"You cannot vote\") ","python-statement-termination#Python Statement Termination":"Unlike languages like C++ or Java, Python uses newlines to terminate statements, not semicolons:\nx = 10 y = 20 z = x + y This contributes to Python’s clean and readable syntax.","python-syntax-in-practice#Python Syntax in Practice":"Let’s look at a complete example that demonstrates the syntax elements we’ve covered:\n# This program demonstrates Python syntax fundamentals # Import a module import math # Define a constant PI = 3.14159 # Define a function def calculate_circle_area(radius): \"\"\" Calculate the area of a circle given its radius. This is a multi-line comment (docstring) that describes the function. \"\"\" return PI * radius ** 2 # Main program block if __name__ == \"__main__\": # Get user input radius_input = input(\"Enter the radius of the circle: \") # Convert string input to float radius = float(radius_input) # Conditional statement if radius \u003c= 0: print(\"Error: Radius must be positive\") else: # Calculate area using our function area = calculate_circle_area(radius) # Print results with formatted output print(f\"Area with our PI: {area:.2f}\") # Use the math module for a more accurate calculation accurate_area = math.pi * radius ** 2 print(f\"Area with math.pi: {accurate_area:.2f}\") # Demonstrate indentation in a nested block if area \u003e 100: print(\"That's a big circle!\") if area \u003e 1000: print(\"That's a VERY big circle!\") Expected Output (for input radius of 10):\nEnter the radius of the circle: 10 Area with our PI: 314.16 Area with math.pi: 314.16 That's a big circle! That's a VERY big circle! ","statements-and-lines#Statements and Lines":"In Python, a statement is typically written on a single line:\nprint(\"Hello, World!\") x = 5 You can place multiple statements on one line using semicolons, though this is not recommended for readability:\nprint(\"Hello\"); print(\"World\") # Valid but not recommended For long statements, you can spread them across multiple lines using the line continuation character \\ or implicit line continuation within parentheses, brackets, or braces:\n# Using line continuation character total = 1 + 2 + 3 + \\ 4 + 5 + 6 # Implicit line continuation (preferred) total = (1 + 2 + 3 + 4 + 5 + 6) colors = ['red', 'blue', 'green'] "},"title":"Syntax Fundamentals"},"/python-fundamentals/01-basics/04-variables-and-types/":{"data":{"":"Variables in Python are used to store data values. Unlike some other programming languages, Python has no command for declaring a variable. A variable is created the moment you first assign a value to it.","checking-data-types#Checking Data Types":"You can check the type of any variable using the type() function:\nx = 10 y = \"Hello\" z = 3.14 print(type(x)) # \u003cclass 'int'\u003e print(type(y)) # \u003cclass 'str'\u003e print(type(z)) # \u003cclass 'float'\u003e ","common-pitfalls-with-variables-and-data-types#Common Pitfalls with Variables and Data Types":" Modifying mutable objects unintentionally:\noriginal = [1, 2, 3] copy = original # This is a reference, not a copy copy.append(4) # Modifies both copy and original String immutability:\nname = \"John\" name[0] = \"B\" # Error: strings are immutable # Correct approach: name = \"B\" + name[1:] # Creates a new string Integer division:\nresult = 5 / 2 # 2.5 (float division) result = 5 // 2 # 2 (integer division) Comparing floating-point numbers:\nx = 0.1 + 0.2 # 0.30000000000000004 (not exactly 0.3) print(x == 0.3) # False # Better approach: import math print(math.isclose(x, 0.3)) # True Note: Python’s handling of variables is very different from languages like C, Java, or C#. In Python, variables are references to objects, not containers for values. This concept becomes particularly important when working with mutable objects like lists and dictionaries.","creating-variables#Creating Variables":"In Python, you create a variable by assigning a value to it using the equals sign (=):\n# Creating variables name = \"John\" age = 30 height = 5.9 is_student = True Python variable names are case-sensitive and must follow these rules:\nMust start with a letter or underscore Can only contain alphanumeric characters and underscores (A-Z, a-z, 0-9, and _) Cannot be a Python keyword # Valid variable names my_var = 10 _count = 20 total1 = 30 # Invalid variable names 1st_number = 40 # Cannot start with a digit my-name = \"John\" # Hyphens not allowed if = 50 # Cannot use keywords ","data-types-in-python#Data Types in Python":"Python has several built-in data types. The main categories are:\nNumeric Types: integers, floating-point numbers, and complex numbers Sequence Types: strings, lists, and tuples Mapping Type: dictionaries Set Types: sets and frozen sets Boolean Type: True or False None Type: represents the absence of a value Let’s explore each of these types in detail:\n1. Numeric Types Integers are whole numbers, positive or negative, without decimals:\nx = 10 y = -5 big_number = 1_000_000 # Underscores for readability in Python 3.6+ Floating-point numbers contain decimal points or use exponential notation:\npi = 3.14159 e = 2.71828 large_num = 1.5e6 # 1.5 million (1.5 × 10^6) small_num = 1.5e-6 # 0.0000015 (1.5 × 10^-6) Complex numbers have a real and imaginary part, written with a “j” as the imaginary part:\nz = 2 + 3j print(z.real) # 2.0 print(z.imag) # 3.0 2. Sequence Types Strings are sequences of characters, enclosed in single or double quotes:\nname = \"Alice\" message = 'Hello, World!' # Multi-line strings use triple quotes long_text = \"\"\"This is a longer text that spans multiple lines\"\"\" Lists are ordered, changeable collections that can contain different data types:\nfruits = [\"apple\", \"banana\", \"cherry\"] mixed_list = [1, \"hello\", 3.14, True] # Accessing list elements (indexing starts at 0) print(fruits[0]) # \"apple\" Tuples are ordered, unchangeable collections:\ncoordinates = (10, 20) rgb_color = (255, 0, 127) # Accessing tuple elements print(coordinates[0]) # 10 3. Mapping Type Dictionaries are unordered collections of key-value pairs:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Accessing dictionary values print(person[\"name\"]) # \"John\" 4. Set Types Sets are unordered collections of unique elements:\nfruits = {\"apple\", \"banana\", \"cherry\"} numbers = {1, 2, 3, 3, 4} # Duplicate values are automatically removed # Sets are useful for removing duplicates list_with_duplicates = [1, 2, 2, 3, 4, 4, 5] unique_numbers = set(list_with_duplicates) print(unique_numbers) # {1, 2, 3, 4, 5} 5. Boolean Type Boolean values represent truth values, either True or False:\nis_active = True is_complete = False print(10 \u003e 5) # True print(10 == 5) # False 6. None Type None represents the absence of a value or a null value:\nresult = None print(result) # None ","dynamic-typing#Dynamic Typing":"Python is dynamically typed, meaning you can reassign variables to different data types:\nx = 5 # x is an integer x = \"hello\" # Now x is a string x = [1, 2, 3] # Now x is a list This flexibility can be powerful but requires care to avoid unexpected errors.","exercises#Exercises":"Exercise 1: Create variables for storing information about a book including title (string), publication year (integer), price (float), is_available (boolean), and authors (list of strings). Print all the information with appropriate labels.\nExercise 2: Create a dictionary representing a shopping cart with at least 3 items. Each item should have a name, price, and quantity. Calculate and print the total cost of the cart.\nExercise 3: Given the string “Python is a versatile programming language”, write code to:\nConvert it to all uppercase Count how many times the letter ‘a’ appears Replace “Python” with “Java” and print the result Split it into a list of words Hint for Exercise 1: Remember to use appropriate variable names and print using formatted strings (f-strings) for cleaner output.\nIn the next section, we’ll explore operators and expressions in Python, building on your knowledge of variables and data types.","type-conversion#Type Conversion":"Python allows you to convert between different data types:\n# Converting between numeric types x = 10 float_x = float(x) # 10.0 complex_x = complex(x) # 10+0j # Converting to and from strings age = 30 age_str = str(age) # \"30\" age_back = int(age_str) # 30 # String to list greeting = \"Hello\" char_list = list(greeting) # ['H', 'e', 'l', 'l', 'o'] # List to tuple numbers = [1, 2, 3] numbers_tuple = tuple(numbers) # (1, 2, 3) Important: Converting between types can lead to data loss or errors. For example, converting a float to an integer truncates the decimal part, and trying to convert an invalid string to a number will raise an error.\n# Data loss example pi = 3.14159 pi_int = int(pi) # 3 (decimal part is lost) # Error example try: num = int(\"hello\") # This will raise a ValueError except ValueError as e: print(f\"Error: {e}\") # Error: invalid literal for int() with base 10: 'hello' ","variables-and-data-types-in-practice#Variables and Data Types in Practice":"Let’s see a complete example that demonstrates various data types and variable operations:\n# Student Record Management Example # Numeric types student_id = 12345 gpa = 3.75 complex_number = 1 + 2j # Not typically used in this context # String data first_name = \"Alice\" last_name = \"Smith\" full_name = first_name + \" \" + last_name # String concatenation # Boolean data is_enrolled = True is_on_probation = False # List - mutable sequence courses = [\"Math\", \"Physics\", \"Computer Science\"] courses.append(\"Chemistry\") # Adding a course # Tuple - immutable sequence semester_dates = (\"January 15, 2023\", \"May 20, 2023\") # Dictionary - key-value pairs student_info = { \"id\": student_id, \"name\": full_name, \"gpa\": gpa, \"courses\": courses, \"enrolled\": is_enrolled } # Set - unique elements unique_student_ids = {12345, 67890, 54321} # None - absence of value graduation_date = None # Not yet determined # Type conversions gpa_string = str(gpa) # Convert to string for formatting gpa_rounded = int(gpa) # Convert to integer (loses decimal precision) # Printing information print(f\"Student Record for {full_name} (ID: {student_id})\") print(f\"GPA: {gpa}\") print(f\"Courses: {', '.join(courses)}\") print(f\"Enrollment status: {'Enrolled' if is_enrolled else 'Not enrolled'}\") # Accessing dictionary values print(f\"Information from dictionary: {student_info['name']} has a GPA of {student_info['gpa']}\") # Checking types print(f\"Type of student_id: {type(student_id)}\") print(f\"Type of courses: {type(courses)}\") print(f\"Type of student_info: {type(student_info)}\") Expected Output:\nStudent Record for Alice Smith (ID: 12345) GPA: 3.75 Courses: Math, Physics, Computer Science, Chemistry Enrollment status: Enrolled Information from dictionary: Alice Smith has a GPA of 3.75 Type of student_id: \u003cclass 'int'\u003e Type of courses: \u003cclass 'list'\u003e Type of student_info: \u003cclass 'dict'\u003e ","variables-are-references#Variables are References":"In Python, variables are references to objects in memory. Understanding this concept is important:\na = [1, 2, 3] # 'a' references a list b = a # 'b' references the same list as 'a' b.append(4) # Modifies the list print(a) # [1, 2, 3, 4] - 'a' also reflects the change To create a copy rather than a reference:\na = [1, 2, 3] b = a.copy() # Creates a new list with the same elements b.append(4) print(a) # [1, 2, 3] - 'a' is unchanged print(b) # [1, 2, 3, 4] "},"title":"Variables and Data Types"},"/python-fundamentals/01-basics/05-operators-and-expressions/":{"data":{"":"In Python, operators are special symbols that perform operations on variables and values. An expression is a combination of values, variables, and operators that evaluates to a result.","arithmetic-expressions#Arithmetic Expressions":" result = 10 + 5 * 2 - 3 / 2 print(f\"10 + 5 * 2 - 3 / 2 = {result}\") # 18.5 ","arithmetic-operators#Arithmetic Operators":"Arithmetic operators perform mathematical operations on numeric values:\nOperator Name Example Result + Addition 5 + 3 8 - Subtraction 5 - 3 2 * Multiplication 5 * 3 15 / Division 5 / 3 1.6666667 % Modulus (remainder) 5 % 3 2 ** Exponentiation 5 ** 3 125 // Floor Division 5 // 3 1 # Arithmetic operators in action a = 10 b = 3 addition = a + b # 13 subtraction = a - b # 7 multiplication = a * b # 30 division = a / b # 3.3333333333333335 modulus = a % b # 1 exponent = a ** b # 1000 floor_div = a // b # 3 print(f\"Addition: {addition}\") print(f\"Subtraction: {subtraction}\") print(f\"Multiplication: {multiplication}\") print(f\"Division: {division}\") print(f\"Modulus: {modulus}\") print(f\"Exponentiation: {exponent}\") print(f\"Floor Division: {floor_div}\") Important: Division (/) always returns a float, while floor division (//) returns an integer by truncating the decimal part.","assignment-operators#Assignment Operators":"Assignment operators are used to assign values to variables:\nOperator Example Equivalent to = x = 5 x = 5 += x += 5 x = x + 5 -= x -= 5 x = x - 5 *= x *= 5 x = x * 5 /= x /= 5 x = x / 5 %= x %= 5 x = x % 5 **= x **= 5 x = x ** 5 //= x //= 5 x = x // 5 # Assignment operators in action x = 10 print(f\"Initial value: {x}\") # 10 x += 5 print(f\"After x += 5: {x}\") # 15 x -= 3 print(f\"After x -= 3: {x}\") # 12 x *= 2 print(f\"After x *= 2: {x}\") # 24 x /= 6 print(f\"After x /= 6: {x}\") # 4.0 x %= 3 print(f\"After x %= 3: {x}\") # 1.0 y = 2 y **= 3 print(f\"After y **= 3: {y}\") # 8 y //= 3 print(f\"After y //= 3: {y}\") # 2 ","bitwise-operators#Bitwise Operators":"Bitwise operators act on operands as if they were strings of binary digits:\nOperator Description Example \u0026 Bitwise AND 5 \u0026 3 (1) | Bitwise OR 5 | 3 (7) ^ Bitwise XOR 5 ^ 3 (6) ~ Bitwise NOT ~5 (-6) \u003c\u003c Left shift 5 \u003c\u003c 1 (10) \u003e\u003e Right shift 5 \u003e\u003e 1 (2) # Bitwise operators in action a = 5 # 101 in binary b = 3 # 011 in binary print(f\"a \u0026 b: {a \u0026 b}\") # 1 (001 in binary) print(f\"a | b: {a | b}\") # 7 (111 in binary) print(f\"a ^ b: {a ^ b}\") # 6 (110 in binary) print(f\"~a: {~a}\") # -6 (due to two's complement) print(f\"a \u003c\u003c 1: {a \u003c\u003c 1}\") # 10 (1010 in binary) print(f\"a \u003e\u003e 1: {a \u003e\u003e 1}\") # 2 (10 in binary) Note: Bitwise operators are less commonly used in everyday Python programming but are essential for certain types of low-level operations, especially in fields like cryptography, network programming, and embedded systems.","boolean-expressions#Boolean Expressions":" has_permission = is_admin or (is_editor and document_owner) ","common-mistakes-with-operators#Common Mistakes with Operators":" Using assignment (=) instead of equality comparison (==):\n# Incorrect if x = 5: # SyntaxError print(\"x is 5\") # Correct if x == 5: print(\"x is 5\") Incorrect operator precedence assumptions:\n# Might be expecting 9, but result is 7 result = 1 + 2 * 3 # Using parentheses for clarity result = (1 + 2) * 3 # 9 Floating-point precision issues:\n# Might expect True, but often False due to floating-point precision 0.1 + 0.2 == 0.3 # Better approach import math math.isclose(0.1 + 0.2, 0.3) Using is when you should use ==:\n# Incorrect for value comparison if a is 5: # Works sometimes due to Python's optimization, but unreliable print(\"a equals 5\") # Correct if a == 5: print(\"a equals 5\") ","comparison-expressions#Comparison Expressions":" is_valid = (age \u003e= 18) and (country in [\"USA\", \"Canada\", \"Mexico\"]) ","comparison-operators#Comparison Operators":"Comparison operators compare values and return Boolean results:\nOperator Description Example == Equal to 5 == 5 (True) != Not equal to 5 != 3 (True) \u003e Greater than 5 \u003e 3 (True) \u003c Less than 5 \u003c 3 (False) \u003e= Greater than or equal to 5 \u003e= 5 (True) \u003c= Less than or equal to 5 \u003c= 3 (False) # Comparison operators in action a = 10 b = 5 c = 10 print(f\"a == b: {a == b}\") # False print(f\"a != b: {a != b}\") # True print(f\"a \u003e b: {a \u003e b}\") # True print(f\"a \u003c b: {a \u003c b}\") # False print(f\"a \u003e= c: {a \u003e= c}\") # True print(f\"a \u003c= c: {a \u003c= c}\") # True Note: Don’t confuse the assignment operator (=) with the equality comparison operator (==). A common error is using = when you mean == in conditional statements.","exercises#Exercises":"Exercise 1: Write a program that calculates the area and perimeter of a rectangle. Ask the user for the length and width, and use appropriate operators to perform the calculations.\nExercise 2: Create a program that takes a user’s age as input and determines which category they fall into: child (0-12), teenager (13-19), adult (20-64), or senior (65+). Use logical operators for the conditions.\nExercise 3: Write a program that asks for three numbers and outputs them in ascending order (smallest to largest). Use comparison operators and conditional statements.\nHint for Exercise 1: The area of a rectangle is length × width, and the perimeter is 2 × (length + width).\nIn the next section, we’ll explore comments and documentation in Python, learning how to make your code more understandable and maintainable.","expressions-in-python#Expressions in Python":"An expression is a combination of values, variables, operators, and function calls that evaluates to a value. Python has several types of expressions:","identity-operators#Identity Operators":"Identity operators compare object identities:\nOperator Description Example is Returns True if both variables reference the same object x is y is not Returns True if both variables do not reference the same object x is not y # Identity operators in action a = [1, 2, 3] b = [1, 2, 3] c = a print(f\"a is b: {a is b}\") # False (different objects with same content) print(f\"a is c: {a is c}\") # True (same object) print(f\"a is not b: {a is not b}\") # True Note: The is operator checks if two variables refer to the same object in memory, while == checks if the contents of the objects are equal.","logical-operators#Logical Operators":"Logical operators combine conditional statements:\nOperator Description Example and Returns True if both statements are true x \u003c 5 and x \u003c 10 or Returns True if one of the statements is true x \u003c 5 or x \u003c 4 not Reverses the result, returns False if the result is true not(x \u003c 5 and x \u003c 10) # Logical operators in action x = 7 print(f\"x \u003e 5 and x \u003c 10: {x \u003e 5 and x \u003c 10}\") # True print(f\"x \u003e 5 and x \u003e 10: {x \u003e 5 and x \u003e 10}\") # False print(f\"x \u003e 5 or x \u003e 10: {x \u003e 5 or x \u003e 10}\") # True print(f\"not(x \u003e 5): {not(x \u003e 5)}\") # False Important: Python evaluates expressions from left to right. With and, if the first expression is False, Python doesn’t evaluate the second expression. With or, if the first expression is True, Python doesn’t evaluate the second expression. This is called short-circuit evaluation.","membership-operators#Membership Operators":"Membership operators test if a sequence contains an object:\nOperator Description Example in Returns True if a value exists in the sequence x in y not in Returns True if a value does not exist in the sequence x not in y # Membership operators in action fruits = [\"apple\", \"banana\", \"cherry\"] text = \"Hello, World!\" print(f\"'apple' in fruits: {'apple' in fruits}\") # True print(f\"'orange' in fruits: {'orange' in fruits}\") # False print(f\"'orange' not in fruits: {'orange' not in fruits}\") # True print(f\"'H' in text: {'H' in text}\") # True print(f\"'hello' in text: {'hello' in text}\") # False (case sensitive) ","operator-precedence#Operator Precedence":"Operators have a precedence that determines the order of evaluation in expressions with multiple operators:\nPrecedence Operator(s) Description 1 () Parentheses 2 ** Exponentiation 3 +x, -x, ~x Unary plus, minus, and bitwise NOT 4 *, /, //, % Multiplication, division, floor division, modulus 5 +, - Addition, subtraction 6 \u003c\u003c, \u003e\u003e Bitwise shifts 7 \u0026 Bitwise AND 8 ^ Bitwise XOR 9 | Bitwise OR 10 ==, !=, \u003e, \u003e=, \u003c, \u003c=, is, is not, in, not in Comparisons, identity, membership 11 not Logical NOT 12 and Logical AND 13 or Logical OR # Operator precedence in action x = 2 + 3 * 4 # 14, not 20 because * has higher precedence than + print(f\"2 + 3 * 4 = {x}\") y = (2 + 3) * 4 # 20, parentheses have highest precedence print(f\"(2 + 3) * 4 = {y}\") z = 2 ** 3 * 2 # 16, ** has higher precedence than * print(f\"2 ** 3 * 2 = {z}\") w = 5 + 4 \u003e 3 + 2 # True, arithmetic operations before comparison print(f\"5 + 4 \u003e 3 + 2: {w}\") v = not 1 + 2 == 3 # False, arithmetic and comparison before logical print(f\"not 1 + 2 == 3: {v}\") Important: When in doubt about operator precedence, use parentheses to explicitly specify the order of operations. This makes your code more readable and less prone to errors.","practical-example-temperature-converter#Practical Example: Temperature Converter":"The following example demonstrates the use of operators and expressions in a practical temperature converter:\ndef convert_temperature(): \"\"\" A function to convert temperatures between Celsius and Fahrenheit. Demonstrates operators and expressions in Python. \"\"\" print(\"Temperature Converter\") print(\"=====================\") print(\"1. Celsius to Fahrenheit\") print(\"2. Fahrenheit to Celsius\") choice = int(input(\"Enter your choice (1/2): \")) if choice == 1: # Celsius to Fahrenheit conversion celsius = float(input(\"Enter temperature in Celsius: \")) # The conversion formula: F = (C × 9/5) + 32 fahrenheit = (celsius * 9/5) + 32 print(f\"{celsius}°C is equal to {fahrenheit:.2f}°F\") # Additional information using comparison operators if celsius \u003c 0: print(\"That's below freezing!\") elif celsius == 0: print(\"That's the freezing point of water.\") elif celsius == 100: print(\"That's the boiling point of water at sea level.\") elif celsius \u003e 38: print(\"That's extremely hot!\") elif choice == 2: # Fahrenheit to Celsius conversion fahrenheit = float(input(\"Enter temperature in Fahrenheit: \")) # The conversion formula: C = (F - 32) × 5/9 celsius = (fahrenheit - 32) * 5/9 print(f\"{fahrenheit}°F is equal to {celsius:.2f}°C\") # Additional information using logical operators if fahrenheit \u003c 32: print(\"That's below freezing!\") elif fahrenheit == 32: print(\"That's the freezing point of water.\") elif fahrenheit == 212: print(\"That's the boiling point of water at sea level.\") elif fahrenheit \u003e 100 and celsius \u003c 38: print(\"That's hot but not extremely hot in Celsius.\") elif celsius \u003e= 38: print(\"That's extremely hot!\") else: print(\"Invalid choice. Please enter 1 or 2.\") # Call the function to run the temperature converter convert_temperature() Expected Output (for input choice 1 and temperature 25):\nTemperature Converter ===================== 1. Celsius to Fahrenheit 2. Fahrenheit to Celsius Enter your choice (1/2): 1 Enter temperature in Celsius: 25 25°C is equal to 77.00°F ","string-expressions#String Expressions":" greeting = \"Hello, \" + name + \"! Welcome to \" + platform formatted_greeting = f\"Hello, {name}! Welcome to {platform}\" "},"title":"Operators and Expressions"},"/python-fundamentals/01-basics/06-input-output-operations/":{"data":{"":"","common-io-issues-and-best-practices#Common I/O Issues and Best Practices":" Always use context managers (with statement) when working with files to ensure they are properly closed, even if an exception occurs.\nHandle file exceptions properly:\ntry: with open(\"file.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"The file does not exist.\") except PermissionError: print(\"You don't have permission to access this file.\") except Exception as e: print(f\"An error occurred: {e}\") Validate user input before processing:\nwhile True: try: age = int(input(\"Enter your age: \")) if age \u003c 0 or age \u003e 120: print(\"Please enter a valid age between 0 and 120.\") continue break except ValueError: print(\"Please enter a valid number.\") Use appropriate file modes to avoid accidentally overwriting data.\nConsider character encoding when working with text files:\nwith open(\"file.txt\", \"r\", encoding=\"utf-8\") as file: content = file.read() ","exercises#Exercises":"Exercise 1: Write a program that asks the user for their name, age, and favorite color. Then display a formatted message that includes this information.\nExercise 2: Create a program that reads a text file, counts the number of lines, words, and characters, and displays the results.\nExercise 3: Build a simple note-taking application that allows the user to add notes, view all notes, and save them to a file. When the program starts, it should load any existing notes from the file.\nHint for Exercise 1: Use the input() function to get user information and f-strings to format the output message.\nIn the next section, we’ll explore conditional statements in Python, learning how to make decisions in your programs based on different conditions.","input-and-output-operations#Input and Output Operations":"Input and output operations are fundamental to any programming language. They allow your program to interact with users, files, and other systems.\nBasic Output with print() The print() function displays text and variables to the console:\n# Simple print statement print(\"Hello, World!\") # Printing multiple items print(\"The answer is\", 42) # Printing with variables name = \"Alice\" age = 30 print(\"Name:\", name, \"Age:\", age) The print() function has several useful parameters:\nParameter Description Example sep Separator between items (default is space) print(\"Hello\", \"World\", sep=\"-\") end String at the end (default is newline) print(\"Hello\", end=\"! \") file File-like object to write to print(\"Log entry\", file=log_file) flush Whether to flush the stream print(\"Progress\", flush=True) # Using print parameters print(\"Apple\", \"Banana\", \"Cherry\", sep=\" | \") # Apple | Banana | Cherry # Preventing new line with end parameter print(\"Hello\", end=\" \") print(\"World!\") # Hello World! # Printing a numbered list for i in range(1, 4): print(i, end=\". \") print(f\"Item {i}\") # Output: # 1. Item 1 # 2. Item 2 # 3. Item 3 String Formatting in Output Python offers multiple ways to format strings for output:\n1. f-strings (Python 3.6+) name = \"Alice\" age = 30 print(f\"Name: {name}, Age: {age}\") # Name: Alice, Age: 30 # Expressions in f-strings print(f\"Age in 5 years: {age + 5}\") # Age in 5 years: 35 # Formatting specifications pi = 3.14159 print(f\"Pi to 2 decimal places: {pi:.2f}\") # Pi to 2 decimal places: 3.14 2. str.format() method name = \"Bob\" age = 25 print(\"Name: {}, Age: {}\".format(name, age)) # Name: Bob, Age: 25 # Positional references print(\"Age: {1}, Name: {0}\".format(name, age)) # Age: 25, Name: Bob # Named references print(\"Name: {n}, Age: {a}\".format(n=name, a=age)) # Name: Bob, Age: 25 3. % operator (older style) name = \"Charlie\" age = 35 print(\"Name: %s, Age: %d\" % (name, age)) # Name: Charlie, Age: 35 Important: f-strings (introduced in Python 3.6) are the recommended approach for string formatting due to their readability and performance. They allow embedding expressions directly in string literals.\nBasic Input with input() The input() function reads a line from the console (as a string):\n# Simple input name = input(\"Enter your name: \") print(f\"Hello, {name}!\") # Note: input() always returns a string age_str = input(\"Enter your age: \") age = int(age_str) # Convert to integer print(f\"In 5 years, you will be {age + 5} years old.\") # Converting directly height = float(input(\"Enter your height in meters: \")) print(f\"Your height in centimeters: {height * 100}\") Note: Always validate user input before conversion to avoid errors. For example, if a user enters “twenty” when you expect a number, int(\"twenty\") will raise a ValueError.\n# Safe input conversion try: age = int(input(\"Enter your age: \")) print(f\"In 5 years, you will be {age + 5} years old.\") except ValueError: print(\"Invalid input. Please enter a number.\") Formatting Console Output You can enhance console output with various formatting techniques:\n# Creating tables print(\"Name\\tAge\\tCity\") print(\"----\\t---\\t----\") print(\"Alice\\t30\\tNew York\") print(\"Bob\\t25\\tChicago\") print(\"Charlie\\t35\\tSan Francisco\") # Using f-strings for table formatting data = [ {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}, {\"name\": \"Bob\", \"age\": 25, \"city\": \"Chicago\"}, {\"name\": \"Charlie\", \"age\": 35, \"city\": \"San Francisco\"} ] print(f\"{'Name':\u003c10}{'Age':\u003c8}{'City':\u003c15}\") print(f\"{'-'*10:\u003c10}{'-'*8:\u003c8}{'-'*15:\u003c15}\") for person in data: print(f\"{person['name']:\u003c10}{person['age']:\u003c8}{person['city']:\u003c15}\") Output:\nName Age City -------------- --------------- Alice 30 New York Bob 25 Chicago Charlie 35 San Francisco In the format specifiers ({value:\u003cwidth}):\n\u003c left-aligns text (default) \u003e right-aligns text ^ centers text The number represents the width Reading and Writing Files File I/O is a common operation in Python programs:\nOpening and Closing Files # Opening a file for reading ('r' is default mode) file = open(\"example.txt\", \"r\") content = file.read() file.close() # Important to close files # Better approach with context manager (automatically closes file) with open(\"example.txt\", \"r\") as file: content = file.read() # File is automatically closed when the block ends File Modes Mode Description 'r' Read (default) 'w' Write (create or truncate) 'a' Append (create if doesn’t exist) 'x' Exclusive creation (fail if file exists) 'b' Binary mode (add to other modes) 't' Text mode (default) '+' Update (read and write) Reading Files # Reading the entire file with open(\"example.txt\", \"r\") as file: content = file.read() print(content) # Reading line by line with open(\"example.txt\", \"r\") as file: for line in file: print(line.strip()) # strip() removes trailing newline # Reading all lines into a list with open(\"example.txt\", \"r\") as file: lines = file.readlines() for line in lines: print(line.strip()) Writing Files # Writing to a file (creates or overwrites) with open(\"output.txt\", \"w\") as file: file.write(\"Hello, World!\\n\") file.write(\"This is a new line.\") # Appending to a file with open(\"output.txt\", \"a\") as file: file.write(\"\\nThis line is appended.\") # Writing multiple lines lines = [\"Line 1\", \"Line 2\", \"Line 3\"] with open(\"output.txt\", \"w\") as file: file.writelines(line + \"\\n\" for line in lines) Working with CSV Files CSV (Comma-Separated Values) files are commonly used for tabular data:\nimport csv # Reading a CSV file with open(\"data.csv\", \"r\", newline=\"\") as file: reader = csv.reader(file) for row in reader: print(row) # row is a list of values # Reading a CSV with headers with open(\"data.csv\", \"r\", newline=\"\") as file: reader = csv.DictReader(file) # Assumes first row has headers for row in reader: print(row) # row is a dictionary # Writing a CSV file data = [ [\"Name\", \"Age\", \"City\"], [\"Alice\", 30, \"New York\"], [\"Bob\", 25, \"Chicago\"], [\"Charlie\", 35, \"San Francisco\"] ] with open(\"new_data.csv\", \"w\", newline=\"\") as file: writer = csv.writer(file) writer.writerows(data) # Writing a CSV with dictionaries data = [ {\"Name\": \"Alice\", \"Age\": 30, \"City\": \"New York\"}, {\"Name\": \"Bob\", \"Age\": 25, \"City\": \"Chicago\"}, {\"Name\": \"Charlie\", \"Age\": 35, \"City\": \"San Francisco\"} ] with open(\"new_data.csv\", \"w\", newline=\"\") as file: fieldnames = [\"Name\", \"Age\", \"City\"] writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() writer.writerows(data) Working with JSON Files JSON (JavaScript Object Notation) is a popular data format:\nimport json # Reading JSON from a file with open(\"data.json\", \"r\") as file: data = json.load(file) print(data) # data is a Python dictionary or list # Writing Python data to a JSON file data = { \"people\": [ {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}, {\"name\": \"Bob\", \"age\": 25, \"city\": \"Chicago\"}, {\"name\": \"Charlie\", \"age\": 35, \"city\": \"San Francisco\"} ] } with open(\"new_data.json\", \"w\") as file: json.dump(data, file, indent=4) # indent for pretty formatting ","practical-example-contact-manager#Practical Example: Contact Manager":"Let’s create a simple contact manager that demonstrates various input and output operations:\nimport json import os def contact_manager(): \"\"\" A simple contact manager that demonstrates input/output operations. \"\"\" contacts_file = \"contacts.json\" contacts = [] # Load existing contacts if the file exists if os.path.exists(contacts_file): try: with open(contacts_file, \"r\") as file: contacts = json.load(file) print(f\"Loaded {len(contacts)} contacts from {contacts_file}\") except json.JSONDecodeError: print(f\"Error loading {contacts_file}. Starting with empty contacts.\") while True: # Display menu print(\"\\nContact Manager\") print(\"===============\") print(\"1. View all contacts\") print(\"2. Add a contact\") print(\"3. Search contacts\") print(\"4. Save and exit\") choice = input(\"\\nEnter your choice (1-4): \") if choice == \"1\": # View all contacts if not contacts: print(\"No contacts found.\") else: print(\"\\n{:\u003c20} {:\u003c15} {:\u003c30}\".format(\"Name\", \"Phone\", \"Email\")) print(\"-\" * 65) for contact in contacts: print(\"{:\u003c20} {:\u003c15} {:\u003c30}\".format( contact.get(\"name\", \"N/A\"), contact.get(\"phone\", \"N/A\"), contact.get(\"email\", \"N/A\") )) elif choice == \"2\": # Add a contact name = input(\"Enter name: \") phone = input(\"Enter phone number: \") email = input(\"Enter email: \") contact = {\"name\": name, \"phone\": phone, \"email\": email} contacts.append(contact) print(f\"Contact {name} added successfully.\") elif choice == \"3\": # Search contacts search_term = input(\"Enter search term: \").lower() found = False print(\"\\n{:\u003c20} {:\u003c15} {:\u003c30}\".format(\"Name\", \"Phone\", \"Email\")) print(\"-\" * 65) for contact in contacts: name = contact.get(\"name\", \"\").lower() phone = contact.get(\"phone\", \"\").lower() email = contact.get(\"email\", \"\").lower() if (search_term in name or search_term in phone or search_term in email): print(\"{:\u003c20} {:\u003c15} {:\u003c30}\".format( contact.get(\"name\", \"N/A\"), contact.get(\"phone\", \"N/A\"), contact.get(\"email\", \"N/A\") )) found = True if not found: print(\"No matching contacts found.\") elif choice == \"4\": # Save and exit with open(contacts_file, \"w\") as file: json.dump(contacts, file, indent=4) print(f\"Contacts saved to {contacts_file}\") break else: print(\"Invalid choice. Please enter a number between 1 and 4.\") # Run the contact manager if __name__ == \"__main__\": contact_manager() Expected Output:\nLoaded 2 contacts from contacts.json Contact Manager =============== 1. View all contacts 2. Add a contact 3. Search contacts 4. Save and exit Enter your choice (1-4): 1 Name Phone Email ----------------------------------------------------------------- John Doe 555-123-4567 john.doe@example.com Jane Smith 555-987-6543 jane.smith@example.com Contact Manager =============== 1. View all contacts 2. Add a contact 3. Search contacts 4. Save and exit Enter your choice (1-4): 2 Enter name: Alice Johnson Enter phone number: 555-555-5555 Enter email: alice.j@example.com Contact Alice Johnson added successfully. Contact Manager =============== 1. View all contacts 2. Add a contact 3. Search contacts 4. Save and exit Enter your choice (1-4): 4 Contacts saved to contacts.json "},"title":"Input and Output Statements"},"/python-fundamentals/02-control-flow/":{"data":{"":"Explore the following sections on Python control flow structures:\n01. Introduction to Python 02. Setup 03. Syntax Basics 04. Variables and Types 05. Operators and Expressions "},"title":"Control Flow"},"/python-fundamentals/02-control-flow/01-conditional-statements/":{"data":{"":"","age-group-classifier#Age Group Classifier":" def classify_age(age): \"\"\" Classify a person into an age group based on their age. Args: age (int): The person's age in years Returns: str: The age group classification \"\"\" if not isinstance(age, (int, float)): return \"Invalid age. Please provide a number.\" if age \u003c 0: return \"Invalid age. Age cannot be negative.\" elif age \u003c 2: return \"Infant\" elif age \u003c 13: return \"Child\" elif age \u003c 18: return \"Teenager\" elif age \u003c 65: return \"Adult\" else: return \"Senior\" # Test the function with different ages print(classify_age(1)) # Infant print(classify_age(10)) # Child print(classify_age(16)) # Teenager print(classify_age(35)) # Adult print(classify_age(70)) # Senior print(classify_age(-5)) # Invalid age print(classify_age(\"20\")) # Invalid age ","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"1. Using = instead of == in conditions A common mistake is using the assignment operator = instead of the equality operator == in conditions:\n# Incorrect - this assigns 10 to x and always evaluates to True if x = 10: print(\"x is 10\") # Correct - this checks if x equals 10 if x == 10: print(\"x is 10\") 2. Forgetting the colon : after conditions # Incorrect - missing colon if x \u003e 10 print(\"x is greater than 10\") # Correct if x \u003e 10: print(\"x is greater than 10\") 3. Incorrect indentation # Incorrect - inconsistent indentation if x \u003e 10: print(\"x is greater than 10\") print(\"This will cause an IndentationError\") # Correct if x \u003e 10: print(\"x is greater than 10\") print(\"This has the same indentation level\") 4. Using is when == is appropriate # Incorrect for value comparison if x is 10: # Works for some simple values due to implementation details but unreliable print(\"x is 10\") # Correct if x == 10: print(\"x is 10\") # `is` is appropriate for checking against None if x is None: print(\"x is None\") 5. Unnecessary else after return # Unnecessarily verbose def is_adult(age): if age \u003e= 18: return True else: # This else is unnecessary return False # More concise def is_adult(age): if age \u003e= 18: return True return False # Even more concise - directly return the condition result def is_adult(age): return age \u003e= 18 6. Complex nested conditions # Hard to read with deep nesting if condition1: if condition2: if condition3: do_something() else: do_something_else() else: do_yet_another_thing() # More readable with combined conditions if condition1 and condition2 and condition3: do_something() elif condition1 and condition2: do_something_else() elif condition1: do_yet_another_thing() 7. Early returns for cleaner code # Unnecessarily nested def process_data(data): if data: if validate(data): result = transform(data) if result: return result return None # Cleaner with early returns def process_data(data): if not data: return None if not validate(data): return None result = transform(data) if not result: return None return result ","comparison-operators-in-conditions#Comparison Operators in Conditions":"","conditional-expressions-ternary-operator#Conditional Expressions (Ternary Operator)":"","exercises#Exercises":"Exercise 1: Write a program that asks for a user’s age and determines if they are eligible to vote (18 or older). The program should handle invalid inputs (like negative ages or non-numeric values) gracefully.\nExercise 2: Create a function that takes a temperature and a scale (‘C’ for Celsius or ‘F’ for Fahrenheit) and returns a description of the weather (e.g., “Cold”, “Moderate”, “Hot”). Define your own temperature ranges for each category.\nExercise 3: Write a program that simulates a simple ATM. It should ask for a PIN, check if it’s correct (use a hardcoded PIN for this exercise), and then allow the user to check their balance, deposit money, or withdraw money. Use nested if statements or a combination of if-elif-else statements.\nHint for Exercise 1: Use a try-except block to handle non-numeric inputs, and an if statement to check for negative ages.\n# Exercise 1 solution outline try: age = int(input(\"Enter your age: \")) if age \u003c 0: print(\"Age cannot be negative.\") elif age \u003e= 18: print(\"You are eligible to vote.\") else: print(\"You are not eligible to vote yet.\") except ValueError: print(\"Invalid input. Please enter a numeric age.\") In the next section, we’ll explore loops in Python, including for and while loops, which allow you to repeat code execution.","logical-operators-for-combining-conditions#Logical Operators for Combining Conditions":"","nested-conditional-statements#Nested Conditional Statements":"","password-strength-checker#Password Strength Checker":" def check_password_strength(password): \"\"\" Check the strength of a password based on various criteria. Args: password (str): The password to check Returns: str: A description of the password strength \"\"\" if not isinstance(password, str): return \"Invalid password. Password must be a string.\" # Check password length if len(password) \u003c 8: return \"Weak: Password should be at least 8 characters long.\" # Initialize strength checks has_uppercase = False has_lowercase = False has_digit = False has_special = False # Define special characters special_chars = \"!@#$%^\u0026*()-_=+[]{}|;:'\\\",.\u003c\u003e/?\" # Check each character in the password for char in password: if char.isupper(): has_uppercase = True elif char.islower(): has_lowercase = True elif char.isdigit(): has_digit = True elif char in special_chars: has_special = True # Determine strength based on criteria met if has_uppercase and has_lowercase and has_digit and has_special: if len(password) \u003e= 12: return \"Very Strong: Excellent password!\" else: return \"Strong: Good password, but could be longer.\" elif (has_uppercase and has_lowercase and has_digit) or \\ (has_uppercase and has_lowercase and has_special) or \\ (has_uppercase and has_digit and has_special) or \\ (has_lowercase and has_digit and has_special): return \"Moderate: Password meets some criteria but not all.\" else: return \"Weak: Password should contain uppercase letters, lowercase letters, digits, and special characters.\" # Test the function with different passwords print(check_password_strength(\"password\")) # Weak (length is good but missing criteria) print(check_password_strength(\"Password123\")) # Moderate (missing special chars) print(check_password_strength(\"Pas$word123\")) # Strong print(check_password_strength(\"Str0ng\u0026SecurePa$$word\")) # Very Strong ","practical-examples#Practical Examples":"","simple-calculator#Simple Calculator":" def simple_calculator(): \"\"\"A simple calculator that performs basic arithmetic operations.\"\"\" print(\"Simple Calculator\") print(\"=================\") print(\"Operations:\") print(\"1. Addition (+)\") print(\"2. Subtraction (-)\") print(\"3. Multiplication (*)\") print(\"4. Division (/)\") try: num1 = float(input(\"Enter first number: \")) num2 = float(input(\"Enter second number: \")) operation = input(\"Enter operation (1-4): \") if operation == \"1\": result = num1 + num2 print(f\"{num1} + {num2} = {result}\") elif operation == \"2\": result = num1 - num2 print(f\"{num1} - {num2} = {result}\") elif operation == \"3\": result = num1 * num2 print(f\"{num1} * {num2} = {result}\") elif operation == \"4\": if num2 == 0: print(\"Error: Division by zero is not allowed.\") else: result = num1 / num2 print(f\"{num1} / {num2} = {result}\") else: print(\"Invalid operation. Please enter a number between 1 and 4.\") except ValueError: print(\"Invalid input. Please enter numeric values.\") # Run the calculator simple_calculator() ","the-elif-statement#The \u003ccode\u003eelif\u003c/code\u003e Statement":"","the-else-statement#The \u003ccode\u003eelse\u003c/code\u003e Statement":"","the-if-statement#The \u003ccode\u003eif\u003c/code\u003e Statement":"","the-is-and-in-operators-in-conditions#The \u003ccode\u003eis\u003c/code\u003e and \u003ccode\u003ein\u003c/code\u003e Operators in Conditions":"Conditional statements allow your program to make decisions based on certain conditions. They are fundamental building blocks in programming that enable your code to take different paths depending on whether specific conditions are true or false.\nThe if Statement The basic form of a conditional statement in Python is the if statement:\nif condition: # Code to execute if condition is True When Python encounters an if statement, it evaluates the condition. If the condition is True, the indented code block beneath it executes. If the condition is False, the indented code block is skipped.\nage = 18 if age \u003e= 18: print(\"You are an adult.\") print(\"You can vote.\") print(\"This line always executes regardless of the condition.\") In this example, if the variable age is 18 or greater, both lines inside the if block will execute. The final print statement is outside the if block, so it always executes.\nThe else Statement The else statement provides an alternative code block to execute when the if condition is False:\nif condition: # Code to execute if condition is True else: # Code to execute if condition is False age = 15 if age \u003e= 18: print(\"You are an adult.\") print(\"You can vote.\") else: print(\"You are not yet an adult.\") print(\"You cannot vote yet.\") print(\"This line always executes regardless of the condition.\") In this example, since age is 15 (less than 18), the else block executes instead of the if block.\nThe elif Statement The elif (short for “else if”) statement allows you to check multiple conditions in sequence:\nif condition1: # Code to execute if condition1 is True elif condition2: # Code to execute if condition1 is False and condition2 is True elif condition3: # Code to execute if condition1 and condition2 are False and condition3 is True else: # Code to execute if all conditions are False score = 85 if score \u003e= 90: grade = \"A\" elif score \u003e= 80: grade = \"B\" elif score \u003e= 70: grade = \"C\" elif score \u003e= 60: grade = \"D\" else: grade = \"F\" print(f\"Your grade is: {grade}\") In this grading example, Python checks each condition in order until it finds one that is True. In this case, score is 85, so the second condition (score \u003e= 80) is the first one that evaluates to True. Therefore, grade is set to “B”.\nImportant: Python checks conditions in the order they appear. Once it finds a condition that is True, it executes that block and then skips all the remaining conditions in that if-elif-else chain.\nNested Conditional Statements You can place conditional statements inside other conditional statements, creating nested structures:\nage = 25 income = 50000 if age \u003e= 18: print(\"You are an adult.\") if income \u003e= 30000: print(\"You earn above the minimum income threshold.\") if income \u003e= 100000: print(\"You are in the high-income bracket.\") else: print(\"You are in the middle-income bracket.\") else: print(\"Your income is below the minimum threshold.\") else: print(\"You are not yet an adult.\") Nested conditionals allow for more complex decision-making but can become difficult to read if too deeply nested. It’s often better to keep your code as flat as possible.\nConditional Expressions (Ternary Operator) Python offers a concise way to write simple if-else statements using conditional expressions, sometimes called the ternary operator:\n# Standard if-else if condition: x = value1 else: x = value2 # Equivalent conditional expression x = value1 if condition else value2 age = 20 status = \"adult\" if age \u003e= 18 else \"minor\" print(status) # Output: \"adult\" # Price calculation with ternary operator is_member = True price = 50.0 * (0.9 if is_member else 1.0) # 10% discount for members print(price) # Output: 45.0 Conditional expressions are ideal for simple assignments based on conditions, making the code more compact and readable in these cases.\nTruthy and Falsy Values In Python, conditions don’t have to be explicit boolean expressions. Any value can be interpreted as a boolean in an if statement:\nFalsy values (interpreted as False):\nFalse None Zero of any numeric type (0, 0.0, 0j) Empty sequences and collections ('', (), [], {}, set()) Objects that define __bool__() to return False or __len__() to return 0 Truthy values (interpreted as True):\nEverything else # Examples of truthy and falsy values name = \"\" numbers = [1, 2, 3] zero = 0 if name: print(\"Name is not empty\") # This won't execute because name is an empty string (falsy) if numbers: print(\"List is not empty\") # This will execute because numbers is a non-empty list (truthy) if zero: print(\"Zero is truthy\") # This won't execute because 0 is falsy else: print(\"Zero is falsy\") # This will execute This behavior allows for concise code to check if a variable has a meaningful value:\nuser_input = input(\"Enter your name: \") if user_input: print(f\"Hello, {user_input}!\") else: print(\"You didn't enter a name.\") Comparison Operators in Conditions Conditions often use comparison operators to compare values:\nOperator Description Example == Equal to x == y != Not equal to x != y \u003e Greater than x \u003e y \u003c Less than x \u003c y \u003e= Greater than or equal to x \u003e= y \u003c= Less than or equal to x \u003c= y x = 10 y = 20 if x == y: print(\"x equals y\") elif x \u003e y: print(\"x is greater than y\") else: print(\"x is less than y\") # This will execute Logical Operators for Combining Conditions You can combine multiple conditions using logical operators:\nOperator Description Example and True if both conditions are true x \u003e 0 and x \u003c 10 or True if at least one condition is true x \u003c 0 or x \u003e 10 not Inverts the result, True becomes False and vice versa not x == y age = 25 income = 50000 if age \u003e= 18 and income \u003e= 30000: print(\"You qualify for the loan.\") temperature = 15 if temperature \u003c 0 or temperature \u003e 30: print(\"Extreme temperature warning.\") is_weekend = True if not is_weekend: print(\"It's a weekday.\") else: print(\"It's the weekend.\") # This will execute When combining conditions with logical operators, understanding the order of evaluation is important:\nParentheses not and or # This condition is more complex but follows the rules of precedence if (age \u003e= 18 and income \u003e= 30000) or (has_guarantor and has_collateral): print(\"Loan application accepted\") The is and in Operators in Conditions The is operator checks if two variables refer to the same object in memory:\na = [1, 2, 3] b = [1, 2, 3] c = a if a is c: print(\"a and c reference the same object\") # This will execute if a is b: print(\"a and b reference the same object\") # This won't execute else: print(\"a and b are different objects with the same content\") # This will execute The in operator checks if a value exists in a sequence:\nfruits = [\"apple\", \"banana\", \"cherry\"] if \"banana\" in fruits: print(\"Banana is in the list\") # This will execute name = \"John\" if \"o\" in name: print(\"The letter 'o' is in the name\") # This will execute Note: Don’t confuse == (equality of values) with is (identity of objects). For most comparisons, you should use ==. The is operator is primarily used to check if a variable is None or to verify object identity.","truthy-and-falsy-values#Truthy and Falsy Values":""},"title":"Conditional Statements"},"/python-fundamentals/02-control-flow/02-loops/":{"data":{"":"","dictionary-comprehensions#Dictionary Comprehensions":"Similar to list comprehensions, you can create dictionaries in a concise way:\n# Create a dictionary of squares squares_dict = {i: i ** 2 for i in range(1, 6)} print(squares_dict) # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} # Create a dictionary with a condition even_squares_dict = {i: i ** 2 for i in range(1, 11) if i % 2 == 0} print(even_squares_dict) # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100} Practical Examples Example 1: Sum of Numbers Calculate the sum of all numbers from 1 to n using both for and while loops:\ndef sum_with_for(n): \"\"\"Calculate the sum of numbers from 1 to n using a for loop.\"\"\" total = 0 for i in range(1, n + 1): total += i return total def sum_with_while(n): \"\"\"Calculate the sum of numbers from 1 to n using a while loop.\"\"\" total = 0 i = 1 while i \u003c= n: total += i i += 1 return total # Test both functions n = 10 print(f\"Sum of numbers from 1 to {n} (for loop): {sum_with_for(n)}\") print(f\"Sum of numbers from 1 to {n} (while loop): {sum_with_while(n)}\") Example 2: FizzBuzz The classic programming challenge:\ndef fizzbuzz(n): \"\"\" Print numbers from 1 to n, but for multiples of 3 print \"Fizz\", for multiples of 5 print \"Buzz\", and for multiples of both print \"FizzBuzz\". \"\"\" for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: print(\"FizzBuzz\") elif i % 3 == 0: print(\"Fizz\") elif i % 5 == 0: print(\"Buzz\") else: print(i) # Run FizzBuzz for numbers 1 to 15 fizzbuzz(15) Example 3: Prime Number Finder Find all prime numbers up to a given limit:\ndef find_primes(limit): \"\"\"Find all prime numbers up to the given limit.\"\"\" primes = [] for num in range(2, limit + 1): is_prime = True # Check if num is divisible by any smaller number for divisor in range(2, int(num ** 0.5) + 1): if num % divisor == 0: is_prime = False break if is_prime: primes.append(num) return primes # Find all primes up to 50 print(find_primes(50)) Example 4: Word Counter Count the occurrences of each word in a text:\ndef count_words(text): \"\"\"Count the occurrences of each word in the given text.\"\"\" # Create an empty dictionary to store word counts word_counts = {} # Split the text into words words = text.split() # Loop through each word for word in words: # Remove punctuation and convert to lowercase clean_word = word.strip(\".,!?\\\"'()[]{}:;\").lower() if clean_word: # Skip empty strings # Increment the count for this word if clean_word in word_counts: word_counts[clean_word] += 1 else: word_counts[clean_word] = 1 return word_counts # Sample text sample_text = \"\"\" Python is a powerful programming language. Python is easy to learn. Python is used for web development, data analysis, artificial intelligence, and more. \"\"\" # Count words result = count_words(sample_text) # Print the results in a readable format print(\"Word Counts:\") for word, count in sorted(result.items()): print(f\"{word}: {count}\") Loop Efficiency and Best Practices 1. Choose the Right Loop Use for loops when you know the number of iterations in advance or when iterating over a collection. Use while loops when you need to continue until a condition changes or for indefinite iterations. # Good use of for loop for i in range(10): print(i) # Good use of while loop response = \"\" while response != \"quit\": response = input(\"Enter a command (type 'quit' to exit): \") # Process the response 2. Avoid Modifying the Iteration Variable in a for Loop In Python, the iteration variable is automatically updated by the loop mechanism. Modifying it manually can lead to unexpected behavior:\n# Problematic - modifying the iteration variable for i in range(5): print(i) i += 2 # This has no effect on the loop's behavior # Better approach if you need to skip items i = 0 while i \u003c 5: print(i) i += 3 # Skip by incrementing more than 1 3. Avoid Modifying Collections During Iteration Modifying a collection while iterating over it can lead to unexpected behavior:\n# Problematic - modifying a list during iteration numbers = [1, 2, 3, 4, 5] for num in numbers: if num % 2 == 0: numbers.remove(num) # This modifies the list being iterated # Better approach numbers = [1, 2, 3, 4, 5] numbers = [num for num in numbers if num % 2 != 0] # or odd_numbers = [] for num in numbers: if num % 2 != 0: odd_numbers.append(num) numbers = odd_numbers 4. Use enumerate() Instead of Manual Counting # Manual index tracking fruits = [\"apple\", \"banana\", \"cherry\"] index = 0 for fruit in fruits: print(f\"{index}: {fruit}\") index += 1 # Better approach with enumerate() for index, fruit in enumerate(fruits): print(f\"{index}: {fruit}\") 5. Use List Comprehensions for Simple Transformations # Traditional loop for transformation numbers = [1, 2, 3, 4, 5] squared = [] for num in numbers: squared.append(num ** 2) # Cleaner approach with list comprehension numbers = [1, 2, 3, 4, 5] squared = [num ** 2 for num in numbers] 6. Break Out of Complex Loops Early def find_item(matrix, target): \"\"\"Find an item in a 2D matrix.\"\"\" for i, row in enumerate(matrix): for j, value in enumerate(row): if value == target: return (i, j) # Return early when found return None # Not found 7. Be Aware of the Performance Impact of Nested Loops Nested loops multiply the number of iterations, which can impact performance for large data sets:\n# This runs in O(n²) time n = 1000 for i in range(n): for j in range(n): # Some operation # Consider if there's a more efficient algorithm Common Loop Patterns Pattern 1: Loop with a Counter count = 0 for item in collection: if condition(item): count += 1 print(f\"Found {count} items matching the condition\") Pattern 2: Find the Maximum/Minimum Value numbers = [23, 54, 12, 87, 34] max_value = numbers[0] # Assume the first item is the maximum for num in numbers[1:]: # Start from the second item if num \u003e max_value: max_value = num print(f\"The maximum value is {max_value}\") Pattern 3: Filtering Items original = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] filtered = [] for num in original: if num % 2 == 0: # Keep only even numbers filtered.append(num) print(filtered) # [2, 4, 6, 8, 10] # Alternatively, using list comprehension filtered = [num for num in original if num % 2 == 0] Pattern 4: Aggregating Values expenses = [120.50, 35.75, 240.00, 55.25, 100.00] total = 0 for expense in expenses: total += expense print(f\"Total expenses: ${total:.2f}\") # Alternatively, using sum() total = sum(expenses) Pattern 5: Nested Loop for Combinations fruits = [\"apple\", \"banana\", \"cherry\"] colors = [\"red\", \"green\", \"blue\"] combinations = [] for fruit in fruits: for color in colors: combinations.append((fruit, color)) print(combinations) # [('apple', 'red'), ('apple', 'green'), ('apple', 'blue'), # ('banana', 'red'), ('banana', 'green'), ('banana', 'blue'), # ('cherry', 'red'), ('cherry', 'green'), ('cherry', 'blue')] # Alternatively, using list comprehension combinations = [(fruit, color) for fruit in fruits for color in colors] ","exercises#Exercises":"Exercise 1: Write a program that prints the multiplication table for a given number. For example, if the number is 5, it should print:\n5 x 1 = 5 5 x 2 = 10 ... 5 x 10 = 50 Exercise 2: Create a program that generates a list of all even numbers between 1 and 100 using a loop. Then create the same list using a list comprehension.\nExercise 3: Write a program that asks the user for a number and then prints all the factors of that number. A factor is a number that divides the given number without a remainder.\nExercise 4: Create a nested loop to generate a “pyramid” pattern like this:\n* ** *** **** ***** Hint for Exercise 1: Use a for loop with the range function to iterate from 1 to 10, and in each iteration, multiply the given number by the current loop variable.\n# Exercise 1 solution outline num = 5 for i in range(1, 11): result = num * i print(f\"{num} x {i} = {result}\") In the next section, we’ll explore break and continue statements in more detail, learn about the pass statement, and introduce exception handling basics.","list-comprehensions#List Comprehensions":"Python offers a concise way to create lists using a single line of code called a list comprehension:\n# Traditional approach squares = [] for i in range(1, 6): squares.append(i ** 2) print(squares) # [1, 4, 9, 16, 25] # List comprehension approach squares = [i ** 2 for i in range(1, 6)] print(squares) # [1, 4, 9, 16, 25] You can also add conditions to list comprehensions:\n# Only include squares of even numbers even_squares = [i ** 2 for i in range(1, 11) if i % 2 == 0] print(even_squares) # [4, 16, 36, 64, 100] List comprehensions can replace many common for-loop patterns and make your code more concise and readable.","loop-control-statements#Loop Control Statements":"Python provides several statements to control the flow of loops:\nThe break Statement The break statement exits the innermost loop prematurely:\nfor i in range(1, 10): if i == 5: break # Exit the loop when i equals 5 print(i) # Output: 1 2 3 4 The continue Statement The continue statement skips the rest of the current iteration and jumps to the next iteration:\nfor i in range(1, 10): if i % 2 == 0: continue # Skip even numbers print(i) # Output: 1 3 5 7 9 The else Clause in Loops Surprisingly, Python allows an else clause with loops. The else block executes after the loop completes normally (i.e., not via a break statement):\n# Find a number in a list numbers = [1, 3, 5, 7, 9] search_for = 5 for num in numbers: if num == search_for: print(f\"Found {search_for}!\") break else: print(f\"{search_for} is not in the list.\") # Output: Found 5! # Try searching for a number not in the list search_for = 6 for num in numbers: if num == search_for: print(f\"Found {search_for}!\") break else: print(f\"{search_for} is not in the list.\") # Output: 6 is not in the list. The else clause is useful for implementing search algorithms where you need to know whether the loop completed without finding the item.","nested-loops#Nested Loops":"You can place one loop inside another to create nested loops:\nfor i in range(1, 4): # Outer loop for j in range(1, 4): # Inner loop print(f\"({i}, {j})\", end=\" \") print() # New line after each row # Output: # (1, 1) (1, 2) (1, 3) # (2, 1) (2, 2) (2, 3) # (3, 1) (3, 2) (3, 3) Nested loops are particularly useful for working with multi-dimensional data structures:\n# Print a 2D list in a grid format matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] for row in matrix: for element in row: print(element, end=\" \") print() # New line after each row # Output: # 1 2 3 # 4 5 6 # 7 8 9 ","the-for-loop#The \u003ccode\u003efor\u003c/code\u003e Loop":"","the-while-loop#The \u003ccode\u003ewhile\u003c/code\u003e Loop":"Loops allow you to execute a block of code repeatedly. They are essential when you need to perform the same action multiple times or process collections of data. Python provides two main types of loops: for loops and while loops.\nThe for Loop The for loop in Python is designed to iterate over a sequence (like a list, tuple, dictionary, set, or string) or other iterable objects. The general syntax is:\nfor variable in iterable: # Code to execute in each iteration Let’s explore some common uses of for loops:\nIterating Over a List fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(f\"I like {fruit}s\") # Output: # I like apples # I like bananas # I like cherrys In this example, the loop variable fruit takes on each value in the fruits list, one at a time.\nIterating Over a String Strings are sequences of characters, so you can iterate over them:\nmessage = \"Hello\" for character in message: print(character) # Output: # H # e # l # l # o Using the range() Function The range() function generates a sequence of numbers, which is perfect for for loops:\n# range(stop) - generates numbers from 0 to stop-1 for i in range(5): print(i) # Output: 0 1 2 3 4 # range(start, stop) - generates numbers from start to stop-1 for i in range(2, 6): print(i) # Output: 2 3 4 5 # range(start, stop, step) - generates numbers from start to stop-1 with step for i in range(1, 10, 2): print(i) # Output: 1 3 5 7 9 The range() function is commonly used when you need to repeat an action a specific number of times or when you need the indices of a sequence.\nIterating With Index Using enumerate() If you need both the value and its position (index) in the sequence, use the enumerate() function:\nfruits = [\"apple\", \"banana\", \"cherry\"] for index, fruit in enumerate(fruits): print(f\"{index}: {fruit}\") # Output: # 0: apple # 1: banana # 2: cherry Iterating Over Dictionaries When iterating over a dictionary, the loop variable takes on the keys:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Iterating over keys (default) for key in person: print(f\"Key: {key}, Value: {person[key]}\") # Explicitly iterating over keys for key in person.keys(): print(f\"Key: {key}\") # Iterating over values for value in person.values(): print(f\"Value: {value}\") # Iterating over key-value pairs for key, value in person.items(): print(f\"Key: {key}, Value: {value}\") Important: When iterating over a dictionary, the order of items was not guaranteed before Python 3.7. Since Python 3.7, dictionaries maintain insertion order.\nThe while Loop The while loop executes a block of code as long as a specified condition is True. The general syntax is:\nwhile condition: # Code to execute in each iteration Basic while Loop count = 0 while count \u003c 5: print(f\"Count: {count}\") count += 1 # Increment count to avoid an infinite loop # Output: # Count: 0 # Count: 1 # Count: 2 # Count: 3 # Count: 4 Important: Always ensure that the condition in a while loop will eventually become False, or you’ll create an infinite loop that will run forever (or until you force the program to stop).\nUser Input Validation with while The while loop is particularly useful for validating user input:\nwhile True: response = input(\"Enter 'yes' or 'no': \").lower() if response == \"yes\" or response == \"no\": break # Exit the loop if valid input else: print(\"Invalid input. Try again.\") print(f\"You entered: {response}\") This loop continues asking for input until the user enters either “yes” or “no”.\nwhile Loop with a Counter You can use a counter variable to control how many times a loop executes:\nattempts = 0 max_attempts = 3 while attempts \u003c max_attempts: password = input(\"Enter your password: \") if password == \"secret\": print(\"Access granted!\") break else: attempts += 1 remaining = max_attempts - attempts if remaining \u003e 0: print(f\"Incorrect password. {remaining} attempts remaining.\") else: print(\"Access denied. Too many incorrect attempts.\") This example limits the user to three password attempts."},"title":"Loops (for, while)"},"/python-fundamentals/02-control-flow/03-break-and-continue/":{"data":{"":"","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"","exercises#Exercises":"Exercise 1: Write a program that prompts the user to enter positive numbers to calculate their sum. Use a loop that continues until the user enters a negative number or zero, at which point the program should stop asking for input and display the sum of all the positive numbers entered.\nExercise 2: Create a program that prints all the prime numbers between 1 and 100, but skips any prime numbers that contain the digit ‘3’ (like 3, 13, 23, etc.).\nExercise 3: Write a program that iterates through the numbers 1 to 100. For multiples of 3, print “Fizz” instead of the number. For multiples of 5, print “Buzz”. For numbers that are multiples of both 3 and 5, print “FizzBuzz”. However, if the number contains the digit 7, skip that number entirely using continue.\nExercise 4: Create a nested loop that searches for a specific pattern in a 2D list (like a word search puzzle). Once the pattern is found, use break statements appropriately to exit both loops.\nHint for Exercise 1: Use a while True loop to keep asking for input. Check if the input is negative or zero, and use break if it is. Otherwise, add the positive number to a running sum.\n# Exercise 1 solution outline sum_of_numbers = 0 while True: user_input = float(input(\"Enter a positive number (or negative/zero to stop): \")) if user_input \u003c= 0: break sum_of_numbers += user_input print(f\"The sum of all positive numbers entered is: {sum_of_numbers}\") In the next section, we’ll explore the pass statement, which provides a way to create placeholder code in Python.","practical-examples#Practical Examples":"","the-break-statement#The \u003ccode\u003ebreak\u003c/code\u003e Statement":"","the-continue-statement#The \u003ccode\u003econtinue\u003c/code\u003e Statement":"","when-to-use-break-vs-continue#When to Use \u003ccode\u003ebreak\u003c/code\u003e vs. \u003ccode\u003econtinue\u003c/code\u003e":"The break and continue statements give you precise control over loop execution. They allow you to alter the normal flow of loops based on certain conditions.\nThe break Statement The break statement immediately terminates the current loop and transfers control to the statement following the loop.\nBreaking Out of a for Loop fruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"] for fruit in fruits: if fruit == \"cherry\": print(f\"Found {fruit}! Stopping search.\") break print(f\"Checking: {fruit}\") print(\"Loop ended\") Output:\nChecking: apple Checking: banana Found cherry! Stopping search. Loop ended In this example, the loop stops when it reaches “cherry” and doesn’t process the remaining items.\nBreaking Out of a while Loop counter = 0 while True: # This creates an infinite loop counter += 1 print(f\"Count: {counter}\") if counter \u003e= 5: print(\"Breaking out of the loop\") break print(\"Loop ended\") Output:\nCount: 1 Count: 2 Count: 3 Count: 4 Count: 5 Breaking out of the loop Loop ended Here, the break statement is essential to exit what would otherwise be an infinite loop.\nUsing break with Nested Loops When using nested loops, break only exits the innermost loop:\nfor i in range(3): print(f\"Outer loop: {i}\") for j in range(3): print(f\" Inner loop: {j}\") if j == 1: print(\" Breaking inner loop\") break print(\"Outer loop continues\") Output:\nOuter loop: 0 Inner loop: 0 Inner loop: 1 Breaking inner loop Outer loop continues Outer loop: 1 Inner loop: 0 Inner loop: 1 Breaking inner loop Outer loop continues Outer loop: 2 Inner loop: 0 Inner loop: 1 Breaking inner loop Outer loop continues To break out of all loops at once, you can use a flag variable or create a function and return from it.\nThe continue Statement The continue statement skips the rest of the current iteration and jumps back to the top of the loop for the next iteration.\nSkipping Items in a for Loop numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] for number in numbers: if number % 2 == 0: # Skip even numbers continue print(f\"Processing odd number: {number}\") Output:\nProcessing odd number: 1 Processing odd number: 3 Processing odd number: 5 Processing odd number: 7 Processing odd number: 9 The continue statement skips the print statement for even numbers.\nSkipping Iterations in a while Loop counter = 0 while counter \u003c 10: counter += 1 if counter % 3 == 0: # Skip multiples of 3 continue print(f\"Processing: {counter}\") Output:\nProcessing: 1 Processing: 2 Processing: 4 Processing: 5 Processing: 7 Processing: 8 Processing: 10 Important: In a while loop, be careful not to put the counter increment after the continue statement, as it would create an infinite loop:\n# Infinite loop - WRONG! counter = 0 while counter \u003c 10: if counter % 3 == 0: continue # Returns to the condition check without incrementing print(f\"Processing: {counter}\") counter += 1 # Never reached when continue executes Practical Examples Example 1: Input Validation Loop This example uses continue to handle invalid inputs and break to exit when valid input is received:\ndef get_positive_number(): \"\"\"Prompt the user until they enter a positive number.\"\"\" while True: try: user_input = input(\"Enter a positive number: \") # Check if the user wants to exit if user_input.lower() in ['q', 'quit', 'exit']: print(\"Exiting.\") return None number = float(user_input) # Handle negative or zero input if number \u003c= 0: print(\"Please enter a positive number!\") continue # We have a valid positive number return number except ValueError: print(\"That's not a valid number! Try again.\") continue # Test the function result = get_positive_number() if result is not None: print(f\"You entered: {result}\") Example 2: Processing a File with Exceptions This example reads a file line by line, using continue to skip invalid lines:\ndef process_data_file(filename): \"\"\"Process numeric data from a file, skipping invalid lines.\"\"\" total = 0 valid_count = 0 try: with open(filename, 'r') as file: for line_number, line in enumerate(file, 1): line = line.strip() # Skip empty lines if not line: print(f\"Line {line_number}: Empty line, skipping\") continue # Skip comment lines if line.startswith('#'): print(f\"Line {line_number}: Comment, skipping\") continue try: value = float(line) total += value valid_count += 1 print(f\"Line {line_number}: Processed value {value}\") except ValueError: print(f\"Line {line_number}: Invalid number '{line}', skipping\") continue except FileNotFoundError: print(f\"Error: File '{filename}' not found.\") return None if valid_count == 0: return 0 average = total / valid_count return average # Example usage (assuming you have a file named \"data.txt\") # average = process_data_file(\"data.txt\") # if average is not None: # print(f\"Average of valid numbers: {average}\") Example 3: Finding Primes with Early Termination This example uses break to implement early termination in a primality test:\ndef is_prime(n): \"\"\" Check if a number is prime using trial division with early termination. \"\"\" if n \u003c= 1: return False if n \u003c= 3: return True # Check if n is divisible by 2 or 3 if n % 2 == 0 or n % 3 == 0: return False # Check divisibility by numbers of form 6k ± 1 up to sqrt(n) i = 5 while i * i \u003c= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start, end): \"\"\"Find all prime numbers in the given range.\"\"\" primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes # Find primes between 10 and 30 print(find_primes_in_range(10, 30)) # Output: [11, 13, 17, 19, 23, 29] Common Pitfalls and Best Practices 1. Avoiding Infinite Loops Always ensure that a while loop has a way to exit, especially when using continue:\n# Good practice - increment before continue counter = 0 while counter \u003c 5: counter += 1 if counter == 3: continue print(counter) 2. Breaking Out of Nested Loops To break out of nested loops, you can use a flag variable:\nfound = False for i in range(5): for j in range(5): if i * j == 6: print(f\"Found i={i}, j={j} where i*j=6\") found = True break if found: break Alternatively, you can wrap the nested loops in a function and use return:\ndef find_product(target): for i in range(5): for j in range(5): if i * j == target: return i, j return None result = find_product(6) if result: i, j = result print(f\"Found i={i}, j={j} where i*j=6\") else: print(\"No solution found\") 3. Don’t Overuse break and continue While these statements are powerful, overusing them can make code harder to understand:\n# Hard to follow with multiple breaks for item in items: if condition1(item): if condition2(item): break process1(item) else: if condition3(item): continue process2(item) # More readable with positive conditions for item in items: if not condition1(item): if not condition3(item): process2(item) continue if condition2(item): break process1(item) 4. Using else with Loops and break Remember that the else clause in a loop executes only if the loop completes normally (without break):\ndef check_all_positive(numbers): for num in numbers: if num \u003c= 0: print(f\"Found non-positive number: {num}\") break else: print(\"All numbers are positive\") check_all_positive([1, 2, 3, 4, 5]) # All numbers are positive check_all_positive([1, 2, -3, 4, 5]) # Found non-positive number: -3 When to Use break vs. continue Use break when:\nYou’ve found what you’re looking for An error or exceptional condition occurs that makes continuing pointless You need to exit early from a potentially expensive operation Use continue when:\nThe current item shouldn’t be processed, but you want to process the rest You want to skip to the next iteration based on a condition You need to handle invalid cases separately "},"title":"Break and Continue Statements"},"/python-fundamentals/02-control-flow/04-pass-statement/":{"data":{"":"","basic-usage#Basic Usage":"","best-practices#Best Practices":" Add Comments: When using pass, add a comment explaining why it’s there and what will eventually replace it: def complex_algorithm(): pass # TODO: Implement the sorting algorithm from research paper XYZ Temporary Usage: Use pass as a temporary placeholder during development, not as a permanent solution.\nUse with Care in Exception Handlers: Catching exceptions and doing nothing (pass) can hide bugs. Include a comment explaining why an exception is being ignored:\ntry: os.remove(filename) except FileNotFoundError: pass # File already doesn't exist, which is fine Consider Alternatives: For more complex placeholder needs, consider raising a NotImplementedError instead of using pass: def feature_coming_soon(): raise NotImplementedError(\"This feature will be available in version 2.0\") ","common-use-cases#Common Use Cases":"","exercises#Exercises":"Exercise 1: Create a class hierarchy for different shapes (Circle, Rectangle, Triangle) with a common base class Shape. Use the pass statement to create method placeholders for area() and perimeter() methods that subclasses will implement.\nExercise 2: Write a function that processes a list of numbers, but uses the pass statement to skip negative numbers. The function should return the sum of positive numbers.\nExercise 3: Create a simple state machine that transitions between states based on input. Use pass statements as placeholders for actions in each state transition that will be implemented later.\nHint for Exercise 1:\nclass Shape: def area(self): pass # Subclasses will implement this def perimeter(self): pass # Subclasses will implement this class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): import math return math.pi * self.radius ** 2 # Implement perimeter method In the next section, we’ll explore exception handling basics in Python, which allows you to gracefully handle errors and unexpected situations in your code.","pass-vs-other-statements#\u003ccode\u003epass\u003c/code\u003e vs. Other Statements":"The pass statement is a null operation in Python. When executed, nothing happens. It’s useful as a placeholder when a statement is syntactically required but you don’t want to execute any code.\nBasic Usage The pass statement allows you to create minimal classes, functions, or code blocks that do nothing:\ndef function_not_implemented_yet(): pass # Will be implemented later class EmptyClass: pass # Will add methods and attributes later if some_condition: pass # Nothing to do in this case, but code is syntactically correct else: # Do something Common Use Cases 1. Creating Placeholder Functions or Classes During development, you might want to define the structure of your program before implementing all the details:\ndef calculate_tax(income): pass # Will implement tax calculation later def save_to_database(data): pass # Will implement database functionality later def send_notification(user, message): pass # Will implement notification system later # Main function can use these functions before they're fully implemented def process_transaction(user, amount): calculate_tax(amount) save_to_database({\"user\": user, \"amount\": amount}) send_notification(user, f\"Transaction of {amount} processed\") return True 2. Creating Empty Code Blocks Python requires code blocks for control structures like loops, conditionals, and functions. The pass statement can serve as temporary content:\n# Checking for specific conditions, but not taking any action yet for user in users: if user.is_active: # Process active users process_user(user) else: # No action needed for inactive users pass 3. Abstract Base Classes When creating abstract classes that subclasses will implement:\nclass Animal: def make_sound(self): pass # Subclasses must implement this method class Dog(Animal): def make_sound(self): return \"Woof!\" class Cat(Animal): def make_sound(self): return \"Meow!\" 4. In Exception Handling When you need to catch an exception but don’t need to take any action:\ntry: potentially_problematic_function() except SomeSpecificException: pass # We're deliberately ignoring this exception Note: While using pass to ignore exceptions is possible, it’s generally better to include a comment explaining why the exception is being ignored to avoid confusion.\npass vs. Other Statements pass vs. ... (Ellipsis) In Python 3, the ellipsis (...) can sometimes be used similarly to pass:\ndef not_implemented_yet(): ... # Using ellipsis as a placeholder The ellipsis is often used in type hints and as a placeholder in code, but pass is more conventional for creating empty code blocks.\npass vs. Empty String or Comment A common mistake is trying to use an empty string or comment as a null operation:\nif condition: \"\" # This doesn't work as a null operation # This is just a comment, not a null operation Unlike these examples, pass is an actual statement that satisfies Python’s requirement for a code block to contain at least one statement.\npass vs. continue Don’t confuse pass with continue:\n# Using pass - the loop continues with the next statement for i in range(5): if i == 2: pass # Does nothing, proceeds to print print(i) # Output: 0 1 2 3 4 # Using continue - skips to the next iteration for i in range(5): if i == 2: continue # Skips the print for i=2 print(i) # Output: 0 1 3 4 ","practical-examples#Practical Examples":"Example 1: Class Hierarchy Design # Designing a class hierarchy for a game class GameObject: def update(self): pass def render(self): pass def collide(self, other_object): pass class Player(GameObject): def update(self): # Update player position based on input print(\"Updating player position\") def render(self): # Render player sprite print(\"Rendering player\") # Note: collide method is not implemented yet class Enemy(GameObject): def update(self): # Update enemy AI print(\"Updating enemy AI\") def render(self): # Render enemy sprite print(\"Rendering enemy\") def collide(self, other_object): if isinstance(other_object, Player): print(\"Enemy collided with player\") Example 2: Function Stubs for API # Creating API stubs for a web service def login(username, password): \"\"\"Authenticate a user with the service.\"\"\" pass # TODO: Implement authentication logic def get_user_data(user_id): \"\"\"Retrieve user data from the database.\"\"\" pass # TODO: Implement database query def update_profile(user_id, data): \"\"\"Update a user's profile information.\"\"\" pass # TODO: Implement update logic def delete_account(user_id): \"\"\"Delete a user account.\"\"\" pass # TODO: Implement account deletion # Main API handler def handle_request(request_type, data): if request_type == \"login\": return login(data[\"username\"], data[\"password\"]) elif request_type == \"get_user\": return get_user_data(data[\"user_id\"]) elif request_type == \"update_profile\": return update_profile(data[\"user_id\"], data[\"profile_data\"]) elif request_type == \"delete_account\": return delete_account(data[\"user_id\"]) else: raise ValueError(f\"Unknown request type: {request_type}\") Example 3: Selective Processing def process_student_data(students): \"\"\"Process student data, but skip those with incomplete records.\"\"\" for student in students: # Skip students with missing required data if not student.has_complete_data(): pass # Skip this student else: # Process student data calculate_grades(student) update_records(student) send_report(student) "},"title":"Pass Statement"},"/python-fundamentals/02-control-flow/05-exception-handling/":{"data":{"":"","best-practices-for-exception-handling#Best Practices for Exception Handling":"1. Be Specific About Which Exceptions to Catch Catch specific exceptions rather than using a broad except clause:\n# Poor practice try: # Some code except: # Catches everything! print(\"An error occurred\") # Better practice try: # Some code except (ValueError, TypeError) as e: print(f\"Input error: {e}\") except FileNotFoundError as e: print(f\"File error: {e}\") 2. Keep try Blocks Small Include only the code that might raise the exception in the try block:\n# Poor practice try: data = input(\"Enter data: \") value = int(data) result = 100 / value print(f\"Result: {result}\") except Exception as e: print(f\"Error: {e}\") # Better practice try: data = input(\"Enter data: \") value = int(data) # Only this line might raise ValueError except ValueError: print(\"Error: Please enter a valid integer.\") else: try: result = 100 / value # Only this line might raise ZeroDivisionError except ZeroDivisionError: print(\"Error: Cannot divide by zero.\") else: print(f\"Result: {result}\") 3. Clean Up Resources with finally or Context Managers Always clean up resources like file handles or database connections:\n# Using finally file = None try: file = open(\"data.txt\", \"r\") # Process the file except FileNotFoundError: print(\"File not found.\") finally: if file: file.close() # Using context manager (better approach) try: with open(\"data.txt\", \"r\") as file: # Process the file except FileNotFoundError: print(\"File not found.\") The with statement (context manager) automatically handles cleanup, which is more concise and less error-prone.\n4. Don’t Use Exceptions for Flow Control Exceptions should be used for exceptional conditions, not for regular flow control:\n# Poor practice def get_item(dictionary, key): try: return dictionary[key] except KeyError: return None # Better practice def get_item(dictionary, key): return dictionary.get(key) # Returns None if key doesn't exist 5. Log Exceptions Appropriately In production code, log exceptions with useful context information:\nimport logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) try: # Some risky operation result = perform_complex_operation(data) except Exception as e: logger.error(f\"Error processing data: {e}\", exc_info=True) # Gracefully handle the error for the user 6. Don’t Silence Exceptions Without Good Reason If you catch an exception, you should handle it meaningfully:\n# Poor practice try: process_data() except Exception: pass # Silently ignore errors # Better practice try: process_data() except Exception as e: print(f\"Failed to process data: {e}\") # Take appropriate action (retry, use fallback, inform user, etc.) 7. Create Custom Exceptions For Your Application’s Domains Custom exceptions make your code more readable and allow for more specific error handling:\nclass ConfigError(Exception): \"\"\"Base class for configuration errors.\"\"\" pass class ConfigNotFoundError(ConfigError): \"\"\"Raised when a configuration file is not found.\"\"\" pass class ConfigParseError(ConfigError): \"\"\"Raised when a configuration file cannot be parsed.\"\"\" pass def load_config(filename): if not os.path.exists(filename): raise ConfigNotFoundError(f\"Configuration file {filename} not found\") try: with open(filename, 'r') as file: data = file.read() # Parse the config return parse_config(data) except ValueError as e: raise ConfigParseError(f\"Failed to parse {filename}: {e}\") ","catching-all-exceptions#Catching All Exceptions":"","creating-custom-exceptions#Creating Custom Exceptions":"You can create your own exception types by defining a new class that inherits from Exception or one of its subclasses:\nclass InsufficientFundsError(Exception): \"\"\"Raised when a withdrawal would result in a negative balance.\"\"\" def __init__(self, balance, amount): self.balance = balance self.amount = amount self.deficit = amount - balance message = f\"Cannot withdraw ${amount}. Balance is ${balance}, resulting in a deficit of ${self.deficit}.\" super().__init__(message) class BankAccount: def __init__(self, name, balance=0): self.name = name self.balance = balance def deposit(self, amount): if amount \u003c= 0: raise ValueError(\"Deposit amount must be positive\") self.balance += amount return self.balance def withdraw(self, amount): if amount \u003c= 0: raise ValueError(\"Withdrawal amount must be positive\") if amount \u003e self.balance: raise InsufficientFundsError(self.balance, amount) self.balance -= amount return self.balance # Using the custom exception account = BankAccount(\"John\", 100) try: account.withdraw(150) except InsufficientFundsError as e: print(f\"Error: {e}\") print(f\"You need ${e.deficit} more to make this withdrawal.\") # Output: # Error: Cannot withdraw $150. Balance is $100, resulting in a deficit of $50. # You need $50 more to make this withdrawal. Custom exceptions help make your code more readable and maintainable by clearly communicating the specific error conditions that can occur in your program.\nPractical Exception Handling Examples Example 1: Safe File Operations def read_file_safely(filename): \"\"\" Safely read a file and return its contents. Returns None if the file cannot be read. \"\"\" try: with open(filename, 'r') as file: return file.read() except FileNotFoundError: print(f\"Warning: File '{filename}' not found.\") return None except PermissionError: print(f\"Warning: No permission to read '{filename}'.\") return None except Exception as e: print(f\"Unexpected error reading '{filename}': {e}\") return None # Test the function content = read_file_safely(\"config.txt\") if content is not None: print(\"File content:\", content) else: print(\"Using default configuration.\") Example 2: User Input Validation def get_integer_input(prompt, min_value=None, max_value=None): \"\"\" Get an integer input from the user within specified bounds. Continues asking until a valid integer is provided. \"\"\" while True: try: value = int(input(prompt)) if min_value is not None and value \u003c min_value: print(f\"Error: The number must be at least {min_value}.\") continue if max_value is not None and value \u003e max_value: print(f\"Error: The number must be at most {max_value}.\") continue return value except ValueError: print(\"Error: Please enter a valid integer.\") # Test the function age = get_integer_input(\"Enter your age (0-120): \", 0, 120) print(f\"Your age is: {age}\") Example 3: API Request with Timeout import requests import time def fetch_data_from_api(url, max_retries=3, timeout=5): \"\"\" Fetch data from an API with retry logic and timeout. \"\"\" retry_count = 0 while retry_count \u003c max_retries: try: response = requests.get(url, timeout=timeout) response.raise_for_status() # Raise an exception for HTTP errors return response.json() except requests.exceptions.Timeout: print(f\"Request timed out. Retrying ({retry_count + 1}/{max_retries})...\") except requests.exceptions.ConnectionError: print(f\"Connection error. Retrying ({retry_count + 1}/{max_retries})...\") except requests.exceptions.HTTPError as e: print(f\"HTTP error occurred: {e}\") if response.status_code == 404: # Not Found print(\"Resource not found. Giving up.\") return None except requests.exceptions.RequestException as e: print(f\"An error occurred: {e}\") return None retry_count += 1 time.sleep(1) # Wait before retrying print(f\"Failed after {max_retries} retries.\") return None # Example usage try: data = fetch_data_from_api(\"https://api.example.com/data\") if data: print(\"Data fetched successfully:\", data) else: print(\"Failed to fetch data.\") except Exception as e: print(f\"Unexpected error: {e}\") Example 4: Database Operations with Transactions import sqlite3 def update_user_profile(user_id, name, email): \"\"\" Update a user's profile in the database, ensuring all changes succeed or none do. \"\"\" connection = None try: connection = sqlite3.connect(\"users.db\") cursor = connection.cursor() # Start a transaction connection.execute(\"BEGIN TRANSACTION\") # Update user name cursor.execute( \"UPDATE users SET name = ? WHERE id = ?\", (name, user_id) ) # Update user email cursor.execute( \"UPDATE users SET email = ? WHERE id = ?\", (email, user_id) ) # Log the change cursor.execute( \"INSERT INTO user_activity_log (user_id, activity, timestamp) VALUES (?, ?, datetime('now'))\", (user_id, f\"Profile updated: name={name}, email={email}\") ) # Commit the transaction connection.commit() print(f\"User {user_id} profile updated successfully.\") return True except sqlite3.Error as e: # Roll back any changes if something went wrong if connection: connection.rollback() print(f\"Database error: {e}\") return False finally: # Close the connection even if an exception occurred if connection: connection.close() # Example usage success = update_user_profile(123, \"John Smith\", \"john.smith@example.com\") if not success: print(\"Please try updating your profile again later.\") ","exercises#Exercises":"Exercise 1: Write a function called safe_divide that takes two parameters and returns their division. The function should handle potential errors (like division by zero or invalid inputs) gracefully and return None if the division cannot be performed.\nExercise 2: Create a function that asks the user for a filename and tries to open and read that file. Handle all possible exceptions that might occur (file not found, permission error, etc.) with appropriate error messages.\nExercise 3: Write a program that asks the user to enter a list of numbers separated by commas, calculates their average, and handles any potential errors (like invalid input) gracefully. Your program should continue asking until it gets valid input.\nExercise 4: Create a custom exception called InvalidPasswordError that is raised when a password doesn’t meet certain criteria (e.g., minimum length, contains uppercase letters, etc.). Write a function to validate passwords that uses this custom exception.\nHint for Exercise 1:\ndef safe_divide(a, b): try: return a / b except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") return None except TypeError: print(\"Error: Both inputs must be numbers.\") return None In the next section, we’ll explore Python data structures in more detail, starting with lists and list operations.","handling-multiple-exceptions#Handling Multiple Exceptions":"","raising-exceptions#Raising Exceptions":"You can manually raise exceptions using the raise statement:\ndef validate_age(age): if not isinstance(age, int): raise TypeError(\"Age must be an integer\") if age \u003c 0: raise ValueError(\"Age cannot be negative\") if age \u003e 120: raise ValueError(\"Age unreasonably high\") return True try: validate_age(-5) except (TypeError, ValueError) as e: print(f\"Validation error: {e}\") # Output: # Validation error: Age cannot be negative Raising exceptions is useful when you want to indicate that an error or exceptional condition has occurred in your code.","re-raising-exceptions#Re-raising Exceptions":"Sometimes you might want to catch an exception, perform some action, and then re-raise the exception to let it propagate further. You can do this with a simple raise statement without arguments:\ntry: # Some code that might raise an exception number = int(input(\"Enter a number: \")) result = 100 / number except ValueError: print(\"Logging: Invalid input provided.\") raise # Re-raise the caught exception ","the-else-clause#The \u003ccode\u003eelse\u003c/code\u003e Clause":"","the-finally-clause#The \u003ccode\u003efinally\u003c/code\u003e Clause":"Exception handling is a crucial aspect of writing robust programs. It allows your code to gracefully respond to unexpected situations or errors instead of crashing. Python provides a comprehensive exception handling mechanism using try, except, else, finally, and raise statements.\nUnderstanding Exceptions An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions. When an error occurs in Python, it creates an exception object. If the exception is not handled, the program terminates with an error message.\nSome common built-in exceptions include:\nSyntaxError: Raised when there’s a syntax error in your code TypeError: Raised when an operation is performed on an inappropriate data type ValueError: Raised when a function receives an argument of the correct type but invalid value NameError: Raised when a variable is not found in the local or global scope IndexError: Raised when trying to access an index that is outside the bounds of a sequence KeyError: Raised when a dictionary key is not found FileNotFoundError: Raised when a file or directory is requested but doesn’t exist ZeroDivisionError: Raised when dividing by zero ImportError: Raised when an import statement fails Here’s how an unhandled exception looks:\n# Attempting to divide by zero x = 10 / 0 # Raises ZeroDivisionError # Output: # Traceback (most recent call last): # File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e # ZeroDivisionError: division by zero The try and except Blocks The basic structure for handling exceptions is:\ntry: # Code that might raise an exception except ExceptionType: # Code that executes if ExceptionType is raised Here’s a simple example of handling a division by zero error:\ntry: numerator = 10 denominator = 0 result = numerator / denominator print(f\"Result: {result}\") except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") # Output: # Error: Division by zero is not allowed. Handling Multiple Exceptions You can handle multiple exception types using multiple except blocks:\ntry: # Try to convert user input to an integer and divide number = int(input(\"Enter a number: \")) result = 100 / number print(f\"100 divided by {number} is {result}\") except ValueError: print(\"Error: Please enter a valid integer.\") except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") # Sample runs: # Enter a number: abc # Error: Please enter a valid integer. # Enter a number: 0 # Error: Division by zero is not allowed. # Enter a number: 5 # 100 divided by 5 is 20.0 You can also catch multiple exception types with a single except block by grouping the exception types in a tuple:\ntry: # Some code that might raise exceptions number = int(input(\"Enter a number: \")) result = 100 / number print(f\"100 divided by {number} is {result}\") except (ValueError, ZeroDivisionError): print(\"Error: Please enter a non-zero integer.\") Catching All Exceptions You can catch all exceptions using a generic except clause, but this is generally not recommended as it can mask unexpected errors:\ntry: # Some risky code result = some_function() except: # Catches any exception print(\"An error occurred.\") A better approach is to use Exception as the exception type, which catches all standard exceptions but still allows you to access the exception details:\ntry: # Some risky code number = int(input(\"Enter a number: \")) result = 100 / number except Exception as e: print(f\"An error occurred: {e}\") print(f\"Error type: {type(e).__name__}\") Important: While catching all exceptions can prevent your program from crashing, it can also hide bugs and make debugging more difficult. It’s generally better to catch specific exceptions that you anticipate and can handle appropriately.\nThe else Clause The else clause in a try/except block executes if no exceptions are raised in the try block:\ntry: number = int(input(\"Enter a number: \")) result = 100 / number except ValueError: print(\"Error: Please enter a valid integer.\") except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") else: print(f\"100 divided by {number} is {result}\") print(\"No exceptions were raised.\") The else clause is particularly useful when you want to separate the code that might raise an exception from the code that should run only if no exceptions are raised.\nThe finally Clause The finally clause contains code that always executes, regardless of whether an exception was raised or not:\ntry: file = open(\"example.txt\", \"r\") content = file.read() # Process the content except FileNotFoundError: print(\"Error: The file was not found.\") finally: # This block always executes try: file.close() print(\"File closed successfully.\") except: print(\"No file to close.\") The finally clause is essential for cleanup actions (like closing files or releasing resources) that must occur whether an exception was raised or not.","the-try-and-except-blocks#The \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003eexcept\u003c/code\u003e Blocks":"","understanding-exceptions#Understanding Exceptions":""},"title":"Exception Handling Basics"},"/python-fundamentals/03-data-structures/01-lists/":{"data":{"":"Lists are one of the most versatile and commonly used data structures in Python. A list is an ordered, mutable collection of elements that can be of different types. This flexibility makes lists extremely useful for a wide range of programming tasks.","accessing-list-elements#Accessing List Elements":"List elements are indexed starting from 0 for the first element:\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"] # Accessing by positive index (from the beginning) first_fruit = fruits[0] # \"apple\" second_fruit = fruits[1] # \"banana\" # Accessing by negative index (from the end) last_fruit = fruits[-1] # \"elderberry\" second_last = fruits[-2] # \"date\" # Accessing nested lists matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] element = matrix[1][2] # 6 (row 1, column 2) Important: Trying to access an index that doesn’t exist will raise an IndexError. Always ensure your indices are within the valid range or use error handling.\nfruits = [\"apple\", \"banana\", \"cherry\"] try: fourth_fruit = fruits[3] # IndexError: list index out of range except IndexError as e: print(f\"Error: {e}\") ","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"Pitfall 1: Modifying a List While Iterating # Incorrect - modifying the list during iteration numbers = [1, 2, 3, 4, 5] for number in numbers: if number % 2 == 0: numbers.remove(number) # This can cause unexpected results # Correct - create a new list or iterate over a copy numbers = [1, 2, 3, 4, 5] numbers = [num for num in numbers if num % 2 != 0] # or numbers = [1, 2, 3, 4, 5] for number in numbers[:]: # Iterate over a copy if number % 2 == 0: numbers.remove(number) Pitfall 2: Shallow vs. Deep Copying # Original list with nested lists original = [1, 2, [3, 4]] # Shallow copy - nested lists are still shared shallow_copy = original.copy() # Deep copy - completely independent import copy deep_copy = copy.deepcopy(original) # Modify the nested list in the original original[2][0] = 99 print(original) # [1, 2, [99, 4]] print(shallow_copy) # [1, 2, [99, 4]] - nested list was affected print(deep_copy) # [1, 2, [3, 4]] - completely independent Pitfall 3: Lists as Default Parameters # Incorrect - the default list is created once and shared def add_to_list(item, my_list=[]): my_list.append(item) return my_list print(add_to_list(\"a\")) # [\"a\"] print(add_to_list(\"b\")) # [\"a\", \"b\"] - Not a new empty list! # Correct - use None as default and create a new list inside def add_to_list_fixed(item, my_list=None): if my_list is None: my_list = [] my_list.append(item) return my_list print(add_to_list_fixed(\"a\")) # [\"a\"] print(add_to_list_fixed(\"b\")) # [\"b\"] Best Practice 1: Use List Comprehensions for Clarity # Less readable loop squares = [] for i in range(10): if i % 2 == 0: squares.append(i ** 2) # More readable list comprehension squares = [i ** 2 for i in range(10) if i % 2 == 0] Best Practice 2: Use Appropriate Built-in Functions numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5] # Directly use built-ins for common operations total = sum(numbers) largest = max(numbers) smallest = min(numbers) exists = 5 in numbers position = numbers.index(5) Best Practice 3: Choose the Right Tool # If you need unique elements, use a set unique_numbers = list(set([3, 1, 4, 1, 5, 9, 2, 6, 5])) # If you need key-value pairs, use a dictionary country_codes = dict(zip([\"USA\", \"Canada\", \"Mexico\"], [1, 2, 3])) # If data won't change, use a tuple coordinates = (40.7128, -74.0060) ","creating-lists#Creating Lists":"There are several ways to create lists in Python:\n# Empty list empty_list = [] empty_list_alt = list() # Using the list() constructor # List with initial values fruits = [\"apple\", \"banana\", \"cherry\"] # List with mixed data types mixed_list = [1, \"hello\", 3.14, True] # Nested lists matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # Creating a list from another iterable letters = list(\"hello\") # Creates ['h', 'e', 'l', 'l', 'o'] numbers = list(range(1, 6)) # Creates [1, 2, 3, 4, 5] ","exercises#Exercises":"Exercise 1: Write a function that takes a list of numbers and returns a new list with only the even numbers. If there are no even numbers, return an empty list.\nExercise 2: Create a function called remove_duplicates that takes a list and returns a new list with all duplicate elements removed while preserving the original order. Do not use sets for this exercise (to practice list operations).\nExercise 3: Write a function called flatten_list that takes a nested list (a list that contains lists) and returns a flattened version with all elements in a single level list.\nExercise 4: Implement a function called rotate_list that takes a list and a number n. The function should rotate the list elements by n positions. If n is positive, rotate to the right, if negative, rotate to the left.\nHint for Exercise 1: Use a list comprehension with a condition to check if each number is even.\ndef get_even_numbers(numbers): return [num for num in numbers if num % 2 == 0] In the next section, we’ll explore tuples, which are similar to lists but have some important differences, particularly their immutability.","list-comprehensions#List Comprehensions":"List comprehensions provide a concise way to create lists:\n# Create a list of squares squares = [x**2 for x in range(1, 6)] print(squares) # [1, 4, 9, 16, 25] # With a condition even_squares = [x**2 for x in range(1, 11) if x % 2 == 0] print(even_squares) # [4, 16, 36, 64, 100] # With multiple conditions numbers = [x for x in range(1, 31) if x % 2 == 0 if x % 3 == 0] print(numbers) # [6, 12, 18, 24, 30] # Nested loops in comprehension pairs = [(x, y) for x in range(1, 3) for y in range(1, 3)] print(pairs) # [(1, 1), (1, 2), (2, 1), (2, 2)] # Creating a flat list from a nested list nested = [[1, 2], [3, 4], [5, 6]] flat = [item for sublist in nested for item in sublist] print(flat) # [1, 2, 3, 4, 5, 6] ","list-methods#List Methods":"Python provides many built-in methods for lists:\nFinding Elements fruits = [\"apple\", \"banana\", \"cherry\", \"banana\", \"date\"] # Check if an element exists if \"banana\" in fruits: print(\"Yes, 'banana' is in the list\") # Count occurrences banana_count = fruits.count(\"banana\") print(f\"Banana appears {banana_count} times\") # 2 # Find the index of an element (first occurrence) banana_index = fruits.index(\"banana\") print(f\"First banana is at index {banana_index}\") # 1 # Find subsequent occurrences second_banana_index = fruits.index(\"banana\", banana_index + 1) print(f\"Second banana is at index {second_banana_index}\") # 3 # To avoid errors if the element doesn't exist try: grape_index = fruits.index(\"grape\") except ValueError: print(\"Grape not found in the list\") Sorting Lists numbers = [3, 1, 4, 1, 5, 9, 2, 6] # Sort in place numbers.sort() print(numbers) # [1, 1, 2, 3, 4, 5, 6, 9] # Sort in descending order numbers.sort(reverse=True) print(numbers) # [9, 6, 5, 4, 3, 2, 1, 1] # Create a new sorted list without modifying the original original = [3, 1, 4, 1, 5, 9, 2, 6] sorted_numbers = sorted(original) print(sorted_numbers) # [1, 1, 2, 3, 4, 5, 6, 9] print(original) # [3, 1, 4, 1, 5, 9, 2, 6] (unchanged) # Sort strings (alphabetically) fruits = [\"banana\", \"cherry\", \"apple\", \"date\"] fruits.sort() print(fruits) # [\"apple\", \"banana\", \"cherry\", \"date\"] # Custom sorting with key parameter students = [ {\"name\": \"Alice\", \"grade\": 88}, {\"name\": \"Bob\", \"grade\": 75}, {\"name\": \"Charlie\", \"grade\": 93} ] # Sort by grade students.sort(key=lambda student: student[\"grade\"]) print([student[\"name\"] for student in students]) # [\"Bob\", \"Alice\", \"Charlie\"] Other Useful Methods # Reverse the list in place fruits = [\"apple\", \"banana\", \"cherry\"] fruits.reverse() print(fruits) # [\"cherry\", \"banana\", \"apple\"] # Copy a list fruits = [\"apple\", \"banana\", \"cherry\"] fruits_copy = fruits.copy() # or list(fruits) or fruits[:] fruits_copy.append(\"date\") print(fruits) # [\"apple\", \"banana\", \"cherry\"] print(fruits_copy) # [\"apple\", \"banana\", \"cherry\", \"date\"] ","list-slicing#List Slicing":"Slicing allows you to extract a portion of a list:\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"] # Syntax: list[start:stop:step] # start: inclusive, stop: exclusive, step: increment (default 1) # Get a slice from index 1 to 3 (exclusive) slice1 = fruits[1:3] # [\"banana\", \"cherry\"] # Omitting start means start from the beginning slice2 = fruits[:3] # [\"apple\", \"banana\", \"cherry\"] # Omitting stop means go to the end slice3 = fruits[2:] # [\"cherry\", \"date\", \"elderberry\"] # Negative indices in slices slice4 = fruits[-3:-1] # [\"cherry\", \"date\"] # Using step to get every 2nd element slice5 = fruits[::2] # [\"apple\", \"cherry\", \"elderberry\"] # Reverse a list reversed_fruits = fruits[::-1] # [\"elderberry\", \"date\", \"cherry\", \"banana\", \"apple\"] Note: Slicing creates a new list, so the original list remains unchanged.","lists-vs-other-data-structures#Lists vs. Other Data Structures":"Understanding when to use lists versus other data structures is important:\nData Structure Ordered Mutable Duplicates Use Case List Yes Yes Yes General purpose, when order matters and items might change Tuple Yes No Yes Immutable sequences, like coordinates or database records Set No Yes No When you need unique items or set operations Dictionary Yes* Yes No (keys) Key-value mapping, like a phone book *Dictionaries maintained insertion order starting in Python 3.7\n# Example: Converting between data structures numbers_list = [1, 2, 3, 2, 1, 4] numbers_tuple = tuple(numbers_list) # (1, 2, 3, 2, 1, 4) numbers_set = set(numbers_list) # {1, 2, 3, 4} numbers_dict = {i: numbers_list[i] for i in range(len(numbers_list))} # {0: 1, 1: 2, 2: 3, 3: 2, 4: 1, 5: 4} Practical Examples Example 1: Todo List Manager def todo_list_manager(): \"\"\"A simple todo list manager using lists.\"\"\" todos = [] while True: print(\"\\nTodo List Manager\") print(\"1. Add task\") print(\"2. View tasks\") print(\"3. Mark task as done\") print(\"4. Remove task\") print(\"5. Exit\") choice = input(\"Enter your choice (1-5): \") if choice == \"1\": task = input(\"Enter a new task: \") todos.append({\"task\": task, \"done\": False}) print(f\"Task '{task}' added.\") elif choice == \"2\": if not todos: print(\"No tasks in the list.\") else: print(\"\\nYour Tasks:\") for i, item in enumerate(todos): status = \"✓\" if item[\"done\"] else \" \" print(f\"{i+1}. [{status}] {item['task']}\") elif choice == \"3\": if not todos: print(\"No tasks to mark as done.\") else: try: task_num = int(input(\"Enter task number to mark as done: \")) - 1 if 0 \u003c= task_num \u003c len(todos): todos[task_num][\"done\"] = True print(f\"Task '{todos[task_num]['task']}' marked as done.\") else: print(\"Invalid task number.\") except ValueError: print(\"Please enter a valid number.\") elif choice == \"4\": if not todos: print(\"No tasks to remove.\") else: try: task_num = int(input(\"Enter task number to remove: \")) - 1 if 0 \u003c= task_num \u003c len(todos): removed_task = todos.pop(task_num) print(f\"Task '{removed_task['task']}' removed.\") else: print(\"Invalid task number.\") except ValueError: print(\"Please enter a valid number.\") elif choice == \"5\": print(\"Goodbye!\") break else: print(\"Invalid choice. Please enter a number between 1 and 5.\") # Uncomment to run the todo list manager # todo_list_manager() Example 2: Basic Data Analysis def analyze_temperatures(daily_temperatures): \"\"\" Analyze a list of daily temperatures and return statistics. Args: daily_temperatures: A list of daily temperature readings Returns: A dictionary containing various statistics \"\"\" if not daily_temperatures: return {\"error\": \"No temperature data provided\"} # Calculate statistics average_temp = sum(daily_temperatures) / len(daily_temperatures) min_temp = min(daily_temperatures) max_temp = max(daily_temperatures) # Find temperature range temp_range = max_temp - min_temp # Count days above average days_above_avg = sum(1 for temp in daily_temperatures if temp \u003e average_temp) # Temperature trend (increasing or decreasing) increasing_days = 0 for i in range(1, len(daily_temperatures)): if daily_temperatures[i] \u003e daily_temperatures[i-1]: increasing_days += 1 trend_percentage = (increasing_days / (len(daily_temperatures) - 1)) * 100 trend = \"Increasing\" if trend_percentage \u003e 50 else \"Decreasing\" return { \"average\": round(average_temp, 1), \"minimum\": min_temp, \"maximum\": max_temp, \"range\": temp_range, \"days_above_average\": days_above_avg, \"trend\": trend } # Sample usage temperatures = [68, 71, 70, 75, 74, 72, 77, 78, 74] analysis = analyze_temperatures(temperatures) print(\"Temperature Analysis:\") for key, value in analysis.items(): print(f\"{key.replace('_', ' ').title()}: {value}\") Example 3: Matrix Operations def print_matrix(matrix): \"\"\"Print a matrix in a readable format.\"\"\" for row in matrix: print(\" \".join(str(element) for element in row)) def matrix_addition(matrix_a, matrix_b): \"\"\"Add two matrices of the same dimensions.\"\"\" if len(matrix_a) != len(matrix_b) or len(matrix_a[0]) != len(matrix_b[0]): raise ValueError(\"Matrices must have the same dimensions\") result = [] for i in range(len(matrix_a)): row = [] for j in range(len(matrix_a[0])): row.append(matrix_a[i][j] + matrix_b[i][j]) result.append(row) return result def matrix_transpose(matrix): \"\"\"Calculate the transpose of a matrix.\"\"\" # Initialize result matrix with zeros rows = len(matrix) cols = len(matrix[0]) result = [[0 for _ in range(rows)] for _ in range(cols)] # Fill in transposed values for i in range(rows): for j in range(cols): result[j][i] = matrix[i][j] return result # Example matrices matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8, 9], [10, 11, 12] ] print(\"Matrix A:\") print_matrix(matrix_a) print(\"\\nMatrix B:\") print_matrix(matrix_b) print(\"\\nMatrix A + B:\") sum_matrix = matrix_addition(matrix_a, matrix_b) print_matrix(sum_matrix) print(\"\\nTranspose of Matrix A:\") transpose_a = matrix_transpose(matrix_a) print_matrix(transpose_a) Common List Operations and Their Time Complexity Understanding the time complexity of list operations helps you write more efficient code:\nOperation Example Time Complexity Description Indexing lst[i] O(1) Access an element by index Assignment lst[i] = x O(1) Assign a value to an index Append lst.append(x) O(1) Add an element to the end Pop (end) lst.pop() O(1) Remove the last element Pop (middle) lst.pop(i) O(n) Remove element at index i Insert lst.insert(i, x) O(n) Insert element at index i Delete del lst[i] O(n) Delete element at index i Remove lst.remove(x) O(n) Remove first occurrence of x Containment x in lst O(n) Check if x is in the list Iteration for x in lst O(n) Iterate through list Get Length len(lst) O(1) Get number of elements Slicing lst[a:b] O(b-a) Get a slice of the list Extend lst.extend(lst2) O(len(lst2)) Add all elements of lst2 Sort lst.sort() O(n log n) Sort the list in place Multiply lst * n O(n*len(lst)) Create a list with n copies Note: Some operations that seem simple can be inefficient for large lists. For example, repeatedly appending to a list is efficient, but repeatedly inserting at the beginning is not, as it requires shifting all other elements.\nCommon Patterns and Techniques Pattern 1: Filtering # Filter even numbers numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] even_numbers = [num for num in numbers if num % 2 == 0] print(even_numbers) # [2, 4, 6, 8, 10] # Filter with a function def is_premium_member(customer): return customer[\"membership\"] == \"premium\" customers = [ {\"name\": \"Alice\", \"membership\": \"premium\"}, {\"name\": \"Bob\", \"membership\": \"standard\"}, {\"name\": \"Charlie\", \"membership\": \"premium\"} ] premium_customers = list(filter(is_premium_member, customers)) print([customer[\"name\"] for customer in premium_customers]) # [\"Alice\", \"Charlie\"] Pattern 2: Mapping # Transform each element numbers = [1, 2, 3, 4, 5] squared = [num ** 2 for num in numbers] print(squared) # [1, 4, 9, 16, 25] # Map with a function def celsius_to_fahrenheit(celsius): return (celsius * 9/5) + 32 celsius_temps = [0, 10, 20, 30, 40] fahrenheit_temps = list(map(celsius_to_fahrenheit, celsius_temps)) print(fahrenheit_temps) # [32.0, 50.0, 68.0, 86.0, 104.0] Pattern 3: Finding Items def find_first(items, predicate): \"\"\"Find the first item that matches the predicate.\"\"\" for item in items: if predicate(item): return item return None numbers = [1, 3, 5, 8, 10, 12] first_even = find_first(numbers, lambda x: x % 2 == 0) print(first_even) # 8 # Using next() and generator expressions first_even_alt = next((x for x in numbers if x % 2 == 0), None) print(first_even_alt) # 8 Pattern 4: Grouping def group_by_category(items, key_func): \"\"\"Group items by a category determined by key_func.\"\"\" result = {} for item in items: key = key_func(item) if key not in result: result[key] = [] result[key].append(item) return result products = [ {\"name\": \"Apples\", \"category\": \"Fruit\", \"price\": 1.50}, {\"name\": \"Bread\", \"category\": \"Bakery\", \"price\": 2.50}, {\"name\": \"Carrots\", \"category\": \"Vegetable\", \"price\": 1.00}, {\"name\": \"Bananas\", \"category\": \"Fruit\", \"price\": 0.75} ] # Group by category grouped = group_by_category(products, lambda x: x[\"category\"]) for category, items in grouped.items(): print(f\"{category}: {[item['name'] for item in items]}\") Pattern 5: Zipping Lists names = [\"Alice\", \"Bob\", \"Charlie\"] ages = [25, 30, 35] occupations = [\"Engineer\", \"Doctor\", \"Teacher\"] # Combine related data from multiple lists people = list(zip(names, ages, occupations)) print(people) # [(\"Alice\", 25, \"Engineer\"), (\"Bob\", 30, \"Doctor\"), (\"Charlie\", 35, \"Teacher\")] # Create a list of dictionaries people_dicts = [{\"name\": n, \"age\": a, \"occupation\": o} for n, a, o in zip(names, ages, occupations)] print(people_dicts) ","modifying-lists#Modifying Lists":"Lists are mutable, meaning you can change their content:\nChanging Individual Elements fruits = [\"apple\", \"banana\", \"cherry\"] # Change the second element fruits[1] = \"blueberry\" print(fruits) # [\"apple\", \"blueberry\", \"cherry\"] # Change a slice fruits[0:2] = [\"avocado\", \"blackberry\"] print(fruits) # [\"avocado\", \"blackberry\", \"cherry\"] # Insert multiple elements in place of one fruits[1:2] = [\"boysenberry\", \"blackcurrant\"] print(fruits) # [\"avocado\", \"boysenberry\", \"blackcurrant\", \"cherry\"] # Remove elements by assigning an empty list fruits[1:3] = [] print(fruits) # [\"avocado\", \"cherry\"] Adding Elements fruits = [\"apple\", \"banana\"] # Append adds a single element to the end fruits.append(\"cherry\") print(fruits) # [\"apple\", \"banana\", \"cherry\"] # Insert adds an element at a specific position fruits.insert(1, \"blueberry\") # Insert at index 1 print(fruits) # [\"apple\", \"blueberry\", \"banana\", \"cherry\"] # Extend adds multiple elements from another iterable more_fruits = [\"date\", \"elderberry\"] fruits.extend(more_fruits) print(fruits) # [\"apple\", \"blueberry\", \"banana\", \"cherry\", \"date\", \"elderberry\"] # Concatenation with + operator (creates a new list) fruits = [\"apple\", \"banana\"] more_fruits = [\"cherry\", \"date\"] all_fruits = fruits + more_fruits print(all_fruits) # [\"apple\", \"banana\", \"cherry\", \"date\"] Important: The append() method adds the entire object as a single element, while extend() adds each element of the iterable individually:\nlist1 = [1, 2, 3] list2 = [4, 5] # Using append list1.append(list2) print(list1) # [1, 2, 3, [4, 5]] # Using extend list1 = [1, 2, 3] # Reset list1 list1.extend(list2) print(list1) # [1, 2, 3, 4, 5] Removing Elements fruits = [\"apple\", \"banana\", \"cherry\", \"banana\", \"date\"] # Remove by value (first occurrence) fruits.remove(\"banana\") print(fruits) # [\"apple\", \"cherry\", \"banana\", \"date\"] # Remove by index and get the value removed_fruit = fruits.pop(1) # Removes item at index 1 print(removed_fruit) # \"cherry\" print(fruits) # [\"apple\", \"banana\", \"date\"] # Remove the last item if no index is specified last_fruit = fruits.pop() print(last_fruit) # \"date\" print(fruits) # [\"apple\", \"banana\"] # Clear all elements fruits.clear() print(fruits) # [] # Delete list items or the entire list with del fruits = [\"apple\", \"banana\", \"cherry\"] del fruits[1] print(fruits) # [\"apple\", \"cherry\"] del fruits # Deletes the entire list # print(fruits) # NameError: name 'fruits' is not defined "},"title":"Lists and List Operations"},"/python-fundamentals/03-data-structures/02-tuples/":{"data":{"":"A tuple is an ordered, immutable collection of elements in Python. Tuples are similar to lists but with one critical difference: once a tuple is created, you cannot modify its elements. This immutability makes tuples useful for representing fixed collections of items.","accessing-tuple-elements#Accessing Tuple Elements":"You can access tuple elements using indexing, just like with lists:\ncoordinates = (10, 20, 30, 40) # Accessing elements first_element = coordinates[0] # 10 last_element = coordinates[-1] # 40 # Slicing first_two = coordinates[0:2] # (10, 20) ","common-pitfalls-and-tips#Common Pitfalls and Tips":"1. Single-Item Tuple Remember to include a trailing comma when creating a tuple with one element:\n# Wrong single_item = (42) # This is an integer, not a tuple # Correct single_item = (42,) # This is a tuple with one element 2. Tuple Modification You cannot modify a tuple after creation, but you can create a new tuple based on an existing one:\ncoordinates = (10, 20, 30) # Can't do this: # coordinates[0] = 100 # But can do this: coordinates = (100,) + coordinates[1:] print(coordinates) # (100, 20, 30) 3. Performance Considerations For very large collections that don’t need to be modified, tuples can be more memory-efficient than lists:\nimport sys # Compare memory usage list_ex = [0, 1, 2, 3, 4, 5] tuple_ex = (0, 1, 2, 3, 4, 5) print(f\"List size: {sys.getsizeof(list_ex)} bytes\") print(f\"Tuple size: {sys.getsizeof(tuple_ex)} bytes\") 4. Tuple Hashability Because tuples are immutable, they can be used as dictionary keys or set elements (as long as they don’t contain mutable objects):\n# This works point_data = { (0, 0): \"Origin\", (1, 0): \"X-axis unit point\", (0, 1): \"Y-axis unit point\" } # This won't work - list is mutable try: bad_keys = {[0, 0]: \"Origin\"} except TypeError as e: print(f\"Error: {e}\") # Error: unhashable type: 'list' # This won't work - tuple contains a mutable object (list) try: bad_tuple_key = {(0, [1, 2]): \"Contains a list\"} except TypeError as e: print(f\"Error: {e}\") # Error: unhashable type: 'list' ","converting-between-tuples-and-lists#Converting Between Tuples and Lists":"You can convert between tuples and lists using the tuple() and list() functions:\n# List to tuple my_list = [1, 2, 3, 4] my_tuple = tuple(my_list) print(my_tuple) # (1, 2, 3, 4) # Tuple to list my_tuple = (5, 6, 7, 8) my_list = list(my_tuple) print(my_list) # [5, 6, 7, 8] ","creating-tuples#Creating Tuples":"There are several ways to create tuples in Python:\n# Creating a tuple using parentheses coordinates = (10, 20) # Creating a tuple without parentheses (tuple packing) person = \"John\", 30, \"New York\" # Creating a tuple with a single element (note the trailing comma) single_item_tuple = (42,) # Without the comma, this would be an integer # Creating an empty tuple empty_tuple = () # Using the tuple() constructor converted_tuple = tuple([1, 2, 3]) # Convert a list to a tuple Important: When creating a tuple with a single element, you must include a trailing comma, or Python will interpret it as a regular value inside parentheses.\n# This is NOT a tuple - it's just an integer in parentheses not_a_tuple = (42) print(type(not_a_tuple)) # \u003cclass 'int'\u003e # This IS a tuple single_item_tuple = (42,) print(type(single_item_tuple)) # \u003cclass 'tuple'\u003e ","exercises#Exercises":"Exercise 1: Create a function that takes two points represented as tuples (x, y) and returns the distance between them using the Pythagorean theorem.\nExercise 2: Create a function that converts a date represented as a tuple (year, month, day) to a formatted string. For example, (2023, 5, 15) should return “May 15, 2023”.\nExercise 3: Create a program that manages a small phone book using tuples. Each contact should be stored as a tuple containing name, phone number, and email. Implement functions to add a contact, search for a contact by name, and display all contacts.\nExercise 4: Create a function that takes a list of tuples representing (student_name, score) and returns the name of the student with the highest score.\nHint for Exercise 1: The Pythagorean theorem states that in a right triangle, the square of the length of the hypotenuse equals the sum of the squares of the other two sides. For two points (x1, y1) and (x2, y2), the distance is:\ndistance = sqrt((x2 - x1)² + (y2 - y1)²) In the next section, we’ll explore dictionaries, another powerful data structure in Python.","named-tuples#Named Tuples":"The collections module provides a namedtuple factory function to create tuple subclasses with named fields:\nfrom collections import namedtuple # Define a named tuple class Point = namedtuple('Point', ['x', 'y']) # Create instances p1 = Point(10, 20) p2 = Point(30, 40) # Access by name print(f\"p1.x = {p1.x}, p1.y = {p1.y}\") # p1.x = 10, p1.y = 20 # Access by index print(f\"p2[0] = {p2[0]}, p2[1] = {p2[1]}\") # p2[0] = 30, p2[1] = 40 # Convert to dictionary p1_dict = p1._asdict() print(p1_dict) # {'x': 10, 'y': 20} Named tuples offer a convenient way to define simple classes with field names, making code more readable.","practical-examples#Practical Examples":"Example 1: Representing RGB Colors def rgb_to_hex(rgb_tuple): \"\"\"Convert RGB values to hex color code.\"\"\" r, g, b = rgb_tuple # Validate RGB values (0-255) for value in (r, g, b): if not (0 \u003c= value \u003c= 255): raise ValueError(\"RGB values must be between 0 and 255\") # Convert to hex return f\"#{r:02x}{g:02x}{b:02x}\" # Define some common colors as tuples red = (255, 0, 0) green = (0, 255, 0) blue = (0, 0, 255) white = (255, 255, 255) black = (0, 0, 0) # Convert to hex print(f\"Red: {rgb_to_hex(red)}\") # Red: #ff0000 print(f\"Green: {rgb_to_hex(green)}\") # Green: #00ff00 print(f\"Blue: {rgb_to_hex(blue)}\") # Blue: #0000ff Example 2: Returning Multiple Values from Functions def calculate_statistics(numbers): \"\"\"Calculate basic statistics for a list of numbers.\"\"\" if not numbers: return (0, 0, 0, 0) # Empty list count = len(numbers) total = sum(numbers) minimum = min(numbers) maximum = max(numbers) # Return multiple values as a tuple return (count, total / count, minimum, maximum) # Test the function data = [4, 7, 2, 9, 3, 5, 8] count, average, minimum, maximum = calculate_statistics(data) print(f\"Count: {count}\") # Count: 7 print(f\"Average: {average}\") # Average: 5.428571428571429 print(f\"Minimum: {minimum}\") # Minimum: 2 print(f\"Maximum: {maximum}\") # Maximum: 9 Example 3: Immutable Database Records def get_employees(): \"\"\"Return employee data as tuples.\"\"\" employees = [ (1001, \"John Smith\", \"Sales\", 55000), (1002, \"Mary Johnson\", \"Engineering\", 78000), (1003, \"James Brown\", \"Marketing\", 62000), (1004, \"Patricia Davis\", \"HR\", 51000), (1005, \"Robert Wilson\", \"Engineering\", 85000), ] return employees def find_employee_by_id(employees, employee_id): \"\"\"Find an employee by their ID.\"\"\" for employee in employees: if employee[0] == employee_id: return employee return None def get_department_stats(employees, department): \"\"\"Calculate average salary and count for a department.\"\"\" count = 0 total_salary = 0 for employee in employees: if employee[2] == department: count += 1 total_salary += employee[3] if count == 0: return (0, 0) return (count, total_salary / count) # Get employee data employees = get_employees() # Find an employee employee = find_employee_by_id(employees, 1003) if employee: employee_id, name, department, salary = employee print(f\"Employee: {name}, Department: {department}, Salary: ${salary}\") # Get department statistics engineering_stats = get_department_stats(employees, \"Engineering\") print(f\"Engineering department: {engineering_stats[0]} employees, Average salary: ${engineering_stats[1]:.2f}\") Note: While this example demonstrates using tuples for records, in a real application, you might prefer named tuples or classes for better readability and maintainability.\nExample 4: Coordinate System with Named Tuples from collections import namedtuple import math # Define Point named tuple Point = namedtuple('Point', ['x', 'y']) def distance(p1, p2): \"\"\"Calculate Euclidean distance between two points.\"\"\" return math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2) def midpoint(p1, p2): \"\"\"Calculate the midpoint between two points.\"\"\" mid_x = (p1.x + p2.x) / 2 mid_y = (p1.y + p2.y) / 2 return Point(mid_x, mid_y) # Create some points origin = Point(0, 0) p1 = Point(3, 4) p2 = Point(6, 8) # Calculate distances print(f\"Distance from origin to p1: {distance(origin, p1)}\") # 5.0 print(f\"Distance from p1 to p2: {distance(p1, p2)}\") # 5.0 # Calculate midpoint mid = midpoint(p1, p2) print(f\"Midpoint of p1 and p2: ({mid.x}, {mid.y})\") # (4.5, 6.0) ","tuple-immutability#Tuple Immutability":"Once a tuple is created, you cannot modify its elements:\ncoordinates = (10, 20, 30) # This will raise a TypeError try: coordinates[0] = 100 except TypeError as e: print(f\"Error: {e}\") # Error: 'tuple' object does not support item assignment However, if a tuple contains mutable objects like lists, the objects themselves can be modified:\nstudent = (\"Alice\", [85, 90, 78]) # Can't modify the student's name # student[0] = \"Bob\" # This would raise TypeError # Can modify the list of scores student[1].append(92) print(student) # ('Alice', [85, 90, 78, 92]) ","tuple-methods#Tuple Methods":"Tuples have only two built-in methods:\n1. count() Returns the number of occurrences of a value:\nnumbers = (1, 2, 3, 2, 4, 2, 5) count_of_2 = numbers.count(2) print(count_of_2) # 3 2. index() Returns the first index where a value appears:\nfruits = (\"apple\", \"banana\", \"cherry\", \"banana\", \"date\") banana_index = fruits.index(\"banana\") print(banana_index) # 1 (first occurrence) # You can specify a start index to search from second_banana = fruits.index(\"banana\", 2) print(second_banana) # 3 (second occurrence) # If the element is not found, ValueError is raised try: fruits.index(\"grape\") except ValueError as e: print(f\"Error: {e}\") # Error: tuple.index(x): x not in tuple ","tuple-operations#Tuple Operations":"1. Concatenation You can concatenate tuples using the + operator:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) combined = tuple1 + tuple2 print(combined) # (1, 2, 3, 4, 5, 6) 2. Repetition You can repeat a tuple using the * operator:\nrepeated = (1, 2) * 3 print(repeated) # (1, 2, 1, 2, 1, 2) 3. Membership Testing You can check if an element exists in a tuple using the in operator:\nnumbers = (1, 2, 3, 4, 5) print(3 in numbers) # True print(6 in numbers) # False 4. Finding Length You can find the length of a tuple using the len() function:\ncoordinates = (10, 20, 30, 40) print(len(coordinates)) # 4 ","tuple-unpacking#Tuple Unpacking":"Tuple unpacking is a powerful feature that allows you to assign tuple elements to individual variables:\n# Basic unpacking coordinates = (10, 20) x, y = coordinates print(f\"x = {x}, y = {y}\") # x = 10, y = 20 # Unpacking with more elements person = (\"John\", 30, \"New York\", \"Engineer\") name, age, city, occupation = person print(f\"{name} is a {age}-year-old {occupation} living in {city}\") # Using _ for values you don't need name, age, _, occupation = person # Ignoring the city print(f\"{name} is a {age}-year-old {occupation}\") You can use the * operator to capture multiple elements in a list:\nnumbers = (1, 2, 3, 4, 5) # Assign first and last elements to variables, middle elements to a list first, *middle, last = numbers print(f\"First: {first}\") # First: 1 print(f\"Middle: {middle}\") # Middle: [2, 3, 4] print(f\"Last: {last}\") # Last: 5 # Assign first elements to variables, remaining to a list first, second, *rest = numbers print(f\"First: {first}\") # First: 1 print(f\"Second: {second}\") # Second: 2 print(f\"Rest: {rest}\") # Rest: [3, 4, 5] ","tuples-vs-lists#Tuples vs. Lists":"Understanding when to use tuples versus lists is important:\nFeature Tuple List Mutability Immutable Mutable Syntax Parentheses: (1, 2, 3) Square brackets: [1, 2, 3] Use case Fixed collections of items Collections that may change Performance Slightly faster access Slightly slower due to mutability Memory usage Slightly more efficient Slightly less efficient Dictionary keys Can be used as dict keys Cannot be used as dict keys Built-in methods Limited (2 methods) Extensive (many methods) # When to use a tuple: coordinates = (40.7128, -74.0060) # Fixed data point days = (\"Monday\", \"Tuesday\", \"Wednesday\") # Fixed collection # When to use a list: scores = [85, 90, 78] # Might need to add more scores later tasks = [\"Buy groceries\", \"Do laundry\"] # Might add or remove tasks ","when-to-use-tuples#When to Use Tuples":"Tuples are ideal for:\nRepresenting fixed collections that shouldn’t change:\ndays_of_week = (\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\") Returning multiple values from a function:\ndef get_dimensions(): return (1920, 1080) # width, height width, height = get_dimensions() Using as dictionary keys:\n# Tuples can be used as dictionary keys because they're immutable locations = { (40.7128, -74.0060): \"New York\", (34.0522, -118.2437): \"Los Angeles\", (41.8781, -87.6298): \"Chicago\" } # Looking up a location print(locations[(40.7128, -74.0060)]) # New York Data integrity:\n# When you want to ensure the data doesn't change def process_settings(settings): # settings is a tuple, so it can't be modified print(f\"Processing settings: {settings}\") process_settings((800, 600, \"high\", True)) "},"title":"Tuples"},"/python-fundamentals/03-data-structures/03-dictionaries/":{"data":{"":"Dictionaries are one of Python’s most powerful data structures. They store data as key-value pairs, allowing you to quickly retrieve, add, modify, and delete values using their associated keys.","accessing-dictionary-values#Accessing Dictionary Values":"You can access values in a dictionary using their keys:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Using square bracket notation print(person[\"name\"]) # Output: John # Using the get() method print(person.get(\"age\")) # Output: 30 # The get() method allows you to specify a default value print(person.get(\"email\", \"Not available\")) # Output: Not available Note: If you try to access a key that doesn’t exist using square brackets (person[\"email\"]), Python will raise a KeyError. The get() method is safer as it returns None (or a specified default value) instead of raising an error.","creating-dictionaries#Creating Dictionaries":"There are several ways to create a dictionary in Python:\n# Empty dictionary empty_dict = {} also_empty = dict() # Dictionary with initial values person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Using the dict() constructor person = dict(name=\"John\", age=30, city=\"New York\") # Creating a dictionary from a list of tuples items = [(\"name\", \"John\"), (\"age\", 30), (\"city\", \"New York\")] person = dict(items) ","dictionary-best-practices#Dictionary Best Practices":"1. Use get() for Safe Key Access # Using square brackets can raise KeyError user = {\"name\": \"John\"} try: email = user[\"email\"] # KeyError if key doesn't exist except KeyError: email = \"No email found\" # Better approach with get() email = user.get(\"email\", \"No email found\") 2. Use Dictionary Comprehensions for Simple Transformations # Traditional approach prices = {\"apple\": 0.5, \"banana\": 0.25, \"orange\": 0.75} sale_prices = {} for item, price in prices.items(): sale_prices[item] = price * 0.8 # Cleaner with dict comprehension sale_prices = {item: price * 0.8 for item, price in prices.items()} 3. Use defaultdict for Automatic Default Values from collections import defaultdict # Regular dictionary requires checking if key exists word_counts = {} for word in words: if word not in word_counts: word_counts[word] = 0 word_counts[word] += 1 # With defaultdict word_counts = defaultdict(int) # Default value is 0 for int for word in words: word_counts[word] += 1 4. Use collections.Counter for Counting from collections import Counter # Manual counting word_counts = {} for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 # Using Counter word_counts = Counter(words) # Counter has additional methods most_common = word_counts.most_common(3) # Get 3 most common words 5. Create Immutable Dictionary with types.MappingProxyType from types import MappingProxyType original = {\"name\": \"John\", \"age\": 30} # Create a read-only view read_only = MappingProxyType(original) # This fails with TypeError try: read_only[\"age\"] = 31 except TypeError as e: print(f\"Error: {e}\") # But the original dictionary can still be modified original[\"age\"] = 31 print(read_only[\"age\"]) # Reflects changes to original 6. Use OrderedDict When Order Matters (pre-Python 3.7) from collections import OrderedDict # Regular dictionaries in Python 3.7+ preserve insertion order regular_dict = {} regular_dict[\"first\"] = 1 regular_dict[\"second\"] = 2 regular_dict[\"third\"] = 3 # OrderedDict provides additional functionality ordered = OrderedDict() ordered[\"first\"] = 1 ordered[\"second\"] = 2 ordered[\"third\"] = 3 # Move an item to the end ordered.move_to_end(\"first\") print(list(ordered.items())) # Output: [('second', 2), ('third', 3), ('first', 1)] # Get the first/last item first_key = next(iter(ordered)) last_key = next(reversed(ordered)) ","dictionary-iteration-patterns#Dictionary Iteration Patterns":"There are several common patterns for iterating through dictionaries:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\", \"email\": \"john@example.com\" } # Iterating through keys (default) for key in person: print(f\"Key: {key}\") # Explicitly iterating through keys for key in person.keys(): print(f\"Key: {key}\") # Iterating through values for value in person.values(): print(f\"Value: {value}\") # Iterating through key-value pairs for key, value in person.items(): print(f\"{key}: {value}\") # Sorting a dictionary by keys during iteration for key in sorted(person.keys()): print(f\"{key}: {person[key]}\") # Sorting a dictionary by values during iteration for key, value in sorted(person.items(), key=lambda item: item[1]): print(f\"{key}: {value}\") ","dictionary-keys-and-values#Dictionary Keys and Values":"In Python dictionaries:\nKeys must be immutable (strings, numbers, tuples, etc.) Values can be any data type (strings, numbers, lists, other dictionaries, etc.) Each key must be unique within a dictionary # Valid keys valid_dict = { \"string_key\": \"value1\", 42: \"value2\", (1, 2): \"value3\", True: \"value4\" } # Invalid key (will raise TypeError) try: invalid_dict = { [\"list\", \"key\"]: \"value\" # Lists are mutable, so they can't be keys } except TypeError as e: print(f\"Error: {e}\") Important: While tuple keys are allowed because tuples are immutable, be cautious if the tuple contains mutable objects like lists. The tuple itself must be immutable in all of its contents.","dictionary-methods#Dictionary Methods":"Python dictionaries come with many useful methods:\nKeys, Values, and Items person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Get all keys keys = person.keys() print(keys) # Output: dict_keys(['name', 'age', 'city']) # Get all values values = person.values() print(values) # Output: dict_values(['John', 30, 'New York']) # Get all key-value pairs as tuples items = person.items() print(items) # Output: dict_items([('name', 'John'), ('age', 30), ('city', 'New York')]) Note: The objects returned by keys(), values(), and items() are view objects that provide a dynamic view of the dictionary’s entries. If the dictionary changes, these views reflect those changes.\nCopying Dictionaries person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Shallow copy person_copy = person.copy() person_copy[\"name\"] = \"Jane\" # This won't affect the original # Alternative shallow copy person_copy2 = dict(person) print(person) # Original unchanged print(person_copy) # Copy with modified name Important: A shallow copy means that nested objects (like lists or dictionaries inside your dictionary) are referenced, not duplicated. To create a deep copy that also duplicates nested objects, use the copy module:\nimport copy nested_dict = { \"name\": \"John\", \"contact\": { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } } # Deep copy deep_copy = copy.deepcopy(nested_dict) deep_copy[\"contact\"][\"email\"] = \"john.doe@example.com\" print(nested_dict[\"contact\"][\"email\"]) # Still \"john@example.com\" print(deep_copy[\"contact\"][\"email\"]) # \"john.doe@example.com\" Checking if a Key Exists person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Using the in operator if \"name\" in person: print(\"Name exists in the dictionary\") if \"email\" not in person: print(\"Email does not exist in the dictionary\") Setting Default Values person = { \"name\": \"John\", \"age\": 30 } # Get a value, or set a default if it doesn't exist email = person.setdefault(\"email\", \"default@example.com\") print(email) # Output: default@example.com print(person) # Output: {'name': 'John', 'age': 30, 'email': 'default@example.com'} # If the key already exists, setdefault doesn't change it name = person.setdefault(\"name\", \"Jane\") print(name) # Output: John (not changed to Jane) Dictionary Comprehensions Similar to list comprehensions, Python offers dictionary comprehensions for creating dictionaries in a concise way:\n# Create a dictionary of squares squares = {x: x**2 for x in range(1, 6)} print(squares) # Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} # Dictionary comprehension with condition even_squares = {x: x**2 for x in range(1, 11) if x % 2 == 0} print(even_squares) # Output: {2: 4, 4: 16, 6: 36, 8: 64, 10: 100} # Converting between dictionaries prices = {\"apple\": 0.5, \"banana\": 0.25, \"orange\": 0.75} double_prices = {item: price * 2 for item, price in prices.items()} print(double_prices) # Output: {'apple': 1.0, 'banana': 0.5, 'orange': 1.5} ","exercises#Exercises":"Exercise 1: Create a program that reads a text file and counts the frequency of each word. Ignore case and punctuation. Display the 10 most common words and their counts.\nExercise 2: Write a function that takes a list of dictionaries (each representing a person with ’name’ and ‘age’ keys) and returns a new dictionary where keys are age groups (‘0-9’, ‘10-19’, etc.) and values are lists of names of people in that age group.\nExercise 3: Implement a simple contact management system using dictionaries. The system should allow users to add, edit, delete, and search for contacts. Each contact should store name, phone, email, and address information.\nExercise 4: Create a nested dictionary that represents a small library. The main dictionary keys should be book categories. Each category should contain books as dictionaries with title, author, publication year, and availability status. Implement functions to add books, check out books, return books, and search for books by different criteria.\nHint for Exercise 1: Use a combination of string methods like lower(), split(), and strip() to process the text. Consider using the Counter class from the collections module.\n# Exercise 1 solution outline from collections import Counter def count_words_in_file(filename): with open(filename, 'r') as file: text = file.read().lower() # Remove punctuation and split into words import string for char in string.punctuation: text = text.replace(char, ' ') words = text.split() word_counts = Counter(words) # Get the 10 most common words most_common = word_counts.most_common(10) return most_common # Example usage result = count_words_in_file('sample.txt') for word, count in result: print(f\"{word}: {count}\") In the next section, we’ll explore another important Python data structure: Sets.","merging-dictionaries#Merging Dictionaries":"In Python 3.5+, you can merge dictionaries using the unpacking operator (**):\n# Python 3.5+ personal_info = { \"name\": \"John\", \"age\": 30 } contact_info = { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } # Merge dictionaries person = {**personal_info, **contact_info} print(person) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} In Python 3.9+, you can use the merge operator (|):\n# Python 3.9+ personal_info = { \"name\": \"John\", \"age\": 30 } contact_info = { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } # Merge dictionaries person = personal_info | contact_info print(person) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} # In-place merge personal_info |= contact_info # Updates personal_info print(personal_info) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} For older Python versions, you can use the update() method:\n# Compatible with all Python versions personal_info = { \"name\": \"John\", \"age\": 30 } contact_info = { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } # Merge dictionaries person = personal_info.copy() # Create a copy to avoid modifying personal_info person.update(contact_info) print(person) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} Note: If there are duplicate keys, the value from the second dictionary (or the rightmost in case of multiple merges) will overwrite the value from the first.","modifying-dictionaries#Modifying Dictionaries":"Dictionaries are mutable, meaning you can change their content without creating a new dictionary:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Adding a new key-value pair person[\"email\"] = \"john@example.com\" # Modifying an existing value person[\"age\"] = 31 # Updating multiple key-value pairs at once person.update({ \"age\": 32, \"job\": \"Engineer\", \"country\": \"USA\" }) print(person) # Output: {'name': 'John', 'age': 32, 'city': 'New York', 'email': 'john@example.com', 'job': 'Engineer', 'country': 'USA'} ","nested-dictionaries#Nested Dictionaries":"Dictionaries can contain other dictionaries as values, creating a nested structure:\n# Student record with nested dictionaries student = { \"name\": \"Alice\", \"grades\": { \"math\": 90, \"science\": 85, \"history\": 92 }, \"contact\": { \"email\": \"alice@example.com\", \"phone\": \"555-9876\", \"address\": { \"street\": \"123 Main St\", \"city\": \"Boston\", \"state\": \"MA\", \"zip\": \"02101\" } } } # Accessing nested dictionary values math_grade = student[\"grades\"][\"math\"] print(f\"Math grade: {math_grade}\") # Output: Math grade: 90 state = student[\"contact\"][\"address\"][\"state\"] print(f\"State: {state}\") # Output: State: MA # Safer access with get() email = student.get(\"contact\", {}).get(\"email\", \"No email found\") country = student.get(\"contact\", {}).get(\"address\", {}).get(\"country\", \"USA\") print(f\"Email: {email}, Country: {country}\") # Output: Email: alice@example.com, Country: USA ","practical-applications-of-dictionaries#Practical Applications of Dictionaries":"Example 1: Counting Word Frequencies def count_word_frequencies(text): \"\"\"Count the frequency of each word in a text.\"\"\" # Clean and split the text words = text.lower().split() # Clean punctuation from words words = [word.strip('.,!?:;()[]{}\"\"\\'') for word in words] # Count frequencies word_counts = {} for word in words: if word: # Skip empty strings if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 return word_counts # Example text text = \"\"\" Python is a powerful programming language. Python is easy to learn, and its syntax allows programmers to express concepts in fewer lines of code than would be possible in languages such as C++ or Java. Python supports multiple programming paradigms. \"\"\" # Count word frequencies word_frequencies = count_word_frequencies(text) # Display results print(\"Word Frequencies:\") for word, count in sorted(word_frequencies.items()): print(f\"{word}: {count}\") Example 2: Student Grade Management System def grade_management_system(): \"\"\"A simple grade management system using dictionaries.\"\"\" students = {} while True: print(\"\\nStudent Grade Management System\") print(\"1. Add student\") print(\"2. Add/update grade\") print(\"3. Calculate average grade\") print(\"4. List all students\") print(\"5. Exit\") choice = input(\"\\nEnter your choice (1-5): \") if choice == \"1\": # Add student name = input(\"Enter student name: \") if name in students: print(f\"Student '{name}' already exists!\") else: students[name] = {} print(f\"Student '{name}' added successfully.\") elif choice == \"2\": # Add/update grade name = input(\"Enter student name: \") if name not in students: print(f\"Student '{name}' not found!\") continue subject = input(\"Enter subject name: \") try: grade = float(input(\"Enter grade (0-100): \")) if 0 \u003c= grade \u003c= 100: students[name][subject] = grade print(f\"Grade for {name} in {subject} updated successfully.\") else: print(\"Grade must be between 0 and 100.\") except ValueError: print(\"Invalid input. Grade must be a number.\") elif choice == \"3\": # Calculate average grade name = input(\"Enter student name: \") if name not in students: print(f\"Student '{name}' not found!\") continue if not students[name]: print(f\"No grades found for {name}.\") continue average = sum(students[name].values()) / len(students[name]) print(f\"Average grade for {name}: {average:.2f}\") elif choice == \"4\": # List all students if not students: print(\"No students in the system.\") continue print(\"\\nStudent List:\") for name, grades in students.items(): if grades: average = sum(grades.values()) / len(grades) subjects = \", \".join(grades.keys()) print(f\"{name}: Average = {average:.2f}, Subjects = {subjects}\") else: print(f\"{name}: No grades yet\") elif choice == \"5\": # Exit print(\"Exiting the system. Goodbye!\") break else: print(\"Invalid choice. Please enter a number between 1 and 5.\") # Run the grade management system if __name__ == \"__main__\": grade_management_system() Example 3: Inventory Management def inventory_management(): \"\"\"A simple inventory management system using dictionaries.\"\"\" inventory = {} # Initialize with some items inventory = { \"apple\": {\"price\": 0.5, \"quantity\": 100}, \"banana\": {\"price\": 0.25, \"quantity\": 150}, \"orange\": {\"price\": 0.75, \"quantity\": 80} } while True: print(\"\\nInventory Management System\") print(\"1. Add new item\") print(\"2. Update item price\") print(\"3. Update item quantity\") print(\"4. View inventory\") print(\"5. Calculate inventory value\") print(\"6. Exit\") choice = input(\"\\nEnter your choice (1-6): \") if choice == \"1\": # Add new item item_name = input(\"Enter item name: \").lower() if item_name in inventory: print(f\"Item '{item_name}' already exists!\") continue try: price = float(input(\"Enter item price: $\")) quantity = int(input(\"Enter item quantity: \")) if price \u003c 0 or quantity \u003c 0: print(\"Price and quantity must be non-negative.\") continue inventory[item_name] = {\"price\": price, \"quantity\": quantity} print(f\"Item '{item_name}' added successfully.\") except ValueError: print(\"Invalid input. Price must be a number and quantity must be an integer.\") elif choice == \"2\": # Update item price item_name = input(\"Enter item name: \").lower() if item_name not in inventory: print(f\"Item '{item_name}' not found!\") continue try: price = float(input(\"Enter new price: $\")) if price \u003c 0: print(\"Price must be non-negative.\") continue inventory[item_name][\"price\"] = price print(f\"Price for '{item_name}' updated successfully.\") except ValueError: print(\"Invalid input. Price must be a number.\") elif choice == \"3\": # Update item quantity item_name = input(\"Enter item name: \").lower() if item_name not in inventory: print(f\"Item '{item_name}' not found!\") continue try: quantity = int(input(\"Enter new quantity: \")) if quantity \u003c 0: print(\"Quantity must be non-negative.\") continue inventory[item_name][\"quantity\"] = quantity print(f\"Quantity for '{item_name}' updated successfully.\") except ValueError: print(\"Invalid input. Quantity must be an integer.\") elif choice == \"4\": # View inventory if not inventory: print(\"Inventory is empty.\") continue print(\"\\nCurrent Inventory:\") print(f\"{'Item':\u003c10} {'Price':\u003c10} {'Quantity':\u003c10} {'Value':\u003c10}\") print(\"-\" * 40) for item, details in sorted(inventory.items()): price = details[\"price\"] quantity = details[\"quantity\"] value = price * quantity print(f\"{item:\u003c10} ${price:\u003c9.2f} {quantity:\u003c10} ${value:\u003c9.2f}\") elif choice == \"5\": # Calculate inventory value if not inventory: print(\"Inventory is empty.\") continue total_value = sum( details[\"price\"] * details[\"quantity\"] for details in inventory.values() ) print(f\"\\nTotal Inventory Value: ${total_value:.2f}\") elif choice == \"6\": # Exit print(\"Exiting Inventory Management System. Goodbye!\") break else: print(\"Invalid choice. Please enter a number between 1 and 6.\") # Run the inventory management system if __name__ == \"__main__\": inventory_management() Common Dictionary Operations and Their Time Complexity Understanding the time complexity of dictionary operations helps you make efficient choices:\nOperation Description Time Complexity d[key] Access by key O(1) average d[key] = value Assignment by key O(1) average key in d Key membership test O(1) average d.get(key) Access by key with default O(1) average d.items() View all items O(1) for the view, O(n) to iterate d.keys() View all keys O(1) for the view, O(n) to iterate d.values() View all values O(1) for the view, O(n) to iterate len(d) Count entries O(1) d.pop(key) Remove and return value O(1) average d.update(d2) Add items from another dict O(len(d2)) Note: The “average” designation for O(1) operations reflects that dictionary lookups have constant time complexity on average, but in worst-case scenarios (rare with modern hash implementations), they could degrade to O(n).","removing-items-from-dictionaries#Removing Items from Dictionaries":"There are several ways to remove items from a dictionary:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\", \"email\": \"john@example.com\" } # Remove a specific item and return its value email = person.pop(\"email\") print(f\"Removed email: {email}\") # Remove and return the last inserted item (Python 3.7+ guarantees insertion order) last_item = person.popitem() print(f\"Removed last item: {last_item}\") # Remove a specific item without returning it del person[\"age\"] # Clear all items person.clear() print(person) # Output: {} "},"title":"Dictionaries"},"/python-fundamentals/03-data-structures/04-sets/":{"data":{"":"A set is an unordered collection of unique elements in Python. Sets are one of Python’s built-in data structures and are particularly useful when you need to ensure that all elements in a collection are distinct or when you need to perform mathematical set operations like unions, intersections, and differences.","basic-set-operations#Basic Set Operations":"Adding Elements fruits = {\"apple\", \"banana\", \"cherry\"} # Add a single element fruits.add(\"orange\") print(fruits) # Output might be: {'orange', 'cherry', 'apple', 'banana'} # Add multiple elements using update() fruits.update([\"mango\", \"grapes\"]) print(fruits) # Output might include all fruits Removing Elements fruits = {\"apple\", \"banana\", \"cherry\", \"orange\", \"mango\"} # Remove an element (raises KeyError if not found) fruits.remove(\"banana\") print(fruits) # Output: set without 'banana' # Discard an element (no error if not found) fruits.discard(\"pear\") # No error even though 'pear' is not in the set print(fruits) # Remove and return an arbitrary element popped = fruits.pop() print(f\"Popped: {popped}\") print(fruits) # Remove all elements fruits.clear() print(fruits) # Output: set() Note: The difference between remove() and discard() is that remove() will raise a KeyError if the element doesn’t exist, while discard() will do nothing.\nChecking Membership fruits = {\"apple\", \"banana\", \"cherry\"} # Check if an element is in the set print(\"banana\" in fruits) # Output: True print(\"pear\" in fruits) # Output: False print(\"pear\" not in fruits) # Output: True ","common-set-pitfalls#Common Set Pitfalls":" Assuming Sets Maintain Order: Before Python 3.7, sets didn’t guarantee any specific order. Even now, you shouldn’t rely on the order of elements in a set. Using Unhashable Types: Trying to add mutable objects like lists or dictionaries to a set will cause an error. Modifying a Set During Iteration: This can lead to unexpected behavior or errors. Forgetting That Set Elements Must Be Unique: If you need to store duplicates, use a list or counter. ","creating-sets#Creating Sets":"There are several ways to create a set in Python:\n1. Using Curly Braces {} # Creating a set with curly braces fruits = {\"apple\", \"banana\", \"cherry\"} print(fruits) # Output might be: {'cherry', 'banana', 'apple'} 2. Using the set() Constructor # Creating a set from a list colors = set([\"red\", \"green\", \"blue\"]) print(colors) # Output might be: {'blue', 'green', 'red'} # Creating a set from a string letters = set(\"hello\") print(letters) # Output: {'h', 'e', 'l', 'o'} (note only unique letters) 3. Creating an Empty Set # Empty set (must use the constructor, as {} creates an empty dictionary) empty_set = set() print(empty_set) # Output: set() print(type(empty_set)) # Output: \u003cclass 'set'\u003e # This creates an empty dictionary, not a set empty_dict = {} print(type(empty_dict)) # Output: \u003cclass 'dict'\u003e Important: You cannot create an empty set using just curly braces {}. This syntax creates an empty dictionary. To create an empty set, you must use the set() constructor.","exercises#Exercises":"Exercise 1: Write a function that takes two lists and returns three lists containing:\nElements that appear in both lists Elements that appear only in the first list Elements that appear only in the second list Exercise 2: Create a function that counts the number of unique characters in a string, ignoring case and spaces.\nExercise 3: Implement a function that determines if two sentences are anagrams of each other (contain the same characters in different orders, ignoring spaces and punctuation).\nExercise 4: Write a program that simulates a classroom attendance system. Allow the user to:\nAdd students to the class Mark students as present or absent Display who’s present Display who’s absent Display the full class roster Hint for Exercise 1: Use set operations like intersection and difference to find the required elements.\ndef analyze_lists(list1, list2): set1 = set(list1) set2 = set(list2) common = list(set1 \u0026 set2) only_in_first = list(set1 - set2) only_in_second = list(set2 - set1) return common, only_in_first, only_in_second In the next section, we’ll explore string manipulation in Python, learning how to work with text efficiently.","frozen-sets#Frozen Sets":"Python also provides an immutable version of sets called frozen sets. Once created, you cannot modify a frozen set:\n# Creating a frozen set frozen = frozenset([1, 2, 3, 4]) print(frozen) # Output: frozenset({1, 2, 3, 4}) # Trying to modify a frozen set raises an error try: frozen.add(5) # This will cause an error except AttributeError as e: print(f\"Error: {e}\") # Output: Error: 'frozenset' object has no attribute 'add' Frozen sets can be used as elements in other sets or as keys in dictionaries since they are hashable (immutable):\n# Using frozen sets as elements in a set set_of_frozensets = {frozenset([1, 2]), frozenset([3, 4])} print(set_of_frozensets) # Output: {frozenset({1, 2}), frozenset({3, 4})} # Using a frozen set as a dictionary key dict_with_frozensets = {frozenset([1, 2]): \"set1\", frozenset([3, 4]): \"set2\"} print(dict_with_frozensets) # Output: {frozenset({1, 2}): 'set1', frozenset({3, 4}): 'set2'} ","key-characteristics-of-sets#Key Characteristics of Sets":" Unordered: Elements in a set have no specific order. You cannot access elements by index or key. Unique Elements: Sets automatically remove duplicates. Each element can appear only once. Mutable: You can add or remove elements from a set after it’s created. Heterogeneous: Sets can contain elements of different data types. Hashable Elements: Set elements must be hashable (immutable) data types like numbers, strings, or tuples. Lists, dictionaries, and other sets cannot be elements of a set. # Demonstrating uniqueness numbers = {1, 2, 3, 2, 1, 4, 5} print(numbers) # Output: {1, 2, 3, 4, 5} (duplicates are removed) # Heterogeneous data types mixed_set = {1, \"hello\", (1, 2, 3)} print(mixed_set) # Output might be: {1, 'hello', (1, 2, 3)} # Error if we try to add unhashable elements try: invalid_set = {1, [2, 3], 4} # This will cause an error except TypeError as e: print(f\"Error: {e}\") # Output: Error: unhashable type: 'list' ","performance-considerations#Performance Considerations":"Sets in Python are implemented using hash tables, which provide several performance benefits:\nFast Membership Testing: Checking if an element is in a set (x in s) is very fast, with O(1) average time complexity. Fast Add and Remove: Adding and removing elements are also O(1) operations on average. Efficient for Uniqueness: Sets automatically handle uniqueness, making them efficient for removing duplicates. Set Operations: Set operations like union, intersection, and difference are optimized and generally faster than equivalent operations on lists. import time # Demonstrate the performance advantage of sets for membership testing def measure_membership_performance(n): \"\"\"Compare membership testing in lists vs. sets.\"\"\" # Create a list and a set with n elements data_list = list(range(n)) data_set = set(range(n)) # Test membership in list start_time = time.time() list_result = n-1 in data_list list_time = time.time() - start_time # Test membership in set start_time = time.time() set_result = n-1 in data_set set_time = time.time() - start_time print(f\"n = {n}:\") print(f\" List membership test: {list_time:.6f} seconds\") print(f\" Set membership test: {set_time:.6f} seconds\") print(f\" Set is {list_time/set_time:.1f}x faster\") # Try with different sizes for n in [1000, 10000, 100000, 1000000]: measure_membership_performance(n) print() Important: While sets provide fast lookups, they have some overhead and are not always the best choice:\nFor very small collections, lists might be faster due to less overhead. Sets consume more memory than lists for the same elements. If you need ordered data or duplicates, lists are more appropriate. ","practical-examples#Practical Examples":"Example 1: Removing Duplicates from a List One of the most common uses of sets is to remove duplicates from a list:\ndef remove_duplicates(items): \"\"\"Remove duplicates from a list while preserving order.\"\"\" return list(dict.fromkeys(items)) # More efficient than using a set # Test the function numbers = [1, 2, 2, 3, 4, 3, 5, 1, 4] unique_numbers = remove_duplicates(numbers) print(unique_numbers) # Output: [1, 2, 3, 4, 5] # Note: If order doesn't matter, you can simply do: unique_numbers = list(set(numbers)) Example 2: Finding Common Elements def find_common_elements(list1, list2): \"\"\"Find common elements between two lists.\"\"\" set1 = set(list1) set2 = set(list2) return list(set1.intersection(set2)) # Test the function group1 = [\"apple\", \"banana\", \"cherry\", \"orange\"] group2 = [\"banana\", \"kiwi\", \"orange\", \"pear\"] common = find_common_elements(group1, group2) print(common) # Output: ['banana', 'orange'] (order may vary) Example 3: Finding Unique Words in a Text def unique_words(text): \"\"\"Find all unique words in a text.\"\"\" # Split by whitespace and remove punctuation words = text.lower().replace(\".\", \"\").replace(\",\", \"\").replace(\"!\", \"\").split() return set(words) # Test the function sample_text = \"The quick brown fox jumps over the lazy dog. The dog barks, but the fox jumps away!\" unique = unique_words(sample_text) print(unique) print(f\"Number of unique words: {len(unique)}\") Example 4: Set-Based Data Analysis def analyze_survey(responses): \"\"\"Analyze survey responses where respondents could select multiple options.\"\"\" # Count total respondents total_respondents = len(responses) # Find all unique options selected all_options = set() for response in responses: all_options.update(response) # Count how many people selected each option option_counts = {} for option in all_options: option_counts[option] = sum(1 for response in responses if option in response) # Find combinations of options that appeared together option_pairs = {} for response in responses: if len(response) \u003e= 2: # Consider all pairs in this response for i, option1 in enumerate(response): for option2 in response[i+1:]: pair = frozenset([option1, option2]) # Order doesn't matter option_pairs[pair] = option_pairs.get(pair, 0) + 1 return { \"total_respondents\": total_respondents, \"unique_options\": all_options, \"option_counts\": option_counts, \"common_pairs\": option_pairs } # Sample survey data: each list represents one person's selections survey_data = [ [\"pizza\", \"burger\", \"pasta\"], [\"pizza\", \"salad\", \"sushi\"], [\"burger\", \"steak\"], [\"pizza\", \"pasta\", \"salad\"], [\"sushi\", \"salad\"] ] analysis = analyze_survey(survey_data) print(f\"Total respondents: {analysis['total_respondents']}\") print(f\"All food options selected: {analysis['unique_options']}\") print(\"\\nOption popularity:\") for option, count in analysis['option_counts'].items(): percentage = (count / analysis['total_respondents']) * 100 print(f\" {option}: {count} responses ({percentage:.1f}%)\") print(\"\\nCommon combinations:\") for pair, count in sorted(analysis['common_pairs'].items(), key=lambda x: x[1], reverse=True): if count \u003e 1: # Only show pairs that appeared more than once pair_list = list(pair) print(f\" {pair_list[0]} and {pair_list[1]}: {count} responses\") ","set-comprehensions#Set Comprehensions":"Similar to list comprehensions, Python allows you to create sets using set comprehensions:\n# Create a set of squares for numbers 1 to 5 squares = {x**2 for x in range(1, 6)} print(squares) # Output: {1, 4, 9, 16, 25} # Create a set of even numbers from 1 to 10 evens = {x for x in range(1, 11) if x % 2 == 0} print(evens) # Output: {2, 4, 6, 8, 10} # Create a set of uppercase letters from a string uppercase_letters = {char.upper() for char in \"hello world\" if char.isalpha()} print(uppercase_letters) # Output: {'H', 'E', 'L', 'O', 'W', 'R', 'D'} ","set-methods-and-operations#Set Methods and Operations":"Python sets support mathematical set operations, which makes them very powerful for certain tasks:\n1. Union The union of two sets includes all unique elements from both sets. You can use the | operator or the union() method:\nset1 = {1, 2, 3} set2 = {3, 4, 5} # Using the | operator union_set = set1 | set2 print(union_set) # Output: {1, 2, 3, 4, 5} # Using the union() method union_set = set1.union(set2) print(union_set) # Output: {1, 2, 3, 4, 5} # You can unite more than two sets set3 = {5, 6, 7} union_set = set1.union(set2, set3) print(union_set) # Output: {1, 2, 3, 4, 5, 6, 7} 2. Intersection The intersection of two sets includes only elements present in both sets. You can use the \u0026 operator or the intersection() method:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Using the \u0026 operator intersection_set = set1 \u0026 set2 print(intersection_set) # Output: {3, 4} # Using the intersection() method intersection_set = set1.intersection(set2) print(intersection_set) # Output: {3, 4} # Intersection of multiple sets set3 = {4, 5, 6, 7} intersection_set = set1.intersection(set2, set3) print(intersection_set) # Output: {4} 3. Difference The difference between two sets includes elements in the first set but not in the second set. You can use the - operator or the difference() method:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Using the - operator difference_set = set1 - set2 print(difference_set) # Output: {1, 2} # Using the difference() method difference_set = set1.difference(set2) print(difference_set) # Output: {1, 2} # The difference is not commutative difference_set = set2 - set1 print(difference_set) # Output: {5, 6} 4. Symmetric Difference The symmetric difference includes elements in either set, but not in both. You can use the ^ operator or the symmetric_difference() method:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Using the ^ operator symmetric_difference = set1 ^ set2 print(symmetric_difference) # Output: {1, 2, 5, 6} # Using the symmetric_difference() method symmetric_difference = set1.symmetric_difference(set2) print(symmetric_difference) # Output: {1, 2, 5, 6} 5. Subset and Superset You can check if one set is a subset or superset of another set:\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} # Check if set1 is a subset of set2 print(set1.issubset(set2)) # Output: True print(set1 \u003c= set2) # Output: True # Check if set1 is a proper subset of set2 print(set1 \u003c set2) # Output: True # Check if set2 is a superset of set1 print(set2.issuperset(set1)) # Output: True print(set2 \u003e= set1) # Output: True # Check if set2 is a proper superset of set1 print(set2 \u003e set1) # Output: True A proper subset/superset means the sets are not equal.\n6. Disjoint Sets Two sets are disjoint if they have no elements in common:\nset1 = {1, 2, 3} set2 = {4, 5, 6} set3 = {3, 4, 5} print(set1.isdisjoint(set2)) # Output: True (no common elements) print(set1.isdisjoint(set3)) # Output: False ('3' is common) ","update-operations#Update Operations":"Python also provides methods to modify a set in place based on set operations:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Update set1 with the union set1.update(set2) print(set1) # Output: {1, 2, 3, 4, 5, 6} # Reset set1 set1 = {1, 2, 3, 4} # Update set1 with the intersection set1.intersection_update(set2) print(set1) # Output: {3, 4} # Reset set1 set1 = {1, 2, 3, 4} # Update set1 with the difference set1.difference_update(set2) print(set1) # Output: {1, 2} # Reset set1 set1 = {1, 2, 3, 4} # Update set1 with the symmetric difference set1.symmetric_difference_update(set2) print(set1) # Output: {1, 2, 5, 6} ","when-to-use-sets#When to Use Sets":"Sets are particularly useful in the following scenarios:\nWhen you need to ensure uniqueness: Sets automatically remove duplicates, making them perfect for storing unique items. For membership testing: If you frequently need to check if an item exists in a collection, sets provide fast lookups. When you need to perform set operations: If your problem involves operations like unions, intersections, or differences, sets have built-in methods for these. For removing duplicates from a sequence: Converting a list to a set and back to a list is a quick way to remove duplicates (though it doesn’t preserve order). When order doesn’t matter: If you don’t care about the order of elements, sets can be more efficient than lists. "},"title":"Sets"},"/python-fundamentals/03-data-structures/05-string-manipulations/":{"data":{"":"Strings are one of the most commonly used data types in programming. In Python, strings are sequences of characters enclosed in quotes (single, double, or triple quotes). String manipulation involves various operations to modify, analyze, or extract information from strings.","creating-strings#Creating Strings":"There are several ways to create strings in Python:\n# Single quotes name = 'John' # Double quotes message = \"Hello, World!\" # Triple quotes (for multi-line strings) description = \"\"\"This is a multi-line string that spans multiple lines.\"\"\" # Empty string empty_string = \"\" Both single and double quotes work the same way, but using double quotes allows you to include single quotes within the string without escaping them, and vice versa:\n# Single quotes inside double quotes message = \"Don't worry about apostrophes\" # Double quotes inside single quotes code = 'The variable is called \"counter\"' ","exercises#Exercises":"Exercise 1: Write a function called reverse_words that takes a string as input and returns a new string with the words reversed but the order of the words maintained. For example, “Hello World” should become “olleH dlroW”.\nExercise 2: Create a function that checks if a string is a palindrome (reads the same backward as forward), ignoring case, spaces, and punctuation. For example, “A man, a plan, a canal: Panama” is a palindrome.\nExercise 3: Write a function that extracts all email addresses from a given text. Use string methods (or regular expressions for an extra challenge) to identify and extract email patterns.\nExercise 4: Implement a function called word_censorship that takes two parameters: a text string and a list of words to censor. Replace each occurrence of a censored word with asterisks of the same length. The censorship should be case-insensitive.\nHint for Exercise 1:\ndef reverse_words(text): words = text.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words) In the next section, we’ll explore lists in Python, which are versatile and widely used data structures for storing collections of items.","practical-string-manipulation-examples#Practical String Manipulation Examples":"Example 1: Password Validator def validate_password(password): \"\"\" Validate that a password meets the following criteria: - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character (!@#$%^\u0026*()_+) Returns a list of validation errors or an empty list if valid. \"\"\" errors = [] # Check length if len(password) \u003c 8: errors.append(\"Password must be at least 8 characters long\") # Check for uppercase letter if not any(char.isupper() for char in password): errors.append(\"Password must contain at least one uppercase letter\") # Check for lowercase letter if not any(char.islower() for char in password): errors.append(\"Password must contain at least one lowercase letter\") # Check for digit if not any(char.isdigit() for char in password): errors.append(\"Password must contain at least one digit\") # Check for special character special_chars = \"!@#$%^\u0026*()_+\" if not any(char in special_chars for char in password): errors.append(\"Password must contain at least one special character (!@#$%^\u0026*()_+)\") return errors # Test the validator test_passwords = [ \"abc123\", # Too short \"ALLUPPERCASE123!\", # No lowercase \"alllowercase123!\", # No uppercase \"ABCDEabcde!\", # No digits \"ABCDEabcde123\", # No special chars \"ABCabc123!\", # Valid ] for password in test_passwords: errors = validate_password(password) if errors: print(f\"Password '{password}' is invalid:\") for error in errors: print(f\"- {error}\") else: print(f\"Password '{password}' is valid\") print() Example 2: Text Analyzer def analyze_text(text): \"\"\" Analyze a text and return statistics about it. \"\"\" # Prepare the text: convert to lowercase and remove punctuation import string text = text.lower() for punctuation in string.punctuation: text = text.replace(punctuation, \"\") # Split into words words = text.split() # Count the words word_count = len(words) # Count unique words unique_words = set(words) unique_word_count = len(unique_words) # Find most common words from collections import Counter word_counter = Counter(words) most_common = word_counter.most_common(5) # Calculate average word length total_length = sum(len(word) for word in words) avg_word_length = total_length / word_count if word_count \u003e 0 else 0 # Analyze sentence structure sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") sentences = [s.strip() for s in sentences if s.strip()] sentence_count = len(sentences) avg_sentence_length = word_count / sentence_count if sentence_count \u003e 0 else 0 # Return the analysis return { \"word_count\": word_count, \"unique_word_count\": unique_word_count, \"vocabulary_diversity\": unique_word_count / word_count if word_count \u003e 0 else 0, \"avg_word_length\": avg_word_length, \"sentence_count\": sentence_count, \"avg_sentence_length\": avg_sentence_length, \"most_common_words\": most_common } # Test the analyzer sample_text = \"\"\" Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation. Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including structured, object-oriented and functional programming. It is often described as a \"batteries included\" language due to its comprehensive standard library. \"\"\" analysis = analyze_text(sample_text) print(\"Text Analysis Results:\") print(f\"Word count: {analysis['word_count']}\") print(f\"Unique word count: {analysis['unique_word_count']}\") print(f\"Vocabulary diversity: {analysis['vocabulary_diversity']:.2f}\") print(f\"Average word length: {analysis['avg_word_length']:.2f} characters\") print(f\"Sentence count: {analysis['sentence_count']}\") print(f\"Average sentence length: {analysis['avg_sentence_length']:.2f} words\") print(\"Most common words:\") for word, count in analysis['most_common_words']: print(f\"- '{word}': {count} occurrences\") Example 3: Simple Template Engine def render_template(template, variables): \"\"\" A simple template engine that replaces {{variable}} in the template with the corresponding value from the variables dictionary. \"\"\" result = template for key, value in variables.items(): placeholder = \"{{\" + key + \"}}\" result = result.replace(placeholder, str(value)) return result # Test the template engine template = \"\"\" Dear {{name}}, Thank you for your purchase of {{product}} on {{date}}. Your order number is {{order_id}}. Please contact us at {{support_email}} if you have any questions. Sincerely, {{company_name}} \"\"\" variables = { \"name\": \"John Smith\", \"product\": \"Python Programming Book\", \"date\": \"May 15, 2023\", \"order_id\": \"ORD-12345\", \"support_email\": \"support@example.com\", \"company_name\": \"Tech Books Inc.\" } rendered = render_template(template, variables) print(rendered) ","string-concatenation#String Concatenation":"You can combine strings using the + operator:\nfirst_name = \"John\" last_name = \"Doe\" full_name = first_name + \" \" + last_name print(full_name) # Output: John Doe You can also use the += operator to append to a string:\ngreeting = \"Hello\" greeting += \", World!\" print(greeting) # Output: Hello, World! For more complex string building, especially when combining different data types, it’s often better to use string formatting methods (covered later) rather than concatenation.","string-formatting#String Formatting":"Python provides several ways to format strings:\nf-strings (Python 3.6+) name = \"Alice\" age = 30 height = 5.8 # Basic formatting greeting = f\"Hello, my name is {name} and I am {age} years old.\" print(greeting) # Format specifications height_formatted = f\"My height is {height:.1f} feet.\" print(height_formatted) # My height is 5.8 feet. # Expressions in f-strings print(f\"In five years, I'll be {age + 5} years old.\") # In five years, I'll be 35 years old. # Alignment and padding for num in range(1, 11): print(f\"{num:2d} squared is {num**2:3d}\") # Output: # 1 squared is 1 # 2 squared is 4 # 3 squared is 9 # ... # 10 squared is 100 The format() Method # Basic formatting greeting = \"Hello, my name is {} and I am {} years old.\".format(name, age) print(greeting) # Positional arguments template = \"The order is: {0}, {1}, {2}.\" print(template.format(\"first\", \"second\", \"third\")) # The order is: first, second, third. # Reuse positional arguments template = \"The repeated order is: {0}, {1}, {0}.\" print(template.format(\"first\", \"second\")) # The repeated order is: first, second, first. # Named arguments info = \"Name: {name}, Age: {age}, Height: {height}m\".format(name=\"Bob\", age=25, height=1.85) print(info) # Name: Bob, Age: 25, Height: 1.85m # Format specifications pi = 3.14159265359 print(\"Pi is approximately {:.2f}\".format(pi)) # Pi is approximately 3.14 # Alignment for i in range(1, 11): print(\"Number: {:\u003c2}, Square: {:\u003c3}, Cube: {:\u003c4}\".format(i, i**2, i**3)) # Number: 1 , Square: 1 , Cube: 1 # Number: 2 , Square: 4 , Cube: 8 # ... The % Operator (older style) # Basic formatting greeting = \"Hello, my name is %s and I am %d years old.\" % (name, age) print(greeting) # Format specifiers pi = 3.14159 print(\"Pi is approximately %.2f\" % pi) # Pi is approximately 3.14 # Multiple values print(\"Name: %s, Age: %d, Height: %.1f\" % (name, age, height)) Note: While the % operator is still supported, f-strings and the format() method are generally preferred in modern Python code due to improved readability and flexibility.","string-indexing#String Indexing":"Strings in Python are sequences, and each character has an index. Indexing starts at 0 for the first character:\nmessage = \"Hello, World!\" # Access individual characters first_char = message[0] # 'H' sixth_char = message[5] # ',' # Negative indexing (counting from the end) last_char = message[-1] # '!' second_last = message[-2] # 'd' print(f\"First character: {first_char}\") print(f\"Last character: {last_char}\") Important: Strings in Python are immutable, which means you cannot change individual characters directly:\nmessage = \"Hello\" # This will cause an error: # message[0] = \"h\" # TypeError: 'str' object does not support item assignment # Instead, create a new string message = \"h\" + message[1:] print(message) # Output: hello ","string-interpolation-with-variables#String Interpolation with Variables":"Python 3.6+ introduced a simpler form of string formatting using f-strings, which directly interpolate variables:\nname = \"Charlie\" age = 40 print(f\"{name} is {age} years old.\") # Charlie is 40 years old. ","string-manipulation-best-practices#String Manipulation Best Practices":"1. Use String Methods Instead of Manual Iteration # Less efficient uppercase_chars = \"\" for char in text: if char.isalpha(): uppercase_chars += char.upper() # More efficient uppercase_chars = \"\".join(char.upper() for char in text if char.isalpha()) 2. Use join() Instead of + for Building Strings # Less efficient (creates many intermediate strings) result = \"\" for item in items: result += item + \", \" result = result[:-2] # Remove trailing comma and space # More efficient result = \", \".join(items) 3. Use f-strings for Readable Formatting # Less readable info = \"Name: \" + name + \", Age: \" + str(age) + \", City: \" + city # More readable info = f\"Name: {name}, Age: {age}, City: {city}\" 4. Use String Methods for Validation # Less reliable is_valid = True for char in user_id: if not (char.isalpha() or char.isdigit() or char == '_'): is_valid = False break # More reliable is_valid = all(char.isalpha() or char.isdigit() or char == '_' for char in user_id) # Or even better is_valid = user_id.isalnum() or \"_\" in user_id 5. Consider Regular Expressions for Complex Pattern Matching import re # Check if a string is a valid email address def is_valid_email(email): pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$' return bool(re.match(pattern, email)) # Test the function emails = [\"user@example.com\", \"invalid-email\", \"another.user@domain.co.uk\"] for email in emails: print(f\"{email}: {'Valid' if is_valid_email(email) else 'Invalid'}\") ","string-methods#String Methods":"Python provides many built-in methods for string manipulation:\nCase Conversion Methods message = \"Hello, World!\" # Convert to uppercase upper_case = message.upper() print(upper_case) # HELLO, WORLD! # Convert to lowercase lower_case = message.lower() print(lower_case) # hello, world! # Convert first character of each word to uppercase title_case = \"welcome to python\".title() print(title_case) # Welcome To Python # Capitalize only the first character of the string capitalized = \"welcome to python\".capitalize() print(capitalized) # Welcome to python # Swap case (uppercase becomes lowercase and vice versa) swapped = \"Hello, World!\".swapcase() print(swapped) # hELLO, wORLD! Searching Methods message = \"Python is a powerful programming language\" # Check if a string starts with a specific prefix starts_with_python = message.startswith(\"Python\") print(starts_with_python) # True # Check if a string ends with a specific suffix ends_with_language = message.endswith(\"language\") print(ends_with_language) # True # Find the position of a substring (returns -1 if not found) position = message.find(\"powerful\") print(position) # 11 # Count occurrences of a substring count = message.count(\"p\") print(count) # 3 (two in \"Python\" and one in \"powerful\") # Check if a string contains only alphabetic characters is_alpha = \"Python\".isalpha() print(is_alpha) # True # Check if a string contains only digits is_digit = \"12345\".isdigit() print(is_digit) # True # Check if a string is alphanumeric is_alnum = \"Python3\".isalnum() print(is_alnum) # True # Check if all characters are whitespace is_space = \" \".isspace() print(is_space) # True Transformation Methods # Replace parts of a string original = \"Python is cool, Python is powerful\" replaced = original.replace(\"Python\", \"Java\") print(replaced) # Java is cool, Java is powerful # Replace with a limit replaced_once = original.replace(\"Python\", \"Java\", 1) print(replaced_once) # Java is cool, Python is powerful # Strip whitespace from the beginning and end text = \" Hello, World! \" stripped = text.strip() print(stripped) # \"Hello, World!\" # Strip only from the left left_stripped = text.lstrip() print(left_stripped) # \"Hello, World! \" # Strip only from the right right_stripped = text.rstrip() print(right_stripped) # \" Hello, World!\" # Strip specific characters (not just whitespace) text_with_symbols = \"###Hello, World!###\" stripped_symbols = text_with_symbols.strip(\"#\") print(stripped_symbols) # \"Hello, World!\" # Pad a string to a fixed length padded = \"Hello\".ljust(10, \"*\") print(padded) # \"Hello*****\" right_padded = \"Hello\".rjust(10, \"*\") print(right_padded) # \"*****Hello\" center_padded = \"Hello\".center(10, \"*\") print(center_padded) # \"**Hello***\" Splitting and Joining # Split a string into a list based on a delimiter message = \"apple,banana,cherry,date\" fruits = message.split(\",\") print(fruits) # ['apple', 'banana', 'cherry', 'date'] # Split with a maximum number of splits first_two = message.split(\",\", 2) print(first_two) # ['apple', 'banana', 'cherry,date'] # Split by whitespace (default behavior of split()) sentence = \"Python is a programming language\" words = sentence.split() print(words) # ['Python', 'is', 'a', 'programming', 'language'] # Split by lines multiline = \"\"\"Line 1 Line 2 Line 3\"\"\" lines = multiline.splitlines() print(lines) # ['Line 1', 'Line 2', 'Line 3'] # Join a list of strings into a single string joined = \", \".join(fruits) print(joined) # 'apple, banana, cherry, date' # Join with empty string no_spaces = \"\".join(words) print(no_spaces) # 'Pythonisaprogramminglanguage' ","string-repetition#String Repetition":"The * operator repeats a string a specified number of times:\nseparator = \"-\" * 20 print(separator) # Output: -------------------- word = \"Python \" repeated = word * 3 print(repeated) # Output: Python Python Python ","string-slicing#String Slicing":"Slicing allows you to extract a portion of a string:\nmessage = \"Hello, World!\" # Syntax: string[start:end:step] # The slice includes start but excludes end # Extract \"Hello\" hello = message[0:5] # or simply message[:5] # Extract \"World\" world = message[7:12] # Extract every second character every_second = message[::2] # \"Hlo ol!\" # Extract the last 5 characters last_five = message[-5:] # \"orld!\" # Reverse a string reversed_msg = message[::-1] # \"!dlroW ,olleH\" print(f\"Hello part: {hello}\") print(f\"World part: {world}\") print(f\"Every second character: {every_second}\") print(f\"Last five characters: {last_five}\") print(f\"Reversed message: {reversed_msg}\") ","working-with-unicode-and-special-characters#Working with Unicode and Special Characters":"Python 3 strings are Unicode by default, which means they can contain characters from various languages and special symbols:\n# Unicode characters unicode_string = \"こんにちは\" # Japanese for \"Hello\" print(unicode_string) # Unicode escape sequences heart_symbol = \"\\u2764\" # Unicode code point for heart print(heart_symbol) # ❤ # Special escape sequences text_with_newlines = \"First line\\nSecond line\" print(text_with_newlines) # Output: # First line # Second line text_with_tabs = \"Name\\tAge\\tCity\" print(text_with_tabs) # Output: # Name Age City # Raw strings (ignore escape characters) raw_string = r\"C:\\Users\\John\\Documents\" print(raw_string) # C:\\Users\\John\\Documents "},"title":"String Manipulation"},"/python/":{"data":{"":" Learn Python fundamentals, how Python can be used for different software engineering disciplines and integrate with different technologies Fundamentals: Python Basics Compose with just Markdown. Enrich with Shortcode components."},"title":"Python Roadmap"},"/tutorials/":{"data":{"":" Python Basics Simple and easy to use, yet powerful and feature-rich.\nMarkdown is All You Need Compose with just Markdown. Enrich with Shortcode components.\nFull Text Search Built-in full text search with FlexSearch, no extra setup required.\nLightweight as a Feather No dependency or Node.js is needed to use Hextra. Powered by Hugo, one of the fastest static site generators, building your site in just seconds with a single binary.\nResponsive with Dark Mode Included Looks great on different screen sizes. Built-in dark mode support, with auto-switching based on user’s system preference.\nBuild and Host for Free Build with GitHub Actions, and host for free on GitHub Pages. Alternatively it can be hosted on any static hosting service.\nMulti-Language Made Easy Create multi-language pages by just adding locales suffix to the Markdown file. Adding i18n support to your site is intuitive.\nAnd Much More... Syntax highlighting / Table of contents / SEO / RSS / LaTeX / Mermaid / Customizable / and more…"},"title":"Tutorials"}}