{"/docs/":{"data":{"":" Build modern websites with Markdown and Hugo "},"title":"_index"},"/python-fundamentals/":{"data":{"":"Explore the following sections to learn Python basics:\n01. Python Basics 02. Control Flow 03. Data Structures 04. Functions 05. Modules and Packages 06. File Operations 07. Object-Oriented Programming 08. Error Handling 09. Practice Projects "},"title":"Python Programming for Beginners"},"/python-fundamentals/01-basics/":{"data":{"":"Python’s clean syntax and readability make it an ideal first language for beginners, while its robust libraries and frameworks provide the tools needed for everything from web development to data science and artificial intelligence.\nIn this comprehensive tutorial, we’ll guide you from the fundamentals to more advanced concepts, helping you build a solid foundation in Python programming through clear explanations, practical examples, and hands-on exercises.\nWhether you’re looking to enhance your career prospects, automate tasks, or simply explore the joy of coding, Python offers an accessible entry point into the world of programming.\nHere is what this section covers:\n01. Introduction to Python 02. Setup 03. Syntax Basics 04. Variables and Types 05. Operators and Expressions 06. Input and Output Operations "},"title":"Python Basics"},"/python-fundamentals/01-basics/01-introduction-to-python/":{"data":{"":"","features-and-advantages-of-python#Features and Advantages of Python":"Python offers numerous features that make it an excellent choice for beginners and professional developers alike:\n1. Easy to Learn and Read Python’s syntax is designed to be intuitive and similar to the English language. Its code is highly readable, making it easier for beginners to understand and for teams to collaborate.\n2. Interpreted Language Python code is executed line by line, which means you don’t need to compile your code before running it. This makes the development process faster and debugging easier.\n3. Dynamically Typed You don’t need to declare variable types when writing Python code. The interpreter automatically identifies the data type based on the value assigned.\n# Example of dynamic typing x = 10 # x is now an integer x = \"Hello\" # x is now a string x = [1, 2, 3] # x is now a list 4. Cross-Platform Compatibility Python runs on multiple platforms including Windows, macOS, Linux, and even on mobile devices and web browsers (through various implementations).\n5. Extensive Standard Library Python comes with a rich standard library that includes modules for various functionalities like file I/O, system calls, internet protocols, and more, reducing the need for external code.\n6. Support for Multiple Programming Paradigms Python supports procedural, object-oriented, and functional programming approaches, providing flexibility in how you structure your code.\n7. Large and Active Community A vibrant community contributes to Python’s ecosystem by developing libraries, providing support, and sharing knowledge through forums, documentation, and tutorials.\n8. Scalability Python can be used for small scripts as well as large, complex applications, making it suitable for various project sizes.","python-applications-and-use-cases#Python Applications and Use Cases":"Python’s versatility makes it suitable for a wide range of applications:\n1. Web Development Python frameworks like Django and Flask enable developers to build robust web applications. Companies like Instagram, Pinterest, and Mozilla use Python for their web applications.\n2. Data Science and Analysis Python has become the language of choice for data scientists. Libraries like NumPy, Pandas, and Matplotlib provide powerful tools for data manipulation and visualization.\n# Simple data analysis example import pandas as pd import matplotlib.pyplot as plt # Create a sample dataframe data = {'Year': [2010, 2011, 2012, 2013, 2014], 'Sales': [65000, 67000, 72000, 78000, 85000]} df = pd.DataFrame(data) # Plot the data plt.figure(figsize=(10,6)) plt.plot(df['Year'], df['Sales'], marker='o') plt.title('Annual Sales') plt.xlabel('Year') plt.ylabel('Sales ($)') plt.grid(True) plt.show() 3. Machine Learning and Artificial Intelligence Libraries like TensorFlow, PyTorch, and scikit-learn have made Python the dominant language in AI and ML development.\n4. Scientific Computing Python is widely used in scientific research for simulation, data processing, and visualization. Libraries like SciPy enhance its capabilities in this domain.\n5. Automation and Scripting Python excels at automating repetitive tasks, making it popular for writing scripts to handle system administration, file operations, and other routine processes.\n6. Game Development While not as common as C++ for game development, Python is used with libraries like Pygame for creating 2D games and prototyping.\n7. Desktop GUI Applications Libraries like Tkinter, PyQt, and wxPython enable the development of cross-platform desktop applications with graphical user interfaces.\n8. Internet of Things (IoT) Python can run on small devices like Raspberry Pi, making it suitable for IoT projects and physical computing.\n9. Finance and Trading Financial institutions use Python for quantitative analysis, algorithmic trading, and risk management due to its data processing capabilities.\nImportant: Python’s adoption continues to grow across industries, and understanding Python is increasingly becoming a fundamental skill for professionals in technology, data analysis, science, and many other fields.\nNote: While Python is excellent for many applications, it may not be the best choice for all scenarios. Applications requiring extreme performance optimization or low-level system access might benefit from languages like C or C++. However, Python often allows for integration with these languages when necessary.\nIn the upcoming sections, we’ll dive deeper into Python’s development environment, syntax fundamentals, and begin building our programming skills step by step.\nNext ","what-is-python-and-its-history#What is Python and its History":"Python is a high-level, interpreted programming language created by Guido van Rossum. It was first released in 1991, but its development began in the late 1980s. Van Rossum named the language after the British comedy group Monty Python, reflecting his intention to make programming fun and accessible.\nPython was designed with a philosophy emphasizing code readability and a syntax that allows programmers to express concepts in fewer lines of code than would be possible in languages like C++ or Java. This philosophy is summarized in “The Zen of Python,” a collection of guiding principles that influence the design of Python code.\nThe language has evolved significantly since its inception:\nPython 1.0 was released in January 1994 Python 2.0 was released in October 2000, introducing features like list comprehensions and garbage collection Python 3.0 was released in December 2008, representing a major revision that broke backward compatibility to address design flaws As of 2023, Python 3.x is the current series with regular updates and improvements Python is maintained by the Python Software Foundation, a non-profit organization dedicated to promoting, protecting, and advancing the Python programming language."},"title":"Introduction Python"},"/python-fundamentals/01-basics/02-setup/":{"data":{"":"","choosing-a-code-editor-or-ide#Choosing a Code Editor or IDE":"While you can write Python code in any text editor, using a specialized code editor or Integrated Development Environment (IDE) can significantly improve your productivity.\nPopular Options for Beginners Visual Studio Code (VS Code):\nFree, lightweight, and highly customizable Works on Windows, macOS, and Linux Install the Python extension for features like syntax highlighting, code completion, and debugging Download from code.visualstudio.com PyCharm:\nPowerful IDE specifically designed for Python Available in free Community Edition and paid Professional Edition Includes advanced features like intelligent code completion, on-the-fly error checking, and integrated debugging Download from jetbrains.com/pycharm Thonny:\nPython IDE designed for beginners Comes with Python built-in, so no need for separate installation Simple interface with helpful features for learning Download from thonny.org IDLE:\nComes bundled with Python installation Basic features but sufficient for beginners No additional installation required Important: Choose an environment that matches your comfort level. If you’re just starting, Thonny or IDLE might be less overwhelming, while VS Code or PyCharm offer more features as you advance.","installing-python#Installing Python":"Before you can start programming in Python, you need to set up your development environment. This process involves installing Python and optionally an Integrated Development Environment (IDE) or code editor to make your programming experience more efficient.\nInstalling Python on Windows Download the installer:\nVisit the official Python website at python.org Click on the “Download Python” button for the latest version Select the Windows installer (.exe) file Run the installer:\nOpen the downloaded file Check the box that says “Add Python to PATH” - this is very important as it allows you to run Python from the command prompt Click “Install Now” for a standard installation Verify the installation:\nOpen Command Prompt (search for “cmd” in the Start menu) Type python --version and press Enter You should see the Python version number displayed C:\\Users\\username\u003e python --version Python 3.11.4 Installing Python on macOS Using the official installer:\nVisit python.org Download the macOS installer (.pkg file) Open the downloaded file and follow the installation wizard Using Homebrew (recommended for developers):\nIf you don’t have Homebrew installed, open Terminal and run: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Install Python using Homebrew: brew install python Verify the installation:\nOpen Terminal Type python3 --version and press Enter You should see the Python version displayed Installing Python on Linux Most Linux distributions come with Python pre-installed. To verify and ensure you have the latest version:\nCheck the current version:\nOpen Terminal Type python3 --version Installing on Ubuntu/Debian:\nsudo apt update sudo apt install python3 python3-pip Installing on Fedora:\nsudo dnf install python3 python3-pip Installing on Arch Linux:\nsudo pacman -S python python-pip ","running-your-first-python-program#Running Your First Python Program":"Now that you have Python and a code editor installed, let’s write and run your first Python program.\nMethod 1: Using the Python Interactive Shell The Python interactive shell (also called the REPL - Read, Evaluate, Print, Loop) lets you execute Python commands line by line.\nOpen the interactive shell:\nOpen Command Prompt (Windows) or Terminal (macOS/Linux) Type python (Windows) or python3 (macOS/Linux) and press Enter You should see the Python prompt (\u003e\u003e\u003e) Write a simple command:\n\u003e\u003e\u003e print(\"Hello, Python!\") Press Enter to see the output:\nHello, Python! Exit the shell:\nType exit() or press Ctrl+Z (Windows) or Ctrl+D (macOS/Linux) followed by Enter Method 2: Creating and Running a Python File Create a new file: Open your chosen code editor Create a new file named hello.py Type the following code: # My first Python program print(\"Hello, Python!\") print(\"Welcome to the world of programming!\") # A simple calculation sum = 5 + 3 print(\"The sum of 5 and 3 is:\", sum) # Getting user input name = input(\"What is your name? \") print(\"Nice to meet you,\", name) Save the file to a location you can easily access, like your Desktop or Documents folder\nRun the program:\nUsing Command Line:\nOpen Command Prompt or Terminal Navigate to the directory where you saved the file using the cd command Run the program with: python hello.py # On Windows python3 hello.py # On macOS/Linux Using VS Code:\nWith the file open, click the “Run” button (triangle icon) in the top-right corner, or Right-click in the editor and select “Run Python File in Terminal” Using PyCharm:\nRight-click in the editor and select “Run ‘hello’” or Use the green “Run” button in the toolbar Using IDLE:\nWith the file open, press F5 or select “Run \u003e Run Module” from the menu View the output: The program will execute and you’ll see the output in the terminal or console window. You’ll also be prompted to enter your name, and then see a personalized greeting.\nExpected Output:\nHello, Python! Welcome to the world of programming! The sum of 5 and 3 is: 8 What is your name? [You type your name here] Nice to meet you, [Your name] Note: The input() function pauses the program and waits for the user to type something and press Enter. This allows for interactive programs that can respond to user input.","troubleshooting-common-installation-issues#Troubleshooting Common Installation Issues":"“Python is not recognized as an internal or external command” This typically means Python wasn’t added to your system’s PATH. You can fix this by:\nReinstalling Python and checking “Add Python to PATH” Manually adding Python to PATH (search online for instructions specific to your OS version) “pip is not recognized as an internal or external command” Similar to the above, pip might not be in your PATH. Try using:\npython -m pip install package_name Multiple Python Versions If you have multiple Python versions installed, you may need to specify which version to use:\npython3.9 script.py # Run with Python 3.9 In the next lesson, we’ll explore Python syntax fundamentals and start writing more sophisticated programs.","understanding-the-python-environment#Understanding the Python Environment":"Python Interpreter Python is an interpreted language, which means the Python interpreter reads and executes your code line by line. This is different from compiled languages where the entire program is translated to machine code before execution.\nPython Packages and pip Python’s functionality can be extended with packages (also called libraries or modules). The Python Package Index (PyPI) hosts thousands of third-party packages for various purposes.\nTo install packages, you use pip, Python’s package installer:\npip install package_name # On Windows pip3 install package_name # On macOS/Linux We’ll explore packages in more detail in later lessons.\nVirtual Environments As you advance in Python, you’ll learn about virtual environments, which allow you to create isolated Python environments for different projects. This is important for managing dependencies, but for now, the global Python installation is sufficient for learning the basics."},"title":"Setup Development Environment"},"/python-fundamentals/01-basics/03-syntax-basics/":{"data":{"":"Python’s syntax is designed to be readable and straightforward, making it an excellent language for beginners. Understanding the fundamental syntax rules is your first step toward writing effective Python code.","case-sensitivity#Case Sensitivity":"Python is case-sensitive, meaning that variables, function names, and all identifiers are sensitive to capitalization:\nname = \"John\" Name = \"Jane\" print(name) # Outputs: John print(Name) # Outputs: Jane # Case sensitivity applies to everything print(len(\"hello\")) # Works print(Len(\"hello\")) # NameError: name 'Len' is not defined ","checking-your-python-syntax#Checking Your Python Syntax":"Python offers several ways to check your syntax before executing code:\nPython Interpreter Checks\nPython checks syntax when you run a program and reports errors IDE Tools\nMost IDEs like PyCharm and VS Code highlight syntax errors as you type Linters\nTools like flake8, pylint, or pycodestyle check not only syntax but also style # Run the following in your terminal to check syntax without executing: python -m py_compile your_script.py ","comments#Comments":"Comments in Python start with the # character and extend to the end of the line:\n# This is a comment print(\"Hello\") # This is an inline comment Python also supports multi-line comments using triple quotes, which are technically multi-line strings but commonly used as comments:\n\"\"\" This is a multi-line comment. It spans multiple lines. Python technically treats this as a string that isn't assigned to anything. \"\"\" ","common-syntax-errors-for-beginners#Common Syntax Errors for Beginners":" Indentation Errors\nMixing tabs and spaces Inconsistent indentation levels Missing Colons\nForgetting the colon at the end of statements like if, for, def, etc. Incorrect Variable Names\nUsing Python keywords as variable names Starting variable names with numbers String Quote Mismatches\nStarting a string with one type of quote and ending with another Parentheses/Bracket Mismatches\nNot closing parentheses, brackets, or braces Example of common errors and fixes:\n# Error: Missing colon if x \u003e 5 print(\"x is greater than 5\") # Fix: if x \u003e 5: print(\"x is greater than 5\") # Error: Incorrect indentation if x \u003e 5: print(\"x is greater than 5\") # Fix: if x \u003e 5: print(\"x is greater than 5\") # Error: Invalid variable name 1st_name = \"John\" # Fix: first_name = \"John\" ","exercises#Exercises":"Exercise 1: Fix the syntax errors in the following code:\nif x = 10 print(x is equal to 10) def calculate_sum(a b): return a+b Exercise 2: Write a program that asks for a user’s name and age, then prints a message saying how old they will be in 10 years. Follow Python naming conventions and proper indentation.\nExercise 3: Create a function that converts temperature from Celsius to Fahrenheit. The formula is: F = C * 9/5 + 32. Make sure to include proper comments and docstrings.\nHint for Exercise 1: Look for missing colons, incorrect operators, and missing commas in function parameters.\nIn the next lesson, we’ll explore Python variables and data types in more detail, building on the syntax fundamentals we’ve covered here.","indentation#Indentation":"Unlike many programming languages that use braces {} to define blocks of code, Python uses indentation. This enforces clean, readable code but requires consistency.\n# Correct indentation if True: print(\"This is indented correctly\") if True: print(\"This is a nested block\") # Incorrect indentation will cause errors if True: print(\"This will cause an error\") # IndentationError Important: Python is strict about indentation. The standard practice is to use 4 spaces for each indentation level. Do not mix tabs and spaces, as this can lead to unexpected errors that are difficult to debug.","keywords#Keywords":"Python has a set of reserved keywords that cannot be used as variable names or identifiers:\nFalse await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield Note: To check if a word is a Python keyword, you can use the keyword module:\nimport keyword print(keyword.iskeyword(\"if\")) # True print(keyword.iskeyword(\"name\")) # False ","naming-conventions#Naming Conventions":"While not strictly syntax rules, Python has widely accepted naming conventions:\nVariable and function names should be lowercase, with words separated by underscores (snake_case): my_variable, calculate_total Class names should use CamelCase (start with a capital letter): MyClass, PersonData Constants are typically all uppercase: MAX_VALUE, PI Module names should be short, lowercase: math, sys, os Package names should be lowercase, preferably short: numpy, pandas # Variable names first_name = \"John\" last_name = \"Doe\" # Function name def calculate_area(radius): return 3.14 * radius ** 2 # Class name class Person: pass # Constant MAX_ATTEMPTS = 3 ","python-code-blocks#Python Code Blocks":"Python uses code blocks for structures like functions, loops, and conditional statements. A code block starts with a colon : and includes all indented lines that follow:\n# Function definition block def greet(name): print(\"Hello,\", name) print(\"Welcome to Python\") # If statement block age = 18 if age \u003e= 18: print(\"You are an adult\") print(\"You can vote\") else: print(\"You are a minor\") print(\"You cannot vote\") ","python-statement-termination#Python Statement Termination":"Unlike languages like C++ or Java, Python uses newlines to terminate statements, not semicolons:\nx = 10 y = 20 z = x + y This contributes to Python’s clean and readable syntax.","python-syntax-in-practice#Python Syntax in Practice":"Let’s look at a complete example that demonstrates the syntax elements we’ve covered:\n# This program demonstrates Python syntax fundamentals # Import a module import math # Define a constant PI = 3.14159 # Define a function def calculate_circle_area(radius): \"\"\" Calculate the area of a circle given its radius. This is a multi-line comment (docstring) that describes the function. \"\"\" return PI * radius ** 2 # Main program block if __name__ == \"__main__\": # Get user input radius_input = input(\"Enter the radius of the circle: \") # Convert string input to float radius = float(radius_input) # Conditional statement if radius \u003c= 0: print(\"Error: Radius must be positive\") else: # Calculate area using our function area = calculate_circle_area(radius) # Print results with formatted output print(f\"Area with our PI: {area:.2f}\") # Use the math module for a more accurate calculation accurate_area = math.pi * radius ** 2 print(f\"Area with math.pi: {accurate_area:.2f}\") # Demonstrate indentation in a nested block if area \u003e 100: print(\"That's a big circle!\") if area \u003e 1000: print(\"That's a VERY big circle!\") Expected Output (for input radius of 10):\nEnter the radius of the circle: 10 Area with our PI: 314.16 Area with math.pi: 314.16 That's a big circle! That's a VERY big circle! ","statements-and-lines#Statements and Lines":"In Python, a statement is typically written on a single line:\nprint(\"Hello, World!\") x = 5 You can place multiple statements on one line using semicolons, though this is not recommended for readability:\nprint(\"Hello\"); print(\"World\") # Valid but not recommended For long statements, you can spread them across multiple lines using the line continuation character \\ or implicit line continuation within parentheses, brackets, or braces:\n# Using line continuation character total = 1 + 2 + 3 + \\ 4 + 5 + 6 # Implicit line continuation (preferred) total = (1 + 2 + 3 + 4 + 5 + 6) colors = ['red', 'blue', 'green'] "},"title":"Syntax Fundamentals"},"/python-fundamentals/01-basics/04-variables-and-types/":{"data":{"":"Variables in Python are used to store data values. Unlike some other programming languages, Python has no command for declaring a variable. A variable is created the moment you first assign a value to it.","checking-data-types#Checking Data Types":"You can check the type of any variable using the type() function:\nx = 10 y = \"Hello\" z = 3.14 print(type(x)) # \u003cclass 'int'\u003e print(type(y)) # \u003cclass 'str'\u003e print(type(z)) # \u003cclass 'float'\u003e ","common-pitfalls-with-variables-and-data-types#Common Pitfalls with Variables and Data Types":" Modifying mutable objects unintentionally:\noriginal = [1, 2, 3] copy = original # This is a reference, not a copy copy.append(4) # Modifies both copy and original String immutability:\nname = \"John\" name[0] = \"B\" # Error: strings are immutable # Correct approach: name = \"B\" + name[1:] # Creates a new string Integer division:\nresult = 5 / 2 # 2.5 (float division) result = 5 // 2 # 2 (integer division) Comparing floating-point numbers:\nx = 0.1 + 0.2 # 0.30000000000000004 (not exactly 0.3) print(x == 0.3) # False # Better approach: import math print(math.isclose(x, 0.3)) # True Note: Python’s handling of variables is very different from languages like C, Java, or C#. In Python, variables are references to objects, not containers for values. This concept becomes particularly important when working with mutable objects like lists and dictionaries.","creating-variables#Creating Variables":"In Python, you create a variable by assigning a value to it using the equals sign (=):\n# Creating variables name = \"John\" age = 30 height = 5.9 is_student = True Python variable names are case-sensitive and must follow these rules:\nMust start with a letter or underscore Can only contain alphanumeric characters and underscores (A-Z, a-z, 0-9, and _) Cannot be a Python keyword # Valid variable names my_var = 10 _count = 20 total1 = 30 # Invalid variable names 1st_number = 40 # Cannot start with a digit my-name = \"John\" # Hyphens not allowed if = 50 # Cannot use keywords ","data-types-in-python#Data Types in Python":"Python has several built-in data types. The main categories are:\nNumeric Types: integers, floating-point numbers, and complex numbers Sequence Types: strings, lists, and tuples Mapping Type: dictionaries Set Types: sets and frozen sets Boolean Type: True or False None Type: represents the absence of a value Let’s explore each of these types in detail:\n1. Numeric Types Integers are whole numbers, positive or negative, without decimals:\nx = 10 y = -5 big_number = 1_000_000 # Underscores for readability in Python 3.6+ Floating-point numbers contain decimal points or use exponential notation:\npi = 3.14159 e = 2.71828 large_num = 1.5e6 # 1.5 million (1.5 × 10^6) small_num = 1.5e-6 # 0.0000015 (1.5 × 10^-6) Complex numbers have a real and imaginary part, written with a “j” as the imaginary part:\nz = 2 + 3j print(z.real) # 2.0 print(z.imag) # 3.0 2. Sequence Types Strings are sequences of characters, enclosed in single or double quotes:\nname = \"Alice\" message = 'Hello, World!' # Multi-line strings use triple quotes long_text = \"\"\"This is a longer text that spans multiple lines\"\"\" Lists are ordered, changeable collections that can contain different data types:\nfruits = [\"apple\", \"banana\", \"cherry\"] mixed_list = [1, \"hello\", 3.14, True] # Accessing list elements (indexing starts at 0) print(fruits[0]) # \"apple\" Tuples are ordered, unchangeable collections:\ncoordinates = (10, 20) rgb_color = (255, 0, 127) # Accessing tuple elements print(coordinates[0]) # 10 3. Mapping Type Dictionaries are unordered collections of key-value pairs:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Accessing dictionary values print(person[\"name\"]) # \"John\" 4. Set Types Sets are unordered collections of unique elements:\nfruits = {\"apple\", \"banana\", \"cherry\"} numbers = {1, 2, 3, 3, 4} # Duplicate values are automatically removed # Sets are useful for removing duplicates list_with_duplicates = [1, 2, 2, 3, 4, 4, 5] unique_numbers = set(list_with_duplicates) print(unique_numbers) # {1, 2, 3, 4, 5} 5. Boolean Type Boolean values represent truth values, either True or False:\nis_active = True is_complete = False print(10 \u003e 5) # True print(10 == 5) # False 6. None Type None represents the absence of a value or a null value:\nresult = None print(result) # None ","dynamic-typing#Dynamic Typing":"Python is dynamically typed, meaning you can reassign variables to different data types:\nx = 5 # x is an integer x = \"hello\" # Now x is a string x = [1, 2, 3] # Now x is a list This flexibility can be powerful but requires care to avoid unexpected errors.","exercises#Exercises":"Exercise 1: Create variables for storing information about a book including title (string), publication year (integer), price (float), is_available (boolean), and authors (list of strings). Print all the information with appropriate labels.\nExercise 2: Create a dictionary representing a shopping cart with at least 3 items. Each item should have a name, price, and quantity. Calculate and print the total cost of the cart.\nExercise 3: Given the string “Python is a versatile programming language”, write code to:\nConvert it to all uppercase Count how many times the letter ‘a’ appears Replace “Python” with “Java” and print the result Split it into a list of words Hint for Exercise 1: Remember to use appropriate variable names and print using formatted strings (f-strings) for cleaner output.\nIn the next section, we’ll explore operators and expressions in Python, building on your knowledge of variables and data types.","type-conversion#Type Conversion":"Python allows you to convert between different data types:\n# Converting between numeric types x = 10 float_x = float(x) # 10.0 complex_x = complex(x) # 10+0j # Converting to and from strings age = 30 age_str = str(age) # \"30\" age_back = int(age_str) # 30 # String to list greeting = \"Hello\" char_list = list(greeting) # ['H', 'e', 'l', 'l', 'o'] # List to tuple numbers = [1, 2, 3] numbers_tuple = tuple(numbers) # (1, 2, 3) Important: Converting between types can lead to data loss or errors. For example, converting a float to an integer truncates the decimal part, and trying to convert an invalid string to a number will raise an error.\n# Data loss example pi = 3.14159 pi_int = int(pi) # 3 (decimal part is lost) # Error example try: num = int(\"hello\") # This will raise a ValueError except ValueError as e: print(f\"Error: {e}\") # Error: invalid literal for int() with base 10: 'hello' ","variables-and-data-types-in-practice#Variables and Data Types in Practice":"Let’s see a complete example that demonstrates various data types and variable operations:\n# Student Record Management Example # Numeric types student_id = 12345 gpa = 3.75 complex_number = 1 + 2j # Not typically used in this context # String data first_name = \"Alice\" last_name = \"Smith\" full_name = first_name + \" \" + last_name # String concatenation # Boolean data is_enrolled = True is_on_probation = False # List - mutable sequence courses = [\"Math\", \"Physics\", \"Computer Science\"] courses.append(\"Chemistry\") # Adding a course # Tuple - immutable sequence semester_dates = (\"January 15, 2023\", \"May 20, 2023\") # Dictionary - key-value pairs student_info = { \"id\": student_id, \"name\": full_name, \"gpa\": gpa, \"courses\": courses, \"enrolled\": is_enrolled } # Set - unique elements unique_student_ids = {12345, 67890, 54321} # None - absence of value graduation_date = None # Not yet determined # Type conversions gpa_string = str(gpa) # Convert to string for formatting gpa_rounded = int(gpa) # Convert to integer (loses decimal precision) # Printing information print(f\"Student Record for {full_name} (ID: {student_id})\") print(f\"GPA: {gpa}\") print(f\"Courses: {', '.join(courses)}\") print(f\"Enrollment status: {'Enrolled' if is_enrolled else 'Not enrolled'}\") # Accessing dictionary values print(f\"Information from dictionary: {student_info['name']} has a GPA of {student_info['gpa']}\") # Checking types print(f\"Type of student_id: {type(student_id)}\") print(f\"Type of courses: {type(courses)}\") print(f\"Type of student_info: {type(student_info)}\") Expected Output:\nStudent Record for Alice Smith (ID: 12345) GPA: 3.75 Courses: Math, Physics, Computer Science, Chemistry Enrollment status: Enrolled Information from dictionary: Alice Smith has a GPA of 3.75 Type of student_id: \u003cclass 'int'\u003e Type of courses: \u003cclass 'list'\u003e Type of student_info: \u003cclass 'dict'\u003e ","variables-are-references#Variables are References":"In Python, variables are references to objects in memory. Understanding this concept is important:\na = [1, 2, 3] # 'a' references a list b = a # 'b' references the same list as 'a' b.append(4) # Modifies the list print(a) # [1, 2, 3, 4] - 'a' also reflects the change To create a copy rather than a reference:\na = [1, 2, 3] b = a.copy() # Creates a new list with the same elements b.append(4) print(a) # [1, 2, 3] - 'a' is unchanged print(b) # [1, 2, 3, 4] "},"title":"Variables and Data Types"},"/python-fundamentals/01-basics/05-operators-and-expressions/":{"data":{"":"In Python, operators are special symbols that perform operations on variables and values. An expression is a combination of values, variables, and operators that evaluates to a result.","arithmetic-expressions#Arithmetic Expressions":" result = 10 + 5 * 2 - 3 / 2 print(f\"10 + 5 * 2 - 3 / 2 = {result}\") # 18.5 ","arithmetic-operators#Arithmetic Operators":"Arithmetic operators perform mathematical operations on numeric values:\nOperator Name Example Result + Addition 5 + 3 8 - Subtraction 5 - 3 2 * Multiplication 5 * 3 15 / Division 5 / 3 1.6666667 % Modulus (remainder) 5 % 3 2 ** Exponentiation 5 ** 3 125 // Floor Division 5 // 3 1 # Arithmetic operators in action a = 10 b = 3 addition = a + b # 13 subtraction = a - b # 7 multiplication = a * b # 30 division = a / b # 3.3333333333333335 modulus = a % b # 1 exponent = a ** b # 1000 floor_div = a // b # 3 print(f\"Addition: {addition}\") print(f\"Subtraction: {subtraction}\") print(f\"Multiplication: {multiplication}\") print(f\"Division: {division}\") print(f\"Modulus: {modulus}\") print(f\"Exponentiation: {exponent}\") print(f\"Floor Division: {floor_div}\") Important: Division (/) always returns a float, while floor division (//) returns an integer by truncating the decimal part.","assignment-operators#Assignment Operators":"Assignment operators are used to assign values to variables:\nOperator Example Equivalent to = x = 5 x = 5 += x += 5 x = x + 5 -= x -= 5 x = x - 5 *= x *= 5 x = x * 5 /= x /= 5 x = x / 5 %= x %= 5 x = x % 5 **= x **= 5 x = x ** 5 //= x //= 5 x = x // 5 # Assignment operators in action x = 10 print(f\"Initial value: {x}\") # 10 x += 5 print(f\"After x += 5: {x}\") # 15 x -= 3 print(f\"After x -= 3: {x}\") # 12 x *= 2 print(f\"After x *= 2: {x}\") # 24 x /= 6 print(f\"After x /= 6: {x}\") # 4.0 x %= 3 print(f\"After x %= 3: {x}\") # 1.0 y = 2 y **= 3 print(f\"After y **= 3: {y}\") # 8 y //= 3 print(f\"After y //= 3: {y}\") # 2 ","bitwise-operators#Bitwise Operators":"Bitwise operators act on operands as if they were strings of binary digits:\nOperator Description Example \u0026 Bitwise AND 5 \u0026 3 (1) | Bitwise OR 5 | 3 (7) ^ Bitwise XOR 5 ^ 3 (6) ~ Bitwise NOT ~5 (-6) \u003c\u003c Left shift 5 \u003c\u003c 1 (10) \u003e\u003e Right shift 5 \u003e\u003e 1 (2) # Bitwise operators in action a = 5 # 101 in binary b = 3 # 011 in binary print(f\"a \u0026 b: {a \u0026 b}\") # 1 (001 in binary) print(f\"a | b: {a | b}\") # 7 (111 in binary) print(f\"a ^ b: {a ^ b}\") # 6 (110 in binary) print(f\"~a: {~a}\") # -6 (due to two's complement) print(f\"a \u003c\u003c 1: {a \u003c\u003c 1}\") # 10 (1010 in binary) print(f\"a \u003e\u003e 1: {a \u003e\u003e 1}\") # 2 (10 in binary) Note: Bitwise operators are less commonly used in everyday Python programming but are essential for certain types of low-level operations, especially in fields like cryptography, network programming, and embedded systems.","boolean-expressions#Boolean Expressions":" has_permission = is_admin or (is_editor and document_owner) ","common-mistakes-with-operators#Common Mistakes with Operators":" Using assignment (=) instead of equality comparison (==):\n# Incorrect if x = 5: # SyntaxError print(\"x is 5\") # Correct if x == 5: print(\"x is 5\") Incorrect operator precedence assumptions:\n# Might be expecting 9, but result is 7 result = 1 + 2 * 3 # Using parentheses for clarity result = (1 + 2) * 3 # 9 Floating-point precision issues:\n# Might expect True, but often False due to floating-point precision 0.1 + 0.2 == 0.3 # Better approach import math math.isclose(0.1 + 0.2, 0.3) Using is when you should use ==:\n# Incorrect for value comparison if a is 5: # Works sometimes due to Python's optimization, but unreliable print(\"a equals 5\") # Correct if a == 5: print(\"a equals 5\") ","comparison-expressions#Comparison Expressions":" is_valid = (age \u003e= 18) and (country in [\"USA\", \"Canada\", \"Mexico\"]) ","comparison-operators#Comparison Operators":"Comparison operators compare values and return Boolean results:\nOperator Description Example == Equal to 5 == 5 (True) != Not equal to 5 != 3 (True) \u003e Greater than 5 \u003e 3 (True) \u003c Less than 5 \u003c 3 (False) \u003e= Greater than or equal to 5 \u003e= 5 (True) \u003c= Less than or equal to 5 \u003c= 3 (False) # Comparison operators in action a = 10 b = 5 c = 10 print(f\"a == b: {a == b}\") # False print(f\"a != b: {a != b}\") # True print(f\"a \u003e b: {a \u003e b}\") # True print(f\"a \u003c b: {a \u003c b}\") # False print(f\"a \u003e= c: {a \u003e= c}\") # True print(f\"a \u003c= c: {a \u003c= c}\") # True Note: Don’t confuse the assignment operator (=) with the equality comparison operator (==). A common error is using = when you mean == in conditional statements.","exercises#Exercises":"Exercise 1: Write a program that calculates the area and perimeter of a rectangle. Ask the user for the length and width, and use appropriate operators to perform the calculations.\nExercise 2: Create a program that takes a user’s age as input and determines which category they fall into: child (0-12), teenager (13-19), adult (20-64), or senior (65+). Use logical operators for the conditions.\nExercise 3: Write a program that asks for three numbers and outputs them in ascending order (smallest to largest). Use comparison operators and conditional statements.\nHint for Exercise 1: The area of a rectangle is length × width, and the perimeter is 2 × (length + width).\nIn the next section, we’ll explore comments and documentation in Python, learning how to make your code more understandable and maintainable.","expressions-in-python#Expressions in Python":"An expression is a combination of values, variables, operators, and function calls that evaluates to a value. Python has several types of expressions:","identity-operators#Identity Operators":"Identity operators compare object identities:\nOperator Description Example is Returns True if both variables reference the same object x is y is not Returns True if both variables do not reference the same object x is not y # Identity operators in action a = [1, 2, 3] b = [1, 2, 3] c = a print(f\"a is b: {a is b}\") # False (different objects with same content) print(f\"a is c: {a is c}\") # True (same object) print(f\"a is not b: {a is not b}\") # True Note: The is operator checks if two variables refer to the same object in memory, while == checks if the contents of the objects are equal.","logical-operators#Logical Operators":"Logical operators combine conditional statements:\nOperator Description Example and Returns True if both statements are true x \u003c 5 and x \u003c 10 or Returns True if one of the statements is true x \u003c 5 or x \u003c 4 not Reverses the result, returns False if the result is true not(x \u003c 5 and x \u003c 10) # Logical operators in action x = 7 print(f\"x \u003e 5 and x \u003c 10: {x \u003e 5 and x \u003c 10}\") # True print(f\"x \u003e 5 and x \u003e 10: {x \u003e 5 and x \u003e 10}\") # False print(f\"x \u003e 5 or x \u003e 10: {x \u003e 5 or x \u003e 10}\") # True print(f\"not(x \u003e 5): {not(x \u003e 5)}\") # False Important: Python evaluates expressions from left to right. With and, if the first expression is False, Python doesn’t evaluate the second expression. With or, if the first expression is True, Python doesn’t evaluate the second expression. This is called short-circuit evaluation.","membership-operators#Membership Operators":"Membership operators test if a sequence contains an object:\nOperator Description Example in Returns True if a value exists in the sequence x in y not in Returns True if a value does not exist in the sequence x not in y # Membership operators in action fruits = [\"apple\", \"banana\", \"cherry\"] text = \"Hello, World!\" print(f\"'apple' in fruits: {'apple' in fruits}\") # True print(f\"'orange' in fruits: {'orange' in fruits}\") # False print(f\"'orange' not in fruits: {'orange' not in fruits}\") # True print(f\"'H' in text: {'H' in text}\") # True print(f\"'hello' in text: {'hello' in text}\") # False (case sensitive) ","operator-precedence#Operator Precedence":"Operators have a precedence that determines the order of evaluation in expressions with multiple operators:\nPrecedence Operator(s) Description 1 () Parentheses 2 ** Exponentiation 3 +x, -x, ~x Unary plus, minus, and bitwise NOT 4 *, /, //, % Multiplication, division, floor division, modulus 5 +, - Addition, subtraction 6 \u003c\u003c, \u003e\u003e Bitwise shifts 7 \u0026 Bitwise AND 8 ^ Bitwise XOR 9 | Bitwise OR 10 ==, !=, \u003e, \u003e=, \u003c, \u003c=, is, is not, in, not in Comparisons, identity, membership 11 not Logical NOT 12 and Logical AND 13 or Logical OR # Operator precedence in action x = 2 + 3 * 4 # 14, not 20 because * has higher precedence than + print(f\"2 + 3 * 4 = {x}\") y = (2 + 3) * 4 # 20, parentheses have highest precedence print(f\"(2 + 3) * 4 = {y}\") z = 2 ** 3 * 2 # 16, ** has higher precedence than * print(f\"2 ** 3 * 2 = {z}\") w = 5 + 4 \u003e 3 + 2 # True, arithmetic operations before comparison print(f\"5 + 4 \u003e 3 + 2: {w}\") v = not 1 + 2 == 3 # False, arithmetic and comparison before logical print(f\"not 1 + 2 == 3: {v}\") Important: When in doubt about operator precedence, use parentheses to explicitly specify the order of operations. This makes your code more readable and less prone to errors.","practical-example-temperature-converter#Practical Example: Temperature Converter":"The following example demonstrates the use of operators and expressions in a practical temperature converter:\ndef convert_temperature(): \"\"\" A function to convert temperatures between Celsius and Fahrenheit. Demonstrates operators and expressions in Python. \"\"\" print(\"Temperature Converter\") print(\"=====================\") print(\"1. Celsius to Fahrenheit\") print(\"2. Fahrenheit to Celsius\") choice = int(input(\"Enter your choice (1/2): \")) if choice == 1: # Celsius to Fahrenheit conversion celsius = float(input(\"Enter temperature in Celsius: \")) # The conversion formula: F = (C × 9/5) + 32 fahrenheit = (celsius * 9/5) + 32 print(f\"{celsius}°C is equal to {fahrenheit:.2f}°F\") # Additional information using comparison operators if celsius \u003c 0: print(\"That's below freezing!\") elif celsius == 0: print(\"That's the freezing point of water.\") elif celsius == 100: print(\"That's the boiling point of water at sea level.\") elif celsius \u003e 38: print(\"That's extremely hot!\") elif choice == 2: # Fahrenheit to Celsius conversion fahrenheit = float(input(\"Enter temperature in Fahrenheit: \")) # The conversion formula: C = (F - 32) × 5/9 celsius = (fahrenheit - 32) * 5/9 print(f\"{fahrenheit}°F is equal to {celsius:.2f}°C\") # Additional information using logical operators if fahrenheit \u003c 32: print(\"That's below freezing!\") elif fahrenheit == 32: print(\"That's the freezing point of water.\") elif fahrenheit == 212: print(\"That's the boiling point of water at sea level.\") elif fahrenheit \u003e 100 and celsius \u003c 38: print(\"That's hot but not extremely hot in Celsius.\") elif celsius \u003e= 38: print(\"That's extremely hot!\") else: print(\"Invalid choice. Please enter 1 or 2.\") # Call the function to run the temperature converter convert_temperature() Expected Output (for input choice 1 and temperature 25):\nTemperature Converter ===================== 1. Celsius to Fahrenheit 2. Fahrenheit to Celsius Enter your choice (1/2): 1 Enter temperature in Celsius: 25 25°C is equal to 77.00°F ","string-expressions#String Expressions":" greeting = \"Hello, \" + name + \"! Welcome to \" + platform formatted_greeting = f\"Hello, {name}! Welcome to {platform}\" "},"title":"Operators and Expressions"},"/python-fundamentals/01-basics/06-input-output-operations/":{"data":{"":"","common-io-issues-and-best-practices#Common I/O Issues and Best Practices":" Always use context managers (with statement) when working with files to ensure they are properly closed, even if an exception occurs.\nHandle file exceptions properly:\ntry: with open(\"file.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"The file does not exist.\") except PermissionError: print(\"You don't have permission to access this file.\") except Exception as e: print(f\"An error occurred: {e}\") Validate user input before processing:\nwhile True: try: age = int(input(\"Enter your age: \")) if age \u003c 0 or age \u003e 120: print(\"Please enter a valid age between 0 and 120.\") continue break except ValueError: print(\"Please enter a valid number.\") Use appropriate file modes to avoid accidentally overwriting data.\nConsider character encoding when working with text files:\nwith open(\"file.txt\", \"r\", encoding=\"utf-8\") as file: content = file.read() ","exercises#Exercises":"Exercise 1: Write a program that asks the user for their name, age, and favorite color. Then display a formatted message that includes this information.\nExercise 2: Create a program that reads a text file, counts the number of lines, words, and characters, and displays the results.\nExercise 3: Build a simple note-taking application that allows the user to add notes, view all notes, and save them to a file. When the program starts, it should load any existing notes from the file.\nHint for Exercise 1: Use the input() function to get user information and f-strings to format the output message.\nIn the next section, we’ll explore conditional statements in Python, learning how to make decisions in your programs based on different conditions.","input-and-output-operations#Input and Output Operations":"Input and output operations are fundamental to any programming language. They allow your program to interact with users, files, and other systems.\nBasic Output with print() The print() function displays text and variables to the console:\n# Simple print statement print(\"Hello, World!\") # Printing multiple items print(\"The answer is\", 42) # Printing with variables name = \"Alice\" age = 30 print(\"Name:\", name, \"Age:\", age) The print() function has several useful parameters:\nParameter Description Example sep Separator between items (default is space) print(\"Hello\", \"World\", sep=\"-\") end String at the end (default is newline) print(\"Hello\", end=\"! \") file File-like object to write to print(\"Log entry\", file=log_file) flush Whether to flush the stream print(\"Progress\", flush=True) # Using print parameters print(\"Apple\", \"Banana\", \"Cherry\", sep=\" | \") # Apple | Banana | Cherry # Preventing new line with end parameter print(\"Hello\", end=\" \") print(\"World!\") # Hello World! # Printing a numbered list for i in range(1, 4): print(i, end=\". \") print(f\"Item {i}\") # Output: # 1. Item 1 # 2. Item 2 # 3. Item 3 String Formatting in Output Python offers multiple ways to format strings for output:\n1. f-strings (Python 3.6+) name = \"Alice\" age = 30 print(f\"Name: {name}, Age: {age}\") # Name: Alice, Age: 30 # Expressions in f-strings print(f\"Age in 5 years: {age + 5}\") # Age in 5 years: 35 # Formatting specifications pi = 3.14159 print(f\"Pi to 2 decimal places: {pi:.2f}\") # Pi to 2 decimal places: 3.14 2. str.format() method name = \"Bob\" age = 25 print(\"Name: {}, Age: {}\".format(name, age)) # Name: Bob, Age: 25 # Positional references print(\"Age: {1}, Name: {0}\".format(name, age)) # Age: 25, Name: Bob # Named references print(\"Name: {n}, Age: {a}\".format(n=name, a=age)) # Name: Bob, Age: 25 3. % operator (older style) name = \"Charlie\" age = 35 print(\"Name: %s, Age: %d\" % (name, age)) # Name: Charlie, Age: 35 Important: f-strings (introduced in Python 3.6) are the recommended approach for string formatting due to their readability and performance. They allow embedding expressions directly in string literals.\nBasic Input with input() The input() function reads a line from the console (as a string):\n# Simple input name = input(\"Enter your name: \") print(f\"Hello, {name}!\") # Note: input() always returns a string age_str = input(\"Enter your age: \") age = int(age_str) # Convert to integer print(f\"In 5 years, you will be {age + 5} years old.\") # Converting directly height = float(input(\"Enter your height in meters: \")) print(f\"Your height in centimeters: {height * 100}\") Note: Always validate user input before conversion to avoid errors. For example, if a user enters “twenty” when you expect a number, int(\"twenty\") will raise a ValueError.\n# Safe input conversion try: age = int(input(\"Enter your age: \")) print(f\"In 5 years, you will be {age + 5} years old.\") except ValueError: print(\"Invalid input. Please enter a number.\") Formatting Console Output You can enhance console output with various formatting techniques:\n# Creating tables print(\"Name\\tAge\\tCity\") print(\"----\\t---\\t----\") print(\"Alice\\t30\\tNew York\") print(\"Bob\\t25\\tChicago\") print(\"Charlie\\t35\\tSan Francisco\") # Using f-strings for table formatting data = [ {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}, {\"name\": \"Bob\", \"age\": 25, \"city\": \"Chicago\"}, {\"name\": \"Charlie\", \"age\": 35, \"city\": \"San Francisco\"} ] print(f\"{'Name':\u003c10}{'Age':\u003c8}{'City':\u003c15}\") print(f\"{'-'*10:\u003c10}{'-'*8:\u003c8}{'-'*15:\u003c15}\") for person in data: print(f\"{person['name']:\u003c10}{person['age']:\u003c8}{person['city']:\u003c15}\") Output:\nName Age City -------------- --------------- Alice 30 New York Bob 25 Chicago Charlie 35 San Francisco In the format specifiers ({value:\u003cwidth}):\n\u003c left-aligns text (default) \u003e right-aligns text ^ centers text The number represents the width Reading and Writing Files File I/O is a common operation in Python programs:\nOpening and Closing Files # Opening a file for reading ('r' is default mode) file = open(\"example.txt\", \"r\") content = file.read() file.close() # Important to close files # Better approach with context manager (automatically closes file) with open(\"example.txt\", \"r\") as file: content = file.read() # File is automatically closed when the block ends File Modes Mode Description 'r' Read (default) 'w' Write (create or truncate) 'a' Append (create if doesn’t exist) 'x' Exclusive creation (fail if file exists) 'b' Binary mode (add to other modes) 't' Text mode (default) '+' Update (read and write) Reading Files # Reading the entire file with open(\"example.txt\", \"r\") as file: content = file.read() print(content) # Reading line by line with open(\"example.txt\", \"r\") as file: for line in file: print(line.strip()) # strip() removes trailing newline # Reading all lines into a list with open(\"example.txt\", \"r\") as file: lines = file.readlines() for line in lines: print(line.strip()) Writing Files # Writing to a file (creates or overwrites) with open(\"output.txt\", \"w\") as file: file.write(\"Hello, World!\\n\") file.write(\"This is a new line.\") # Appending to a file with open(\"output.txt\", \"a\") as file: file.write(\"\\nThis line is appended.\") # Writing multiple lines lines = [\"Line 1\", \"Line 2\", \"Line 3\"] with open(\"output.txt\", \"w\") as file: file.writelines(line + \"\\n\" for line in lines) Working with CSV Files CSV (Comma-Separated Values) files are commonly used for tabular data:\nimport csv # Reading a CSV file with open(\"data.csv\", \"r\", newline=\"\") as file: reader = csv.reader(file) for row in reader: print(row) # row is a list of values # Reading a CSV with headers with open(\"data.csv\", \"r\", newline=\"\") as file: reader = csv.DictReader(file) # Assumes first row has headers for row in reader: print(row) # row is a dictionary # Writing a CSV file data = [ [\"Name\", \"Age\", \"City\"], [\"Alice\", 30, \"New York\"], [\"Bob\", 25, \"Chicago\"], [\"Charlie\", 35, \"San Francisco\"] ] with open(\"new_data.csv\", \"w\", newline=\"\") as file: writer = csv.writer(file) writer.writerows(data) # Writing a CSV with dictionaries data = [ {\"Name\": \"Alice\", \"Age\": 30, \"City\": \"New York\"}, {\"Name\": \"Bob\", \"Age\": 25, \"City\": \"Chicago\"}, {\"Name\": \"Charlie\", \"Age\": 35, \"City\": \"San Francisco\"} ] with open(\"new_data.csv\", \"w\", newline=\"\") as file: fieldnames = [\"Name\", \"Age\", \"City\"] writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() writer.writerows(data) Working with JSON Files JSON (JavaScript Object Notation) is a popular data format:\nimport json # Reading JSON from a file with open(\"data.json\", \"r\") as file: data = json.load(file) print(data) # data is a Python dictionary or list # Writing Python data to a JSON file data = { \"people\": [ {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}, {\"name\": \"Bob\", \"age\": 25, \"city\": \"Chicago\"}, {\"name\": \"Charlie\", \"age\": 35, \"city\": \"San Francisco\"} ] } with open(\"new_data.json\", \"w\") as file: json.dump(data, file, indent=4) # indent for pretty formatting ","practical-example-contact-manager#Practical Example: Contact Manager":"Let’s create a simple contact manager that demonstrates various input and output operations:\nimport json import os def contact_manager(): \"\"\" A simple contact manager that demonstrates input/output operations. \"\"\" contacts_file = \"contacts.json\" contacts = [] # Load existing contacts if the file exists if os.path.exists(contacts_file): try: with open(contacts_file, \"r\") as file: contacts = json.load(file) print(f\"Loaded {len(contacts)} contacts from {contacts_file}\") except json.JSONDecodeError: print(f\"Error loading {contacts_file}. Starting with empty contacts.\") while True: # Display menu print(\"\\nContact Manager\") print(\"===============\") print(\"1. View all contacts\") print(\"2. Add a contact\") print(\"3. Search contacts\") print(\"4. Save and exit\") choice = input(\"\\nEnter your choice (1-4): \") if choice == \"1\": # View all contacts if not contacts: print(\"No contacts found.\") else: print(\"\\n{:\u003c20} {:\u003c15} {:\u003c30}\".format(\"Name\", \"Phone\", \"Email\")) print(\"-\" * 65) for contact in contacts: print(\"{:\u003c20} {:\u003c15} {:\u003c30}\".format( contact.get(\"name\", \"N/A\"), contact.get(\"phone\", \"N/A\"), contact.get(\"email\", \"N/A\") )) elif choice == \"2\": # Add a contact name = input(\"Enter name: \") phone = input(\"Enter phone number: \") email = input(\"Enter email: \") contact = {\"name\": name, \"phone\": phone, \"email\": email} contacts.append(contact) print(f\"Contact {name} added successfully.\") elif choice == \"3\": # Search contacts search_term = input(\"Enter search term: \").lower() found = False print(\"\\n{:\u003c20} {:\u003c15} {:\u003c30}\".format(\"Name\", \"Phone\", \"Email\")) print(\"-\" * 65) for contact in contacts: name = contact.get(\"name\", \"\").lower() phone = contact.get(\"phone\", \"\").lower() email = contact.get(\"email\", \"\").lower() if (search_term in name or search_term in phone or search_term in email): print(\"{:\u003c20} {:\u003c15} {:\u003c30}\".format( contact.get(\"name\", \"N/A\"), contact.get(\"phone\", \"N/A\"), contact.get(\"email\", \"N/A\") )) found = True if not found: print(\"No matching contacts found.\") elif choice == \"4\": # Save and exit with open(contacts_file, \"w\") as file: json.dump(contacts, file, indent=4) print(f\"Contacts saved to {contacts_file}\") break else: print(\"Invalid choice. Please enter a number between 1 and 4.\") # Run the contact manager if __name__ == \"__main__\": contact_manager() Expected Output:\nLoaded 2 contacts from contacts.json Contact Manager =============== 1. View all contacts 2. Add a contact 3. Search contacts 4. Save and exit Enter your choice (1-4): 1 Name Phone Email ----------------------------------------------------------------- John Doe 555-123-4567 john.doe@example.com Jane Smith 555-987-6543 jane.smith@example.com Contact Manager =============== 1. View all contacts 2. Add a contact 3. Search contacts 4. Save and exit Enter your choice (1-4): 2 Enter name: Alice Johnson Enter phone number: 555-555-5555 Enter email: alice.j@example.com Contact Alice Johnson added successfully. Contact Manager =============== 1. View all contacts 2. Add a contact 3. Search contacts 4. Save and exit Enter your choice (1-4): 4 Contacts saved to contacts.json "},"title":"Input and Output Statements"},"/python-fundamentals/02-control-flow/":{"data":{"":"Control flow refers to the order in which your Python code executes and the structures that allow you to direct that flow based on conditions or repeat actions multiple times.\nUnderstanding how to control program execution is essential for creating dynamic applications that can make decisions, process collections of data, and respond to different scenarios appropriately.\nIn this section, you’ll learn about conditional statements that execute code based on whether conditions are true or false, loops that allow you to repeat code efficiently, and statements that help you manage the flow within these structures:\n01. Conditional Statements 02. Loops (for, while) 03. Break and Continue Statements 04. Pass Statement 05. Exception Handling Basics "},"title":"Control Flow"},"/python-fundamentals/02-control-flow/01-conditional-statements/":{"data":{"":"","age-group-classifier#Age Group Classifier":" def classify_age(age): \"\"\" Classify a person into an age group based on their age. Args: age (int): The person's age in years Returns: str: The age group classification \"\"\" if not isinstance(age, (int, float)): return \"Invalid age. Please provide a number.\" if age \u003c 0: return \"Invalid age. Age cannot be negative.\" elif age \u003c 2: return \"Infant\" elif age \u003c 13: return \"Child\" elif age \u003c 18: return \"Teenager\" elif age \u003c 65: return \"Adult\" else: return \"Senior\" # Test the function with different ages print(classify_age(1)) # Infant print(classify_age(10)) # Child print(classify_age(16)) # Teenager print(classify_age(35)) # Adult print(classify_age(70)) # Senior print(classify_age(-5)) # Invalid age print(classify_age(\"20\")) # Invalid age ","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"1. Using = instead of == in conditions A common mistake is using the assignment operator = instead of the equality operator == in conditions:\n# Incorrect - this assigns 10 to x and always evaluates to True if x = 10: print(\"x is 10\") # Correct - this checks if x equals 10 if x == 10: print(\"x is 10\") 2. Forgetting the colon : after conditions # Incorrect - missing colon if x \u003e 10 print(\"x is greater than 10\") # Correct if x \u003e 10: print(\"x is greater than 10\") 3. Incorrect indentation # Incorrect - inconsistent indentation if x \u003e 10: print(\"x is greater than 10\") print(\"This will cause an IndentationError\") # Correct if x \u003e 10: print(\"x is greater than 10\") print(\"This has the same indentation level\") 4. Using is when == is appropriate # Incorrect for value comparison if x is 10: # Works for some simple values due to implementation details but unreliable print(\"x is 10\") # Correct if x == 10: print(\"x is 10\") # `is` is appropriate for checking against None if x is None: print(\"x is None\") 5. Unnecessary else after return # Unnecessarily verbose def is_adult(age): if age \u003e= 18: return True else: # This else is unnecessary return False # More concise def is_adult(age): if age \u003e= 18: return True return False # Even more concise - directly return the condition result def is_adult(age): return age \u003e= 18 6. Complex nested conditions # Hard to read with deep nesting if condition1: if condition2: if condition3: do_something() else: do_something_else() else: do_yet_another_thing() # More readable with combined conditions if condition1 and condition2 and condition3: do_something() elif condition1 and condition2: do_something_else() elif condition1: do_yet_another_thing() 7. Early returns for cleaner code # Unnecessarily nested def process_data(data): if data: if validate(data): result = transform(data) if result: return result return None # Cleaner with early returns def process_data(data): if not data: return None if not validate(data): return None result = transform(data) if not result: return None return result ","comparison-operators-in-conditions#Comparison Operators in Conditions":"","conditional-expressions-ternary-operator#Conditional Expressions (Ternary Operator)":"","exercises#Exercises":"Exercise 1: Write a program that asks for a user’s age and determines if they are eligible to vote (18 or older). The program should handle invalid inputs (like negative ages or non-numeric values) gracefully.\nExercise 2: Create a function that takes a temperature and a scale (‘C’ for Celsius or ‘F’ for Fahrenheit) and returns a description of the weather (e.g., “Cold”, “Moderate”, “Hot”). Define your own temperature ranges for each category.\nExercise 3: Write a program that simulates a simple ATM. It should ask for a PIN, check if it’s correct (use a hardcoded PIN for this exercise), and then allow the user to check their balance, deposit money, or withdraw money. Use nested if statements or a combination of if-elif-else statements.\nHint for Exercise 1: Use a try-except block to handle non-numeric inputs, and an if statement to check for negative ages.\n# Exercise 1 solution outline try: age = int(input(\"Enter your age: \")) if age \u003c 0: print(\"Age cannot be negative.\") elif age \u003e= 18: print(\"You are eligible to vote.\") else: print(\"You are not eligible to vote yet.\") except ValueError: print(\"Invalid input. Please enter a numeric age.\") In the next section, we’ll explore loops in Python, including for and while loops, which allow you to repeat code execution.","logical-operators-for-combining-conditions#Logical Operators for Combining Conditions":"","nested-conditional-statements#Nested Conditional Statements":"","password-strength-checker#Password Strength Checker":" def check_password_strength(password): \"\"\" Check the strength of a password based on various criteria. Args: password (str): The password to check Returns: str: A description of the password strength \"\"\" if not isinstance(password, str): return \"Invalid password. Password must be a string.\" # Check password length if len(password) \u003c 8: return \"Weak: Password should be at least 8 characters long.\" # Initialize strength checks has_uppercase = False has_lowercase = False has_digit = False has_special = False # Define special characters special_chars = \"!@#$%^\u0026*()-_=+[]{}|;:'\\\",.\u003c\u003e/?\" # Check each character in the password for char in password: if char.isupper(): has_uppercase = True elif char.islower(): has_lowercase = True elif char.isdigit(): has_digit = True elif char in special_chars: has_special = True # Determine strength based on criteria met if has_uppercase and has_lowercase and has_digit and has_special: if len(password) \u003e= 12: return \"Very Strong: Excellent password!\" else: return \"Strong: Good password, but could be longer.\" elif (has_uppercase and has_lowercase and has_digit) or \\ (has_uppercase and has_lowercase and has_special) or \\ (has_uppercase and has_digit and has_special) or \\ (has_lowercase and has_digit and has_special): return \"Moderate: Password meets some criteria but not all.\" else: return \"Weak: Password should contain uppercase letters, lowercase letters, digits, and special characters.\" # Test the function with different passwords print(check_password_strength(\"password\")) # Weak (length is good but missing criteria) print(check_password_strength(\"Password123\")) # Moderate (missing special chars) print(check_password_strength(\"Pas$word123\")) # Strong print(check_password_strength(\"Str0ng\u0026SecurePa$$word\")) # Very Strong ","practical-examples#Practical Examples":"","simple-calculator#Simple Calculator":" def simple_calculator(): \"\"\"A simple calculator that performs basic arithmetic operations.\"\"\" print(\"Simple Calculator\") print(\"=================\") print(\"Operations:\") print(\"1. Addition (+)\") print(\"2. Subtraction (-)\") print(\"3. Multiplication (*)\") print(\"4. Division (/)\") try: num1 = float(input(\"Enter first number: \")) num2 = float(input(\"Enter second number: \")) operation = input(\"Enter operation (1-4): \") if operation == \"1\": result = num1 + num2 print(f\"{num1} + {num2} = {result}\") elif operation == \"2\": result = num1 - num2 print(f\"{num1} - {num2} = {result}\") elif operation == \"3\": result = num1 * num2 print(f\"{num1} * {num2} = {result}\") elif operation == \"4\": if num2 == 0: print(\"Error: Division by zero is not allowed.\") else: result = num1 / num2 print(f\"{num1} / {num2} = {result}\") else: print(\"Invalid operation. Please enter a number between 1 and 4.\") except ValueError: print(\"Invalid input. Please enter numeric values.\") # Run the calculator simple_calculator() ","the-elif-statement#The \u003ccode\u003eelif\u003c/code\u003e Statement":"","the-else-statement#The \u003ccode\u003eelse\u003c/code\u003e Statement":"","the-if-statement#The \u003ccode\u003eif\u003c/code\u003e Statement":"","the-is-and-in-operators-in-conditions#The \u003ccode\u003eis\u003c/code\u003e and \u003ccode\u003ein\u003c/code\u003e Operators in Conditions":"Conditional statements allow your program to make decisions based on certain conditions. They are fundamental building blocks in programming that enable your code to take different paths depending on whether specific conditions are true or false.\nThe if Statement The basic form of a conditional statement in Python is the if statement:\nif condition: # Code to execute if condition is True When Python encounters an if statement, it evaluates the condition. If the condition is True, the indented code block beneath it executes. If the condition is False, the indented code block is skipped.\nage = 18 if age \u003e= 18: print(\"You are an adult.\") print(\"You can vote.\") print(\"This line always executes regardless of the condition.\") In this example, if the variable age is 18 or greater, both lines inside the if block will execute. The final print statement is outside the if block, so it always executes.\nThe else Statement The else statement provides an alternative code block to execute when the if condition is False:\nif condition: # Code to execute if condition is True else: # Code to execute if condition is False age = 15 if age \u003e= 18: print(\"You are an adult.\") print(\"You can vote.\") else: print(\"You are not yet an adult.\") print(\"You cannot vote yet.\") print(\"This line always executes regardless of the condition.\") In this example, since age is 15 (less than 18), the else block executes instead of the if block.\nThe elif Statement The elif (short for “else if”) statement allows you to check multiple conditions in sequence:\nif condition1: # Code to execute if condition1 is True elif condition2: # Code to execute if condition1 is False and condition2 is True elif condition3: # Code to execute if condition1 and condition2 are False and condition3 is True else: # Code to execute if all conditions are False score = 85 if score \u003e= 90: grade = \"A\" elif score \u003e= 80: grade = \"B\" elif score \u003e= 70: grade = \"C\" elif score \u003e= 60: grade = \"D\" else: grade = \"F\" print(f\"Your grade is: {grade}\") In this grading example, Python checks each condition in order until it finds one that is True. In this case, score is 85, so the second condition (score \u003e= 80) is the first one that evaluates to True. Therefore, grade is set to “B”.\nImportant: Python checks conditions in the order they appear. Once it finds a condition that is True, it executes that block and then skips all the remaining conditions in that if-elif-else chain.\nNested Conditional Statements You can place conditional statements inside other conditional statements, creating nested structures:\nage = 25 income = 50000 if age \u003e= 18: print(\"You are an adult.\") if income \u003e= 30000: print(\"You earn above the minimum income threshold.\") if income \u003e= 100000: print(\"You are in the high-income bracket.\") else: print(\"You are in the middle-income bracket.\") else: print(\"Your income is below the minimum threshold.\") else: print(\"You are not yet an adult.\") Nested conditionals allow for more complex decision-making but can become difficult to read if too deeply nested. It’s often better to keep your code as flat as possible.\nConditional Expressions (Ternary Operator) Python offers a concise way to write simple if-else statements using conditional expressions, sometimes called the ternary operator:\n# Standard if-else if condition: x = value1 else: x = value2 # Equivalent conditional expression x = value1 if condition else value2 age = 20 status = \"adult\" if age \u003e= 18 else \"minor\" print(status) # Output: \"adult\" # Price calculation with ternary operator is_member = True price = 50.0 * (0.9 if is_member else 1.0) # 10% discount for members print(price) # Output: 45.0 Conditional expressions are ideal for simple assignments based on conditions, making the code more compact and readable in these cases.\nTruthy and Falsy Values In Python, conditions don’t have to be explicit boolean expressions. Any value can be interpreted as a boolean in an if statement:\nFalsy values (interpreted as False):\nFalse None Zero of any numeric type (0, 0.0, 0j) Empty sequences and collections ('', (), [], {}, set()) Objects that define __bool__() to return False or __len__() to return 0 Truthy values (interpreted as True):\nEverything else # Examples of truthy and falsy values name = \"\" numbers = [1, 2, 3] zero = 0 if name: print(\"Name is not empty\") # This won't execute because name is an empty string (falsy) if numbers: print(\"List is not empty\") # This will execute because numbers is a non-empty list (truthy) if zero: print(\"Zero is truthy\") # This won't execute because 0 is falsy else: print(\"Zero is falsy\") # This will execute This behavior allows for concise code to check if a variable has a meaningful value:\nuser_input = input(\"Enter your name: \") if user_input: print(f\"Hello, {user_input}!\") else: print(\"You didn't enter a name.\") Comparison Operators in Conditions Conditions often use comparison operators to compare values:\nOperator Description Example == Equal to x == y != Not equal to x != y \u003e Greater than x \u003e y \u003c Less than x \u003c y \u003e= Greater than or equal to x \u003e= y \u003c= Less than or equal to x \u003c= y x = 10 y = 20 if x == y: print(\"x equals y\") elif x \u003e y: print(\"x is greater than y\") else: print(\"x is less than y\") # This will execute Logical Operators for Combining Conditions You can combine multiple conditions using logical operators:\nOperator Description Example and True if both conditions are true x \u003e 0 and x \u003c 10 or True if at least one condition is true x \u003c 0 or x \u003e 10 not Inverts the result, True becomes False and vice versa not x == y age = 25 income = 50000 if age \u003e= 18 and income \u003e= 30000: print(\"You qualify for the loan.\") temperature = 15 if temperature \u003c 0 or temperature \u003e 30: print(\"Extreme temperature warning.\") is_weekend = True if not is_weekend: print(\"It's a weekday.\") else: print(\"It's the weekend.\") # This will execute When combining conditions with logical operators, understanding the order of evaluation is important:\nParentheses not and or # This condition is more complex but follows the rules of precedence if (age \u003e= 18 and income \u003e= 30000) or (has_guarantor and has_collateral): print(\"Loan application accepted\") The is and in Operators in Conditions The is operator checks if two variables refer to the same object in memory:\na = [1, 2, 3] b = [1, 2, 3] c = a if a is c: print(\"a and c reference the same object\") # This will execute if a is b: print(\"a and b reference the same object\") # This won't execute else: print(\"a and b are different objects with the same content\") # This will execute The in operator checks if a value exists in a sequence:\nfruits = [\"apple\", \"banana\", \"cherry\"] if \"banana\" in fruits: print(\"Banana is in the list\") # This will execute name = \"John\" if \"o\" in name: print(\"The letter 'o' is in the name\") # This will execute Note: Don’t confuse == (equality of values) with is (identity of objects). For most comparisons, you should use ==. The is operator is primarily used to check if a variable is None or to verify object identity.","truthy-and-falsy-values#Truthy and Falsy Values":""},"title":"Conditional Statements"},"/python-fundamentals/02-control-flow/02-loops/":{"data":{"":"","dictionary-comprehensions#Dictionary Comprehensions":"Similar to list comprehensions, you can create dictionaries in a concise way:\n# Create a dictionary of squares squares_dict = {i: i ** 2 for i in range(1, 6)} print(squares_dict) # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} # Create a dictionary with a condition even_squares_dict = {i: i ** 2 for i in range(1, 11) if i % 2 == 0} print(even_squares_dict) # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100} Practical Examples Example 1: Sum of Numbers Calculate the sum of all numbers from 1 to n using both for and while loops:\ndef sum_with_for(n): \"\"\"Calculate the sum of numbers from 1 to n using a for loop.\"\"\" total = 0 for i in range(1, n + 1): total += i return total def sum_with_while(n): \"\"\"Calculate the sum of numbers from 1 to n using a while loop.\"\"\" total = 0 i = 1 while i \u003c= n: total += i i += 1 return total # Test both functions n = 10 print(f\"Sum of numbers from 1 to {n} (for loop): {sum_with_for(n)}\") print(f\"Sum of numbers from 1 to {n} (while loop): {sum_with_while(n)}\") Example 2: FizzBuzz The classic programming challenge:\ndef fizzbuzz(n): \"\"\" Print numbers from 1 to n, but for multiples of 3 print \"Fizz\", for multiples of 5 print \"Buzz\", and for multiples of both print \"FizzBuzz\". \"\"\" for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: print(\"FizzBuzz\") elif i % 3 == 0: print(\"Fizz\") elif i % 5 == 0: print(\"Buzz\") else: print(i) # Run FizzBuzz for numbers 1 to 15 fizzbuzz(15) Example 3: Prime Number Finder Find all prime numbers up to a given limit:\ndef find_primes(limit): \"\"\"Find all prime numbers up to the given limit.\"\"\" primes = [] for num in range(2, limit + 1): is_prime = True # Check if num is divisible by any smaller number for divisor in range(2, int(num ** 0.5) + 1): if num % divisor == 0: is_prime = False break if is_prime: primes.append(num) return primes # Find all primes up to 50 print(find_primes(50)) Example 4: Word Counter Count the occurrences of each word in a text:\ndef count_words(text): \"\"\"Count the occurrences of each word in the given text.\"\"\" # Create an empty dictionary to store word counts word_counts = {} # Split the text into words words = text.split() # Loop through each word for word in words: # Remove punctuation and convert to lowercase clean_word = word.strip(\".,!?\\\"'()[]{}:;\").lower() if clean_word: # Skip empty strings # Increment the count for this word if clean_word in word_counts: word_counts[clean_word] += 1 else: word_counts[clean_word] = 1 return word_counts # Sample text sample_text = \"\"\" Python is a powerful programming language. Python is easy to learn. Python is used for web development, data analysis, artificial intelligence, and more. \"\"\" # Count words result = count_words(sample_text) # Print the results in a readable format print(\"Word Counts:\") for word, count in sorted(result.items()): print(f\"{word}: {count}\") Loop Efficiency and Best Practices 1. Choose the Right Loop Use for loops when you know the number of iterations in advance or when iterating over a collection. Use while loops when you need to continue until a condition changes or for indefinite iterations. # Good use of for loop for i in range(10): print(i) # Good use of while loop response = \"\" while response != \"quit\": response = input(\"Enter a command (type 'quit' to exit): \") # Process the response 2. Avoid Modifying the Iteration Variable in a for Loop In Python, the iteration variable is automatically updated by the loop mechanism. Modifying it manually can lead to unexpected behavior:\n# Problematic - modifying the iteration variable for i in range(5): print(i) i += 2 # This has no effect on the loop's behavior # Better approach if you need to skip items i = 0 while i \u003c 5: print(i) i += 3 # Skip by incrementing more than 1 3. Avoid Modifying Collections During Iteration Modifying a collection while iterating over it can lead to unexpected behavior:\n# Problematic - modifying a list during iteration numbers = [1, 2, 3, 4, 5] for num in numbers: if num % 2 == 0: numbers.remove(num) # This modifies the list being iterated # Better approach numbers = [1, 2, 3, 4, 5] numbers = [num for num in numbers if num % 2 != 0] # or odd_numbers = [] for num in numbers: if num % 2 != 0: odd_numbers.append(num) numbers = odd_numbers 4. Use enumerate() Instead of Manual Counting # Manual index tracking fruits = [\"apple\", \"banana\", \"cherry\"] index = 0 for fruit in fruits: print(f\"{index}: {fruit}\") index += 1 # Better approach with enumerate() for index, fruit in enumerate(fruits): print(f\"{index}: {fruit}\") 5. Use List Comprehensions for Simple Transformations # Traditional loop for transformation numbers = [1, 2, 3, 4, 5] squared = [] for num in numbers: squared.append(num ** 2) # Cleaner approach with list comprehension numbers = [1, 2, 3, 4, 5] squared = [num ** 2 for num in numbers] 6. Break Out of Complex Loops Early def find_item(matrix, target): \"\"\"Find an item in a 2D matrix.\"\"\" for i, row in enumerate(matrix): for j, value in enumerate(row): if value == target: return (i, j) # Return early when found return None # Not found 7. Be Aware of the Performance Impact of Nested Loops Nested loops multiply the number of iterations, which can impact performance for large data sets:\n# This runs in O(n²) time n = 1000 for i in range(n): for j in range(n): # Some operation # Consider if there's a more efficient algorithm Common Loop Patterns Pattern 1: Loop with a Counter count = 0 for item in collection: if condition(item): count += 1 print(f\"Found {count} items matching the condition\") Pattern 2: Find the Maximum/Minimum Value numbers = [23, 54, 12, 87, 34] max_value = numbers[0] # Assume the first item is the maximum for num in numbers[1:]: # Start from the second item if num \u003e max_value: max_value = num print(f\"The maximum value is {max_value}\") Pattern 3: Filtering Items original = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] filtered = [] for num in original: if num % 2 == 0: # Keep only even numbers filtered.append(num) print(filtered) # [2, 4, 6, 8, 10] # Alternatively, using list comprehension filtered = [num for num in original if num % 2 == 0] Pattern 4: Aggregating Values expenses = [120.50, 35.75, 240.00, 55.25, 100.00] total = 0 for expense in expenses: total += expense print(f\"Total expenses: ${total:.2f}\") # Alternatively, using sum() total = sum(expenses) Pattern 5: Nested Loop for Combinations fruits = [\"apple\", \"banana\", \"cherry\"] colors = [\"red\", \"green\", \"blue\"] combinations = [] for fruit in fruits: for color in colors: combinations.append((fruit, color)) print(combinations) # [('apple', 'red'), ('apple', 'green'), ('apple', 'blue'), # ('banana', 'red'), ('banana', 'green'), ('banana', 'blue'), # ('cherry', 'red'), ('cherry', 'green'), ('cherry', 'blue')] # Alternatively, using list comprehension combinations = [(fruit, color) for fruit in fruits for color in colors] ","exercises#Exercises":"Exercise 1: Write a program that prints the multiplication table for a given number. For example, if the number is 5, it should print:\n5 x 1 = 5 5 x 2 = 10 ... 5 x 10 = 50 Exercise 2: Create a program that generates a list of all even numbers between 1 and 100 using a loop. Then create the same list using a list comprehension.\nExercise 3: Write a program that asks the user for a number and then prints all the factors of that number. A factor is a number that divides the given number without a remainder.\nExercise 4: Create a nested loop to generate a “pyramid” pattern like this:\n* ** *** **** ***** Hint for Exercise 1: Use a for loop with the range function to iterate from 1 to 10, and in each iteration, multiply the given number by the current loop variable.\n# Exercise 1 solution outline num = 5 for i in range(1, 11): result = num * i print(f\"{num} x {i} = {result}\") In the next section, we’ll explore break and continue statements in more detail, learn about the pass statement, and introduce exception handling basics.","list-comprehensions#List Comprehensions":"Python offers a concise way to create lists using a single line of code called a list comprehension:\n# Traditional approach squares = [] for i in range(1, 6): squares.append(i ** 2) print(squares) # [1, 4, 9, 16, 25] # List comprehension approach squares = [i ** 2 for i in range(1, 6)] print(squares) # [1, 4, 9, 16, 25] You can also add conditions to list comprehensions:\n# Only include squares of even numbers even_squares = [i ** 2 for i in range(1, 11) if i % 2 == 0] print(even_squares) # [4, 16, 36, 64, 100] List comprehensions can replace many common for-loop patterns and make your code more concise and readable.","loop-control-statements#Loop Control Statements":"Python provides several statements to control the flow of loops:\nThe break Statement The break statement exits the innermost loop prematurely:\nfor i in range(1, 10): if i == 5: break # Exit the loop when i equals 5 print(i) # Output: 1 2 3 4 The continue Statement The continue statement skips the rest of the current iteration and jumps to the next iteration:\nfor i in range(1, 10): if i % 2 == 0: continue # Skip even numbers print(i) # Output: 1 3 5 7 9 The else Clause in Loops Surprisingly, Python allows an else clause with loops. The else block executes after the loop completes normally (i.e., not via a break statement):\n# Find a number in a list numbers = [1, 3, 5, 7, 9] search_for = 5 for num in numbers: if num == search_for: print(f\"Found {search_for}!\") break else: print(f\"{search_for} is not in the list.\") # Output: Found 5! # Try searching for a number not in the list search_for = 6 for num in numbers: if num == search_for: print(f\"Found {search_for}!\") break else: print(f\"{search_for} is not in the list.\") # Output: 6 is not in the list. The else clause is useful for implementing search algorithms where you need to know whether the loop completed without finding the item.","nested-loops#Nested Loops":"You can place one loop inside another to create nested loops:\nfor i in range(1, 4): # Outer loop for j in range(1, 4): # Inner loop print(f\"({i}, {j})\", end=\" \") print() # New line after each row # Output: # (1, 1) (1, 2) (1, 3) # (2, 1) (2, 2) (2, 3) # (3, 1) (3, 2) (3, 3) Nested loops are particularly useful for working with multi-dimensional data structures:\n# Print a 2D list in a grid format matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] for row in matrix: for element in row: print(element, end=\" \") print() # New line after each row # Output: # 1 2 3 # 4 5 6 # 7 8 9 ","the-for-loop#The \u003ccode\u003efor\u003c/code\u003e Loop":"","the-while-loop#The \u003ccode\u003ewhile\u003c/code\u003e Loop":"Loops allow you to execute a block of code repeatedly. They are essential when you need to perform the same action multiple times or process collections of data. Python provides two main types of loops: for loops and while loops.\nThe for Loop The for loop in Python is designed to iterate over a sequence (like a list, tuple, dictionary, set, or string) or other iterable objects. The general syntax is:\nfor variable in iterable: # Code to execute in each iteration Let’s explore some common uses of for loops:\nIterating Over a List fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(f\"I like {fruit}s\") # Output: # I like apples # I like bananas # I like cherrys In this example, the loop variable fruit takes on each value in the fruits list, one at a time.\nIterating Over a String Strings are sequences of characters, so you can iterate over them:\nmessage = \"Hello\" for character in message: print(character) # Output: # H # e # l # l # o Using the range() Function The range() function generates a sequence of numbers, which is perfect for for loops:\n# range(stop) - generates numbers from 0 to stop-1 for i in range(5): print(i) # Output: 0 1 2 3 4 # range(start, stop) - generates numbers from start to stop-1 for i in range(2, 6): print(i) # Output: 2 3 4 5 # range(start, stop, step) - generates numbers from start to stop-1 with step for i in range(1, 10, 2): print(i) # Output: 1 3 5 7 9 The range() function is commonly used when you need to repeat an action a specific number of times or when you need the indices of a sequence.\nIterating With Index Using enumerate() If you need both the value and its position (index) in the sequence, use the enumerate() function:\nfruits = [\"apple\", \"banana\", \"cherry\"] for index, fruit in enumerate(fruits): print(f\"{index}: {fruit}\") # Output: # 0: apple # 1: banana # 2: cherry Iterating Over Dictionaries When iterating over a dictionary, the loop variable takes on the keys:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Iterating over keys (default) for key in person: print(f\"Key: {key}, Value: {person[key]}\") # Explicitly iterating over keys for key in person.keys(): print(f\"Key: {key}\") # Iterating over values for value in person.values(): print(f\"Value: {value}\") # Iterating over key-value pairs for key, value in person.items(): print(f\"Key: {key}, Value: {value}\") Important: When iterating over a dictionary, the order of items was not guaranteed before Python 3.7. Since Python 3.7, dictionaries maintain insertion order.\nThe while Loop The while loop executes a block of code as long as a specified condition is True. The general syntax is:\nwhile condition: # Code to execute in each iteration Basic while Loop count = 0 while count \u003c 5: print(f\"Count: {count}\") count += 1 # Increment count to avoid an infinite loop # Output: # Count: 0 # Count: 1 # Count: 2 # Count: 3 # Count: 4 Important: Always ensure that the condition in a while loop will eventually become False, or you’ll create an infinite loop that will run forever (or until you force the program to stop).\nUser Input Validation with while The while loop is particularly useful for validating user input:\nwhile True: response = input(\"Enter 'yes' or 'no': \").lower() if response == \"yes\" or response == \"no\": break # Exit the loop if valid input else: print(\"Invalid input. Try again.\") print(f\"You entered: {response}\") This loop continues asking for input until the user enters either “yes” or “no”.\nwhile Loop with a Counter You can use a counter variable to control how many times a loop executes:\nattempts = 0 max_attempts = 3 while attempts \u003c max_attempts: password = input(\"Enter your password: \") if password == \"secret\": print(\"Access granted!\") break else: attempts += 1 remaining = max_attempts - attempts if remaining \u003e 0: print(f\"Incorrect password. {remaining} attempts remaining.\") else: print(\"Access denied. Too many incorrect attempts.\") This example limits the user to three password attempts."},"title":"Loops (for, while)"},"/python-fundamentals/02-control-flow/03-break-and-continue/":{"data":{"":"","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"","exercises#Exercises":"Exercise 1: Write a program that prompts the user to enter positive numbers to calculate their sum. Use a loop that continues until the user enters a negative number or zero, at which point the program should stop asking for input and display the sum of all the positive numbers entered.\nExercise 2: Create a program that prints all the prime numbers between 1 and 100, but skips any prime numbers that contain the digit ‘3’ (like 3, 13, 23, etc.).\nExercise 3: Write a program that iterates through the numbers 1 to 100. For multiples of 3, print “Fizz” instead of the number. For multiples of 5, print “Buzz”. For numbers that are multiples of both 3 and 5, print “FizzBuzz”. However, if the number contains the digit 7, skip that number entirely using continue.\nExercise 4: Create a nested loop that searches for a specific pattern in a 2D list (like a word search puzzle). Once the pattern is found, use break statements appropriately to exit both loops.\nHint for Exercise 1: Use a while True loop to keep asking for input. Check if the input is negative or zero, and use break if it is. Otherwise, add the positive number to a running sum.\n# Exercise 1 solution outline sum_of_numbers = 0 while True: user_input = float(input(\"Enter a positive number (or negative/zero to stop): \")) if user_input \u003c= 0: break sum_of_numbers += user_input print(f\"The sum of all positive numbers entered is: {sum_of_numbers}\") In the next section, we’ll explore the pass statement, which provides a way to create placeholder code in Python.","practical-examples#Practical Examples":"","the-break-statement#The \u003ccode\u003ebreak\u003c/code\u003e Statement":"","the-continue-statement#The \u003ccode\u003econtinue\u003c/code\u003e Statement":"","when-to-use-break-vs-continue#When to Use \u003ccode\u003ebreak\u003c/code\u003e vs. \u003ccode\u003econtinue\u003c/code\u003e":"The break and continue statements give you precise control over loop execution. They allow you to alter the normal flow of loops based on certain conditions.\nThe break Statement The break statement immediately terminates the current loop and transfers control to the statement following the loop.\nBreaking Out of a for Loop fruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"] for fruit in fruits: if fruit == \"cherry\": print(f\"Found {fruit}! Stopping search.\") break print(f\"Checking: {fruit}\") print(\"Loop ended\") Output:\nChecking: apple Checking: banana Found cherry! Stopping search. Loop ended In this example, the loop stops when it reaches “cherry” and doesn’t process the remaining items.\nBreaking Out of a while Loop counter = 0 while True: # This creates an infinite loop counter += 1 print(f\"Count: {counter}\") if counter \u003e= 5: print(\"Breaking out of the loop\") break print(\"Loop ended\") Output:\nCount: 1 Count: 2 Count: 3 Count: 4 Count: 5 Breaking out of the loop Loop ended Here, the break statement is essential to exit what would otherwise be an infinite loop.\nUsing break with Nested Loops When using nested loops, break only exits the innermost loop:\nfor i in range(3): print(f\"Outer loop: {i}\") for j in range(3): print(f\" Inner loop: {j}\") if j == 1: print(\" Breaking inner loop\") break print(\"Outer loop continues\") Output:\nOuter loop: 0 Inner loop: 0 Inner loop: 1 Breaking inner loop Outer loop continues Outer loop: 1 Inner loop: 0 Inner loop: 1 Breaking inner loop Outer loop continues Outer loop: 2 Inner loop: 0 Inner loop: 1 Breaking inner loop Outer loop continues To break out of all loops at once, you can use a flag variable or create a function and return from it.\nThe continue Statement The continue statement skips the rest of the current iteration and jumps back to the top of the loop for the next iteration.\nSkipping Items in a for Loop numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] for number in numbers: if number % 2 == 0: # Skip even numbers continue print(f\"Processing odd number: {number}\") Output:\nProcessing odd number: 1 Processing odd number: 3 Processing odd number: 5 Processing odd number: 7 Processing odd number: 9 The continue statement skips the print statement for even numbers.\nSkipping Iterations in a while Loop counter = 0 while counter \u003c 10: counter += 1 if counter % 3 == 0: # Skip multiples of 3 continue print(f\"Processing: {counter}\") Output:\nProcessing: 1 Processing: 2 Processing: 4 Processing: 5 Processing: 7 Processing: 8 Processing: 10 Important: In a while loop, be careful not to put the counter increment after the continue statement, as it would create an infinite loop:\n# Infinite loop - WRONG! counter = 0 while counter \u003c 10: if counter % 3 == 0: continue # Returns to the condition check without incrementing print(f\"Processing: {counter}\") counter += 1 # Never reached when continue executes Practical Examples Example 1: Input Validation Loop This example uses continue to handle invalid inputs and break to exit when valid input is received:\ndef get_positive_number(): \"\"\"Prompt the user until they enter a positive number.\"\"\" while True: try: user_input = input(\"Enter a positive number: \") # Check if the user wants to exit if user_input.lower() in ['q', 'quit', 'exit']: print(\"Exiting.\") return None number = float(user_input) # Handle negative or zero input if number \u003c= 0: print(\"Please enter a positive number!\") continue # We have a valid positive number return number except ValueError: print(\"That's not a valid number! Try again.\") continue # Test the function result = get_positive_number() if result is not None: print(f\"You entered: {result}\") Example 2: Processing a File with Exceptions This example reads a file line by line, using continue to skip invalid lines:\ndef process_data_file(filename): \"\"\"Process numeric data from a file, skipping invalid lines.\"\"\" total = 0 valid_count = 0 try: with open(filename, 'r') as file: for line_number, line in enumerate(file, 1): line = line.strip() # Skip empty lines if not line: print(f\"Line {line_number}: Empty line, skipping\") continue # Skip comment lines if line.startswith('#'): print(f\"Line {line_number}: Comment, skipping\") continue try: value = float(line) total += value valid_count += 1 print(f\"Line {line_number}: Processed value {value}\") except ValueError: print(f\"Line {line_number}: Invalid number '{line}', skipping\") continue except FileNotFoundError: print(f\"Error: File '{filename}' not found.\") return None if valid_count == 0: return 0 average = total / valid_count return average # Example usage (assuming you have a file named \"data.txt\") # average = process_data_file(\"data.txt\") # if average is not None: # print(f\"Average of valid numbers: {average}\") Example 3: Finding Primes with Early Termination This example uses break to implement early termination in a primality test:\ndef is_prime(n): \"\"\" Check if a number is prime using trial division with early termination. \"\"\" if n \u003c= 1: return False if n \u003c= 3: return True # Check if n is divisible by 2 or 3 if n % 2 == 0 or n % 3 == 0: return False # Check divisibility by numbers of form 6k ± 1 up to sqrt(n) i = 5 while i * i \u003c= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start, end): \"\"\"Find all prime numbers in the given range.\"\"\" primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes # Find primes between 10 and 30 print(find_primes_in_range(10, 30)) # Output: [11, 13, 17, 19, 23, 29] Common Pitfalls and Best Practices 1. Avoiding Infinite Loops Always ensure that a while loop has a way to exit, especially when using continue:\n# Good practice - increment before continue counter = 0 while counter \u003c 5: counter += 1 if counter == 3: continue print(counter) 2. Breaking Out of Nested Loops To break out of nested loops, you can use a flag variable:\nfound = False for i in range(5): for j in range(5): if i * j == 6: print(f\"Found i={i}, j={j} where i*j=6\") found = True break if found: break Alternatively, you can wrap the nested loops in a function and use return:\ndef find_product(target): for i in range(5): for j in range(5): if i * j == target: return i, j return None result = find_product(6) if result: i, j = result print(f\"Found i={i}, j={j} where i*j=6\") else: print(\"No solution found\") 3. Don’t Overuse break and continue While these statements are powerful, overusing them can make code harder to understand:\n# Hard to follow with multiple breaks for item in items: if condition1(item): if condition2(item): break process1(item) else: if condition3(item): continue process2(item) # More readable with positive conditions for item in items: if not condition1(item): if not condition3(item): process2(item) continue if condition2(item): break process1(item) 4. Using else with Loops and break Remember that the else clause in a loop executes only if the loop completes normally (without break):\ndef check_all_positive(numbers): for num in numbers: if num \u003c= 0: print(f\"Found non-positive number: {num}\") break else: print(\"All numbers are positive\") check_all_positive([1, 2, 3, 4, 5]) # All numbers are positive check_all_positive([1, 2, -3, 4, 5]) # Found non-positive number: -3 When to Use break vs. continue Use break when:\nYou’ve found what you’re looking for An error or exceptional condition occurs that makes continuing pointless You need to exit early from a potentially expensive operation Use continue when:\nThe current item shouldn’t be processed, but you want to process the rest You want to skip to the next iteration based on a condition You need to handle invalid cases separately "},"title":"Break and Continue Statements"},"/python-fundamentals/02-control-flow/04-pass-statement/":{"data":{"":"","basic-usage#Basic Usage":"","best-practices#Best Practices":" Add Comments: When using pass, add a comment explaining why it’s there and what will eventually replace it: def complex_algorithm(): pass # TODO: Implement the sorting algorithm from research paper XYZ Temporary Usage: Use pass as a temporary placeholder during development, not as a permanent solution.\nUse with Care in Exception Handlers: Catching exceptions and doing nothing (pass) can hide bugs. Include a comment explaining why an exception is being ignored:\ntry: os.remove(filename) except FileNotFoundError: pass # File already doesn't exist, which is fine Consider Alternatives: For more complex placeholder needs, consider raising a NotImplementedError instead of using pass: def feature_coming_soon(): raise NotImplementedError(\"This feature will be available in version 2.0\") ","common-use-cases#Common Use Cases":"","exercises#Exercises":"Exercise 1: Create a class hierarchy for different shapes (Circle, Rectangle, Triangle) with a common base class Shape. Use the pass statement to create method placeholders for area() and perimeter() methods that subclasses will implement.\nExercise 2: Write a function that processes a list of numbers, but uses the pass statement to skip negative numbers. The function should return the sum of positive numbers.\nExercise 3: Create a simple state machine that transitions between states based on input. Use pass statements as placeholders for actions in each state transition that will be implemented later.\nHint for Exercise 1:\nclass Shape: def area(self): pass # Subclasses will implement this def perimeter(self): pass # Subclasses will implement this class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): import math return math.pi * self.radius ** 2 # Implement perimeter method In the next section, we’ll explore exception handling basics in Python, which allows you to gracefully handle errors and unexpected situations in your code.","pass-vs-other-statements#\u003ccode\u003epass\u003c/code\u003e vs. Other Statements":"The pass statement is a null operation in Python. When executed, nothing happens. It’s useful as a placeholder when a statement is syntactically required but you don’t want to execute any code.\nBasic Usage The pass statement allows you to create minimal classes, functions, or code blocks that do nothing:\ndef function_not_implemented_yet(): pass # Will be implemented later class EmptyClass: pass # Will add methods and attributes later if some_condition: pass # Nothing to do in this case, but code is syntactically correct else: # Do something Common Use Cases 1. Creating Placeholder Functions or Classes During development, you might want to define the structure of your program before implementing all the details:\ndef calculate_tax(income): pass # Will implement tax calculation later def save_to_database(data): pass # Will implement database functionality later def send_notification(user, message): pass # Will implement notification system later # Main function can use these functions before they're fully implemented def process_transaction(user, amount): calculate_tax(amount) save_to_database({\"user\": user, \"amount\": amount}) send_notification(user, f\"Transaction of {amount} processed\") return True 2. Creating Empty Code Blocks Python requires code blocks for control structures like loops, conditionals, and functions. The pass statement can serve as temporary content:\n# Checking for specific conditions, but not taking any action yet for user in users: if user.is_active: # Process active users process_user(user) else: # No action needed for inactive users pass 3. Abstract Base Classes When creating abstract classes that subclasses will implement:\nclass Animal: def make_sound(self): pass # Subclasses must implement this method class Dog(Animal): def make_sound(self): return \"Woof!\" class Cat(Animal): def make_sound(self): return \"Meow!\" 4. In Exception Handling When you need to catch an exception but don’t need to take any action:\ntry: potentially_problematic_function() except SomeSpecificException: pass # We're deliberately ignoring this exception Note: While using pass to ignore exceptions is possible, it’s generally better to include a comment explaining why the exception is being ignored to avoid confusion.\npass vs. Other Statements pass vs. ... (Ellipsis) In Python 3, the ellipsis (...) can sometimes be used similarly to pass:\ndef not_implemented_yet(): ... # Using ellipsis as a placeholder The ellipsis is often used in type hints and as a placeholder in code, but pass is more conventional for creating empty code blocks.\npass vs. Empty String or Comment A common mistake is trying to use an empty string or comment as a null operation:\nif condition: \"\" # This doesn't work as a null operation # This is just a comment, not a null operation Unlike these examples, pass is an actual statement that satisfies Python’s requirement for a code block to contain at least one statement.\npass vs. continue Don’t confuse pass with continue:\n# Using pass - the loop continues with the next statement for i in range(5): if i == 2: pass # Does nothing, proceeds to print print(i) # Output: 0 1 2 3 4 # Using continue - skips to the next iteration for i in range(5): if i == 2: continue # Skips the print for i=2 print(i) # Output: 0 1 3 4 ","practical-examples#Practical Examples":"Example 1: Class Hierarchy Design # Designing a class hierarchy for a game class GameObject: def update(self): pass def render(self): pass def collide(self, other_object): pass class Player(GameObject): def update(self): # Update player position based on input print(\"Updating player position\") def render(self): # Render player sprite print(\"Rendering player\") # Note: collide method is not implemented yet class Enemy(GameObject): def update(self): # Update enemy AI print(\"Updating enemy AI\") def render(self): # Render enemy sprite print(\"Rendering enemy\") def collide(self, other_object): if isinstance(other_object, Player): print(\"Enemy collided with player\") Example 2: Function Stubs for API # Creating API stubs for a web service def login(username, password): \"\"\"Authenticate a user with the service.\"\"\" pass # TODO: Implement authentication logic def get_user_data(user_id): \"\"\"Retrieve user data from the database.\"\"\" pass # TODO: Implement database query def update_profile(user_id, data): \"\"\"Update a user's profile information.\"\"\" pass # TODO: Implement update logic def delete_account(user_id): \"\"\"Delete a user account.\"\"\" pass # TODO: Implement account deletion # Main API handler def handle_request(request_type, data): if request_type == \"login\": return login(data[\"username\"], data[\"password\"]) elif request_type == \"get_user\": return get_user_data(data[\"user_id\"]) elif request_type == \"update_profile\": return update_profile(data[\"user_id\"], data[\"profile_data\"]) elif request_type == \"delete_account\": return delete_account(data[\"user_id\"]) else: raise ValueError(f\"Unknown request type: {request_type}\") Example 3: Selective Processing def process_student_data(students): \"\"\"Process student data, but skip those with incomplete records.\"\"\" for student in students: # Skip students with missing required data if not student.has_complete_data(): pass # Skip this student else: # Process student data calculate_grades(student) update_records(student) send_report(student) "},"title":"Pass Statement"},"/python-fundamentals/02-control-flow/05-exception-handling/":{"data":{"":"","best-practices-for-exception-handling#Best Practices for Exception Handling":"1. Be Specific About Which Exceptions to Catch Catch specific exceptions rather than using a broad except clause:\n# Poor practice try: # Some code except: # Catches everything! print(\"An error occurred\") # Better practice try: # Some code except (ValueError, TypeError) as e: print(f\"Input error: {e}\") except FileNotFoundError as e: print(f\"File error: {e}\") 2. Keep try Blocks Small Include only the code that might raise the exception in the try block:\n# Poor practice try: data = input(\"Enter data: \") value = int(data) result = 100 / value print(f\"Result: {result}\") except Exception as e: print(f\"Error: {e}\") # Better practice try: data = input(\"Enter data: \") value = int(data) # Only this line might raise ValueError except ValueError: print(\"Error: Please enter a valid integer.\") else: try: result = 100 / value # Only this line might raise ZeroDivisionError except ZeroDivisionError: print(\"Error: Cannot divide by zero.\") else: print(f\"Result: {result}\") 3. Clean Up Resources with finally or Context Managers Always clean up resources like file handles or database connections:\n# Using finally file = None try: file = open(\"data.txt\", \"r\") # Process the file except FileNotFoundError: print(\"File not found.\") finally: if file: file.close() # Using context manager (better approach) try: with open(\"data.txt\", \"r\") as file: # Process the file except FileNotFoundError: print(\"File not found.\") The with statement (context manager) automatically handles cleanup, which is more concise and less error-prone.\n4. Don’t Use Exceptions for Flow Control Exceptions should be used for exceptional conditions, not for regular flow control:\n# Poor practice def get_item(dictionary, key): try: return dictionary[key] except KeyError: return None # Better practice def get_item(dictionary, key): return dictionary.get(key) # Returns None if key doesn't exist 5. Log Exceptions Appropriately In production code, log exceptions with useful context information:\nimport logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) try: # Some risky operation result = perform_complex_operation(data) except Exception as e: logger.error(f\"Error processing data: {e}\", exc_info=True) # Gracefully handle the error for the user 6. Don’t Silence Exceptions Without Good Reason If you catch an exception, you should handle it meaningfully:\n# Poor practice try: process_data() except Exception: pass # Silently ignore errors # Better practice try: process_data() except Exception as e: print(f\"Failed to process data: {e}\") # Take appropriate action (retry, use fallback, inform user, etc.) 7. Create Custom Exceptions For Your Application’s Domains Custom exceptions make your code more readable and allow for more specific error handling:\nclass ConfigError(Exception): \"\"\"Base class for configuration errors.\"\"\" pass class ConfigNotFoundError(ConfigError): \"\"\"Raised when a configuration file is not found.\"\"\" pass class ConfigParseError(ConfigError): \"\"\"Raised when a configuration file cannot be parsed.\"\"\" pass def load_config(filename): if not os.path.exists(filename): raise ConfigNotFoundError(f\"Configuration file {filename} not found\") try: with open(filename, 'r') as file: data = file.read() # Parse the config return parse_config(data) except ValueError as e: raise ConfigParseError(f\"Failed to parse {filename}: {e}\") ","catching-all-exceptions#Catching All Exceptions":"","creating-custom-exceptions#Creating Custom Exceptions":"You can create your own exception types by defining a new class that inherits from Exception or one of its subclasses:\nclass InsufficientFundsError(Exception): \"\"\"Raised when a withdrawal would result in a negative balance.\"\"\" def __init__(self, balance, amount): self.balance = balance self.amount = amount self.deficit = amount - balance message = f\"Cannot withdraw ${amount}. Balance is ${balance}, resulting in a deficit of ${self.deficit}.\" super().__init__(message) class BankAccount: def __init__(self, name, balance=0): self.name = name self.balance = balance def deposit(self, amount): if amount \u003c= 0: raise ValueError(\"Deposit amount must be positive\") self.balance += amount return self.balance def withdraw(self, amount): if amount \u003c= 0: raise ValueError(\"Withdrawal amount must be positive\") if amount \u003e self.balance: raise InsufficientFundsError(self.balance, amount) self.balance -= amount return self.balance # Using the custom exception account = BankAccount(\"John\", 100) try: account.withdraw(150) except InsufficientFundsError as e: print(f\"Error: {e}\") print(f\"You need ${e.deficit} more to make this withdrawal.\") # Output: # Error: Cannot withdraw $150. Balance is $100, resulting in a deficit of $50. # You need $50 more to make this withdrawal. Custom exceptions help make your code more readable and maintainable by clearly communicating the specific error conditions that can occur in your program.\nPractical Exception Handling Examples Example 1: Safe File Operations def read_file_safely(filename): \"\"\" Safely read a file and return its contents. Returns None if the file cannot be read. \"\"\" try: with open(filename, 'r') as file: return file.read() except FileNotFoundError: print(f\"Warning: File '{filename}' not found.\") return None except PermissionError: print(f\"Warning: No permission to read '{filename}'.\") return None except Exception as e: print(f\"Unexpected error reading '{filename}': {e}\") return None # Test the function content = read_file_safely(\"config.txt\") if content is not None: print(\"File content:\", content) else: print(\"Using default configuration.\") Example 2: User Input Validation def get_integer_input(prompt, min_value=None, max_value=None): \"\"\" Get an integer input from the user within specified bounds. Continues asking until a valid integer is provided. \"\"\" while True: try: value = int(input(prompt)) if min_value is not None and value \u003c min_value: print(f\"Error: The number must be at least {min_value}.\") continue if max_value is not None and value \u003e max_value: print(f\"Error: The number must be at most {max_value}.\") continue return value except ValueError: print(\"Error: Please enter a valid integer.\") # Test the function age = get_integer_input(\"Enter your age (0-120): \", 0, 120) print(f\"Your age is: {age}\") Example 3: API Request with Timeout import requests import time def fetch_data_from_api(url, max_retries=3, timeout=5): \"\"\" Fetch data from an API with retry logic and timeout. \"\"\" retry_count = 0 while retry_count \u003c max_retries: try: response = requests.get(url, timeout=timeout) response.raise_for_status() # Raise an exception for HTTP errors return response.json() except requests.exceptions.Timeout: print(f\"Request timed out. Retrying ({retry_count + 1}/{max_retries})...\") except requests.exceptions.ConnectionError: print(f\"Connection error. Retrying ({retry_count + 1}/{max_retries})...\") except requests.exceptions.HTTPError as e: print(f\"HTTP error occurred: {e}\") if response.status_code == 404: # Not Found print(\"Resource not found. Giving up.\") return None except requests.exceptions.RequestException as e: print(f\"An error occurred: {e}\") return None retry_count += 1 time.sleep(1) # Wait before retrying print(f\"Failed after {max_retries} retries.\") return None # Example usage try: data = fetch_data_from_api(\"https://api.example.com/data\") if data: print(\"Data fetched successfully:\", data) else: print(\"Failed to fetch data.\") except Exception as e: print(f\"Unexpected error: {e}\") Example 4: Database Operations with Transactions import sqlite3 def update_user_profile(user_id, name, email): \"\"\" Update a user's profile in the database, ensuring all changes succeed or none do. \"\"\" connection = None try: connection = sqlite3.connect(\"users.db\") cursor = connection.cursor() # Start a transaction connection.execute(\"BEGIN TRANSACTION\") # Update user name cursor.execute( \"UPDATE users SET name = ? WHERE id = ?\", (name, user_id) ) # Update user email cursor.execute( \"UPDATE users SET email = ? WHERE id = ?\", (email, user_id) ) # Log the change cursor.execute( \"INSERT INTO user_activity_log (user_id, activity, timestamp) VALUES (?, ?, datetime('now'))\", (user_id, f\"Profile updated: name={name}, email={email}\") ) # Commit the transaction connection.commit() print(f\"User {user_id} profile updated successfully.\") return True except sqlite3.Error as e: # Roll back any changes if something went wrong if connection: connection.rollback() print(f\"Database error: {e}\") return False finally: # Close the connection even if an exception occurred if connection: connection.close() # Example usage success = update_user_profile(123, \"John Smith\", \"john.smith@example.com\") if not success: print(\"Please try updating your profile again later.\") ","exercises#Exercises":"Exercise 1: Write a function called safe_divide that takes two parameters and returns their division. The function should handle potential errors (like division by zero or invalid inputs) gracefully and return None if the division cannot be performed.\nExercise 2: Create a function that asks the user for a filename and tries to open and read that file. Handle all possible exceptions that might occur (file not found, permission error, etc.) with appropriate error messages.\nExercise 3: Write a program that asks the user to enter a list of numbers separated by commas, calculates their average, and handles any potential errors (like invalid input) gracefully. Your program should continue asking until it gets valid input.\nExercise 4: Create a custom exception called InvalidPasswordError that is raised when a password doesn’t meet certain criteria (e.g., minimum length, contains uppercase letters, etc.). Write a function to validate passwords that uses this custom exception.\nHint for Exercise 1:\ndef safe_divide(a, b): try: return a / b except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") return None except TypeError: print(\"Error: Both inputs must be numbers.\") return None In the next section, we’ll explore Python data structures in more detail, starting with lists and list operations.","handling-multiple-exceptions#Handling Multiple Exceptions":"","raising-exceptions#Raising Exceptions":"You can manually raise exceptions using the raise statement:\ndef validate_age(age): if not isinstance(age, int): raise TypeError(\"Age must be an integer\") if age \u003c 0: raise ValueError(\"Age cannot be negative\") if age \u003e 120: raise ValueError(\"Age unreasonably high\") return True try: validate_age(-5) except (TypeError, ValueError) as e: print(f\"Validation error: {e}\") # Output: # Validation error: Age cannot be negative Raising exceptions is useful when you want to indicate that an error or exceptional condition has occurred in your code.","re-raising-exceptions#Re-raising Exceptions":"Sometimes you might want to catch an exception, perform some action, and then re-raise the exception to let it propagate further. You can do this with a simple raise statement without arguments:\ntry: # Some code that might raise an exception number = int(input(\"Enter a number: \")) result = 100 / number except ValueError: print(\"Logging: Invalid input provided.\") raise # Re-raise the caught exception ","the-else-clause#The \u003ccode\u003eelse\u003c/code\u003e Clause":"","the-finally-clause#The \u003ccode\u003efinally\u003c/code\u003e Clause":"Exception handling is a crucial aspect of writing robust programs. It allows your code to gracefully respond to unexpected situations or errors instead of crashing. Python provides a comprehensive exception handling mechanism using try, except, else, finally, and raise statements.\nUnderstanding Exceptions An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions. When an error occurs in Python, it creates an exception object. If the exception is not handled, the program terminates with an error message.\nSome common built-in exceptions include:\nSyntaxError: Raised when there’s a syntax error in your code TypeError: Raised when an operation is performed on an inappropriate data type ValueError: Raised when a function receives an argument of the correct type but invalid value NameError: Raised when a variable is not found in the local or global scope IndexError: Raised when trying to access an index that is outside the bounds of a sequence KeyError: Raised when a dictionary key is not found FileNotFoundError: Raised when a file or directory is requested but doesn’t exist ZeroDivisionError: Raised when dividing by zero ImportError: Raised when an import statement fails Here’s how an unhandled exception looks:\n# Attempting to divide by zero x = 10 / 0 # Raises ZeroDivisionError # Output: # Traceback (most recent call last): # File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e # ZeroDivisionError: division by zero The try and except Blocks The basic structure for handling exceptions is:\ntry: # Code that might raise an exception except ExceptionType: # Code that executes if ExceptionType is raised Here’s a simple example of handling a division by zero error:\ntry: numerator = 10 denominator = 0 result = numerator / denominator print(f\"Result: {result}\") except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") # Output: # Error: Division by zero is not allowed. Handling Multiple Exceptions You can handle multiple exception types using multiple except blocks:\ntry: # Try to convert user input to an integer and divide number = int(input(\"Enter a number: \")) result = 100 / number print(f\"100 divided by {number} is {result}\") except ValueError: print(\"Error: Please enter a valid integer.\") except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") # Sample runs: # Enter a number: abc # Error: Please enter a valid integer. # Enter a number: 0 # Error: Division by zero is not allowed. # Enter a number: 5 # 100 divided by 5 is 20.0 You can also catch multiple exception types with a single except block by grouping the exception types in a tuple:\ntry: # Some code that might raise exceptions number = int(input(\"Enter a number: \")) result = 100 / number print(f\"100 divided by {number} is {result}\") except (ValueError, ZeroDivisionError): print(\"Error: Please enter a non-zero integer.\") Catching All Exceptions You can catch all exceptions using a generic except clause, but this is generally not recommended as it can mask unexpected errors:\ntry: # Some risky code result = some_function() except: # Catches any exception print(\"An error occurred.\") A better approach is to use Exception as the exception type, which catches all standard exceptions but still allows you to access the exception details:\ntry: # Some risky code number = int(input(\"Enter a number: \")) result = 100 / number except Exception as e: print(f\"An error occurred: {e}\") print(f\"Error type: {type(e).__name__}\") Important: While catching all exceptions can prevent your program from crashing, it can also hide bugs and make debugging more difficult. It’s generally better to catch specific exceptions that you anticipate and can handle appropriately.\nThe else Clause The else clause in a try/except block executes if no exceptions are raised in the try block:\ntry: number = int(input(\"Enter a number: \")) result = 100 / number except ValueError: print(\"Error: Please enter a valid integer.\") except ZeroDivisionError: print(\"Error: Division by zero is not allowed.\") else: print(f\"100 divided by {number} is {result}\") print(\"No exceptions were raised.\") The else clause is particularly useful when you want to separate the code that might raise an exception from the code that should run only if no exceptions are raised.\nThe finally Clause The finally clause contains code that always executes, regardless of whether an exception was raised or not:\ntry: file = open(\"example.txt\", \"r\") content = file.read() # Process the content except FileNotFoundError: print(\"Error: The file was not found.\") finally: # This block always executes try: file.close() print(\"File closed successfully.\") except: print(\"No file to close.\") The finally clause is essential for cleanup actions (like closing files or releasing resources) that must occur whether an exception was raised or not.","the-try-and-except-blocks#The \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003eexcept\u003c/code\u003e Blocks":"","understanding-exceptions#Understanding Exceptions":""},"title":"Exception Handling Basics"},"/python-fundamentals/03-data-structures/":{"data":{"":"Data structures are fundamental containers that allow you to store, organize, and manipulate collections of data efficiently in Python.\nMastering Python’s built-in data structures—lists, tuples, dictionaries, and sets—will dramatically improve your ability to write elegant, optimized code for any programming challenge. Each structure has unique properties and use cases, from the versatile and mutable lists to the lightning-fast lookups of dictionaries.\nUnderstanding when and how to use each data structure is a critical skill that separates novice programmers from experienced developers. Check the outline below to discover the powerful data structures Python offers and how to leverage them in your projects.\nHere is what this section covers:\n01. Lists and List Operations 02. Tuples 03. Dictionaries 04. Sets 05. String Manipulation "},"title":"Data Structures"},"/python-fundamentals/03-data-structures/01-lists/":{"data":{"":"Lists are one of the most versatile and commonly used data structures in Python. A list is an ordered, mutable collection of elements that can be of different types. This flexibility makes lists extremely useful for a wide range of programming tasks.","accessing-list-elements#Accessing List Elements":"List elements are indexed starting from 0 for the first element:\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"] # Accessing by positive index (from the beginning) first_fruit = fruits[0] # \"apple\" second_fruit = fruits[1] # \"banana\" # Accessing by negative index (from the end) last_fruit = fruits[-1] # \"elderberry\" second_last = fruits[-2] # \"date\" # Accessing nested lists matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] element = matrix[1][2] # 6 (row 1, column 2) Important: Trying to access an index that doesn’t exist will raise an IndexError. Always ensure your indices are within the valid range or use error handling.\nfruits = [\"apple\", \"banana\", \"cherry\"] try: fourth_fruit = fruits[3] # IndexError: list index out of range except IndexError as e: print(f\"Error: {e}\") ","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"Pitfall 1: Modifying a List While Iterating # Incorrect - modifying the list during iteration numbers = [1, 2, 3, 4, 5] for number in numbers: if number % 2 == 0: numbers.remove(number) # This can cause unexpected results # Correct - create a new list or iterate over a copy numbers = [1, 2, 3, 4, 5] numbers = [num for num in numbers if num % 2 != 0] # or numbers = [1, 2, 3, 4, 5] for number in numbers[:]: # Iterate over a copy if number % 2 == 0: numbers.remove(number) Pitfall 2: Shallow vs. Deep Copying # Original list with nested lists original = [1, 2, [3, 4]] # Shallow copy - nested lists are still shared shallow_copy = original.copy() # Deep copy - completely independent import copy deep_copy = copy.deepcopy(original) # Modify the nested list in the original original[2][0] = 99 print(original) # [1, 2, [99, 4]] print(shallow_copy) # [1, 2, [99, 4]] - nested list was affected print(deep_copy) # [1, 2, [3, 4]] - completely independent Pitfall 3: Lists as Default Parameters # Incorrect - the default list is created once and shared def add_to_list(item, my_list=[]): my_list.append(item) return my_list print(add_to_list(\"a\")) # [\"a\"] print(add_to_list(\"b\")) # [\"a\", \"b\"] - Not a new empty list! # Correct - use None as default and create a new list inside def add_to_list_fixed(item, my_list=None): if my_list is None: my_list = [] my_list.append(item) return my_list print(add_to_list_fixed(\"a\")) # [\"a\"] print(add_to_list_fixed(\"b\")) # [\"b\"] Best Practice 1: Use List Comprehensions for Clarity # Less readable loop squares = [] for i in range(10): if i % 2 == 0: squares.append(i ** 2) # More readable list comprehension squares = [i ** 2 for i in range(10) if i % 2 == 0] Best Practice 2: Use Appropriate Built-in Functions numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5] # Directly use built-ins for common operations total = sum(numbers) largest = max(numbers) smallest = min(numbers) exists = 5 in numbers position = numbers.index(5) Best Practice 3: Choose the Right Tool # If you need unique elements, use a set unique_numbers = list(set([3, 1, 4, 1, 5, 9, 2, 6, 5])) # If you need key-value pairs, use a dictionary country_codes = dict(zip([\"USA\", \"Canada\", \"Mexico\"], [1, 2, 3])) # If data won't change, use a tuple coordinates = (40.7128, -74.0060) ","creating-lists#Creating Lists":"There are several ways to create lists in Python:\n# Empty list empty_list = [] empty_list_alt = list() # Using the list() constructor # List with initial values fruits = [\"apple\", \"banana\", \"cherry\"] # List with mixed data types mixed_list = [1, \"hello\", 3.14, True] # Nested lists matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # Creating a list from another iterable letters = list(\"hello\") # Creates ['h', 'e', 'l', 'l', 'o'] numbers = list(range(1, 6)) # Creates [1, 2, 3, 4, 5] ","exercises#Exercises":"Exercise 1: Write a function that takes a list of numbers and returns a new list with only the even numbers. If there are no even numbers, return an empty list.\nExercise 2: Create a function called remove_duplicates that takes a list and returns a new list with all duplicate elements removed while preserving the original order. Do not use sets for this exercise (to practice list operations).\nExercise 3: Write a function called flatten_list that takes a nested list (a list that contains lists) and returns a flattened version with all elements in a single level list.\nExercise 4: Implement a function called rotate_list that takes a list and a number n. The function should rotate the list elements by n positions. If n is positive, rotate to the right, if negative, rotate to the left.\nHint for Exercise 1: Use a list comprehension with a condition to check if each number is even.\ndef get_even_numbers(numbers): return [num for num in numbers if num % 2 == 0] In the next section, we’ll explore tuples, which are similar to lists but have some important differences, particularly their immutability.","list-comprehensions#List Comprehensions":"List comprehensions provide a concise way to create lists:\n# Create a list of squares squares = [x**2 for x in range(1, 6)] print(squares) # [1, 4, 9, 16, 25] # With a condition even_squares = [x**2 for x in range(1, 11) if x % 2 == 0] print(even_squares) # [4, 16, 36, 64, 100] # With multiple conditions numbers = [x for x in range(1, 31) if x % 2 == 0 if x % 3 == 0] print(numbers) # [6, 12, 18, 24, 30] # Nested loops in comprehension pairs = [(x, y) for x in range(1, 3) for y in range(1, 3)] print(pairs) # [(1, 1), (1, 2), (2, 1), (2, 2)] # Creating a flat list from a nested list nested = [[1, 2], [3, 4], [5, 6]] flat = [item for sublist in nested for item in sublist] print(flat) # [1, 2, 3, 4, 5, 6] ","list-methods#List Methods":"Python provides many built-in methods for lists:\nFinding Elements fruits = [\"apple\", \"banana\", \"cherry\", \"banana\", \"date\"] # Check if an element exists if \"banana\" in fruits: print(\"Yes, 'banana' is in the list\") # Count occurrences banana_count = fruits.count(\"banana\") print(f\"Banana appears {banana_count} times\") # 2 # Find the index of an element (first occurrence) banana_index = fruits.index(\"banana\") print(f\"First banana is at index {banana_index}\") # 1 # Find subsequent occurrences second_banana_index = fruits.index(\"banana\", banana_index + 1) print(f\"Second banana is at index {second_banana_index}\") # 3 # To avoid errors if the element doesn't exist try: grape_index = fruits.index(\"grape\") except ValueError: print(\"Grape not found in the list\") Sorting Lists numbers = [3, 1, 4, 1, 5, 9, 2, 6] # Sort in place numbers.sort() print(numbers) # [1, 1, 2, 3, 4, 5, 6, 9] # Sort in descending order numbers.sort(reverse=True) print(numbers) # [9, 6, 5, 4, 3, 2, 1, 1] # Create a new sorted list without modifying the original original = [3, 1, 4, 1, 5, 9, 2, 6] sorted_numbers = sorted(original) print(sorted_numbers) # [1, 1, 2, 3, 4, 5, 6, 9] print(original) # [3, 1, 4, 1, 5, 9, 2, 6] (unchanged) # Sort strings (alphabetically) fruits = [\"banana\", \"cherry\", \"apple\", \"date\"] fruits.sort() print(fruits) # [\"apple\", \"banana\", \"cherry\", \"date\"] # Custom sorting with key parameter students = [ {\"name\": \"Alice\", \"grade\": 88}, {\"name\": \"Bob\", \"grade\": 75}, {\"name\": \"Charlie\", \"grade\": 93} ] # Sort by grade students.sort(key=lambda student: student[\"grade\"]) print([student[\"name\"] for student in students]) # [\"Bob\", \"Alice\", \"Charlie\"] Other Useful Methods # Reverse the list in place fruits = [\"apple\", \"banana\", \"cherry\"] fruits.reverse() print(fruits) # [\"cherry\", \"banana\", \"apple\"] # Copy a list fruits = [\"apple\", \"banana\", \"cherry\"] fruits_copy = fruits.copy() # or list(fruits) or fruits[:] fruits_copy.append(\"date\") print(fruits) # [\"apple\", \"banana\", \"cherry\"] print(fruits_copy) # [\"apple\", \"banana\", \"cherry\", \"date\"] ","list-slicing#List Slicing":"Slicing allows you to extract a portion of a list:\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"] # Syntax: list[start:stop:step] # start: inclusive, stop: exclusive, step: increment (default 1) # Get a slice from index 1 to 3 (exclusive) slice1 = fruits[1:3] # [\"banana\", \"cherry\"] # Omitting start means start from the beginning slice2 = fruits[:3] # [\"apple\", \"banana\", \"cherry\"] # Omitting stop means go to the end slice3 = fruits[2:] # [\"cherry\", \"date\", \"elderberry\"] # Negative indices in slices slice4 = fruits[-3:-1] # [\"cherry\", \"date\"] # Using step to get every 2nd element slice5 = fruits[::2] # [\"apple\", \"cherry\", \"elderberry\"] # Reverse a list reversed_fruits = fruits[::-1] # [\"elderberry\", \"date\", \"cherry\", \"banana\", \"apple\"] Note: Slicing creates a new list, so the original list remains unchanged.","lists-vs-other-data-structures#Lists vs. Other Data Structures":"Understanding when to use lists versus other data structures is important:\nData Structure Ordered Mutable Duplicates Use Case List Yes Yes Yes General purpose, when order matters and items might change Tuple Yes No Yes Immutable sequences, like coordinates or database records Set No Yes No When you need unique items or set operations Dictionary Yes* Yes No (keys) Key-value mapping, like a phone book *Dictionaries maintained insertion order starting in Python 3.7\n# Example: Converting between data structures numbers_list = [1, 2, 3, 2, 1, 4] numbers_tuple = tuple(numbers_list) # (1, 2, 3, 2, 1, 4) numbers_set = set(numbers_list) # {1, 2, 3, 4} numbers_dict = {i: numbers_list[i] for i in range(len(numbers_list))} # {0: 1, 1: 2, 2: 3, 3: 2, 4: 1, 5: 4} Practical Examples Example 1: Todo List Manager def todo_list_manager(): \"\"\"A simple todo list manager using lists.\"\"\" todos = [] while True: print(\"\\nTodo List Manager\") print(\"1. Add task\") print(\"2. View tasks\") print(\"3. Mark task as done\") print(\"4. Remove task\") print(\"5. Exit\") choice = input(\"Enter your choice (1-5): \") if choice == \"1\": task = input(\"Enter a new task: \") todos.append({\"task\": task, \"done\": False}) print(f\"Task '{task}' added.\") elif choice == \"2\": if not todos: print(\"No tasks in the list.\") else: print(\"\\nYour Tasks:\") for i, item in enumerate(todos): status = \"✓\" if item[\"done\"] else \" \" print(f\"{i+1}. [{status}] {item['task']}\") elif choice == \"3\": if not todos: print(\"No tasks to mark as done.\") else: try: task_num = int(input(\"Enter task number to mark as done: \")) - 1 if 0 \u003c= task_num \u003c len(todos): todos[task_num][\"done\"] = True print(f\"Task '{todos[task_num]['task']}' marked as done.\") else: print(\"Invalid task number.\") except ValueError: print(\"Please enter a valid number.\") elif choice == \"4\": if not todos: print(\"No tasks to remove.\") else: try: task_num = int(input(\"Enter task number to remove: \")) - 1 if 0 \u003c= task_num \u003c len(todos): removed_task = todos.pop(task_num) print(f\"Task '{removed_task['task']}' removed.\") else: print(\"Invalid task number.\") except ValueError: print(\"Please enter a valid number.\") elif choice == \"5\": print(\"Goodbye!\") break else: print(\"Invalid choice. Please enter a number between 1 and 5.\") # Uncomment to run the todo list manager # todo_list_manager() Example 2: Basic Data Analysis def analyze_temperatures(daily_temperatures): \"\"\" Analyze a list of daily temperatures and return statistics. Args: daily_temperatures: A list of daily temperature readings Returns: A dictionary containing various statistics \"\"\" if not daily_temperatures: return {\"error\": \"No temperature data provided\"} # Calculate statistics average_temp = sum(daily_temperatures) / len(daily_temperatures) min_temp = min(daily_temperatures) max_temp = max(daily_temperatures) # Find temperature range temp_range = max_temp - min_temp # Count days above average days_above_avg = sum(1 for temp in daily_temperatures if temp \u003e average_temp) # Temperature trend (increasing or decreasing) increasing_days = 0 for i in range(1, len(daily_temperatures)): if daily_temperatures[i] \u003e daily_temperatures[i-1]: increasing_days += 1 trend_percentage = (increasing_days / (len(daily_temperatures) - 1)) * 100 trend = \"Increasing\" if trend_percentage \u003e 50 else \"Decreasing\" return { \"average\": round(average_temp, 1), \"minimum\": min_temp, \"maximum\": max_temp, \"range\": temp_range, \"days_above_average\": days_above_avg, \"trend\": trend } # Sample usage temperatures = [68, 71, 70, 75, 74, 72, 77, 78, 74] analysis = analyze_temperatures(temperatures) print(\"Temperature Analysis:\") for key, value in analysis.items(): print(f\"{key.replace('_', ' ').title()}: {value}\") Example 3: Matrix Operations def print_matrix(matrix): \"\"\"Print a matrix in a readable format.\"\"\" for row in matrix: print(\" \".join(str(element) for element in row)) def matrix_addition(matrix_a, matrix_b): \"\"\"Add two matrices of the same dimensions.\"\"\" if len(matrix_a) != len(matrix_b) or len(matrix_a[0]) != len(matrix_b[0]): raise ValueError(\"Matrices must have the same dimensions\") result = [] for i in range(len(matrix_a)): row = [] for j in range(len(matrix_a[0])): row.append(matrix_a[i][j] + matrix_b[i][j]) result.append(row) return result def matrix_transpose(matrix): \"\"\"Calculate the transpose of a matrix.\"\"\" # Initialize result matrix with zeros rows = len(matrix) cols = len(matrix[0]) result = [[0 for _ in range(rows)] for _ in range(cols)] # Fill in transposed values for i in range(rows): for j in range(cols): result[j][i] = matrix[i][j] return result # Example matrices matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8, 9], [10, 11, 12] ] print(\"Matrix A:\") print_matrix(matrix_a) print(\"\\nMatrix B:\") print_matrix(matrix_b) print(\"\\nMatrix A + B:\") sum_matrix = matrix_addition(matrix_a, matrix_b) print_matrix(sum_matrix) print(\"\\nTranspose of Matrix A:\") transpose_a = matrix_transpose(matrix_a) print_matrix(transpose_a) Common List Operations and Their Time Complexity Understanding the time complexity of list operations helps you write more efficient code:\nOperation Example Time Complexity Description Indexing lst[i] O(1) Access an element by index Assignment lst[i] = x O(1) Assign a value to an index Append lst.append(x) O(1) Add an element to the end Pop (end) lst.pop() O(1) Remove the last element Pop (middle) lst.pop(i) O(n) Remove element at index i Insert lst.insert(i, x) O(n) Insert element at index i Delete del lst[i] O(n) Delete element at index i Remove lst.remove(x) O(n) Remove first occurrence of x Containment x in lst O(n) Check if x is in the list Iteration for x in lst O(n) Iterate through list Get Length len(lst) O(1) Get number of elements Slicing lst[a:b] O(b-a) Get a slice of the list Extend lst.extend(lst2) O(len(lst2)) Add all elements of lst2 Sort lst.sort() O(n log n) Sort the list in place Multiply lst * n O(n*len(lst)) Create a list with n copies Note: Some operations that seem simple can be inefficient for large lists. For example, repeatedly appending to a list is efficient, but repeatedly inserting at the beginning is not, as it requires shifting all other elements.\nCommon Patterns and Techniques Pattern 1: Filtering # Filter even numbers numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] even_numbers = [num for num in numbers if num % 2 == 0] print(even_numbers) # [2, 4, 6, 8, 10] # Filter with a function def is_premium_member(customer): return customer[\"membership\"] == \"premium\" customers = [ {\"name\": \"Alice\", \"membership\": \"premium\"}, {\"name\": \"Bob\", \"membership\": \"standard\"}, {\"name\": \"Charlie\", \"membership\": \"premium\"} ] premium_customers = list(filter(is_premium_member, customers)) print([customer[\"name\"] for customer in premium_customers]) # [\"Alice\", \"Charlie\"] Pattern 2: Mapping # Transform each element numbers = [1, 2, 3, 4, 5] squared = [num ** 2 for num in numbers] print(squared) # [1, 4, 9, 16, 25] # Map with a function def celsius_to_fahrenheit(celsius): return (celsius * 9/5) + 32 celsius_temps = [0, 10, 20, 30, 40] fahrenheit_temps = list(map(celsius_to_fahrenheit, celsius_temps)) print(fahrenheit_temps) # [32.0, 50.0, 68.0, 86.0, 104.0] Pattern 3: Finding Items def find_first(items, predicate): \"\"\"Find the first item that matches the predicate.\"\"\" for item in items: if predicate(item): return item return None numbers = [1, 3, 5, 8, 10, 12] first_even = find_first(numbers, lambda x: x % 2 == 0) print(first_even) # 8 # Using next() and generator expressions first_even_alt = next((x for x in numbers if x % 2 == 0), None) print(first_even_alt) # 8 Pattern 4: Grouping def group_by_category(items, key_func): \"\"\"Group items by a category determined by key_func.\"\"\" result = {} for item in items: key = key_func(item) if key not in result: result[key] = [] result[key].append(item) return result products = [ {\"name\": \"Apples\", \"category\": \"Fruit\", \"price\": 1.50}, {\"name\": \"Bread\", \"category\": \"Bakery\", \"price\": 2.50}, {\"name\": \"Carrots\", \"category\": \"Vegetable\", \"price\": 1.00}, {\"name\": \"Bananas\", \"category\": \"Fruit\", \"price\": 0.75} ] # Group by category grouped = group_by_category(products, lambda x: x[\"category\"]) for category, items in grouped.items(): print(f\"{category}: {[item['name'] for item in items]}\") Pattern 5: Zipping Lists names = [\"Alice\", \"Bob\", \"Charlie\"] ages = [25, 30, 35] occupations = [\"Engineer\", \"Doctor\", \"Teacher\"] # Combine related data from multiple lists people = list(zip(names, ages, occupations)) print(people) # [(\"Alice\", 25, \"Engineer\"), (\"Bob\", 30, \"Doctor\"), (\"Charlie\", 35, \"Teacher\")] # Create a list of dictionaries people_dicts = [{\"name\": n, \"age\": a, \"occupation\": o} for n, a, o in zip(names, ages, occupations)] print(people_dicts) ","modifying-lists#Modifying Lists":"Lists are mutable, meaning you can change their content:\nChanging Individual Elements fruits = [\"apple\", \"banana\", \"cherry\"] # Change the second element fruits[1] = \"blueberry\" print(fruits) # [\"apple\", \"blueberry\", \"cherry\"] # Change a slice fruits[0:2] = [\"avocado\", \"blackberry\"] print(fruits) # [\"avocado\", \"blackberry\", \"cherry\"] # Insert multiple elements in place of one fruits[1:2] = [\"boysenberry\", \"blackcurrant\"] print(fruits) # [\"avocado\", \"boysenberry\", \"blackcurrant\", \"cherry\"] # Remove elements by assigning an empty list fruits[1:3] = [] print(fruits) # [\"avocado\", \"cherry\"] Adding Elements fruits = [\"apple\", \"banana\"] # Append adds a single element to the end fruits.append(\"cherry\") print(fruits) # [\"apple\", \"banana\", \"cherry\"] # Insert adds an element at a specific position fruits.insert(1, \"blueberry\") # Insert at index 1 print(fruits) # [\"apple\", \"blueberry\", \"banana\", \"cherry\"] # Extend adds multiple elements from another iterable more_fruits = [\"date\", \"elderberry\"] fruits.extend(more_fruits) print(fruits) # [\"apple\", \"blueberry\", \"banana\", \"cherry\", \"date\", \"elderberry\"] # Concatenation with + operator (creates a new list) fruits = [\"apple\", \"banana\"] more_fruits = [\"cherry\", \"date\"] all_fruits = fruits + more_fruits print(all_fruits) # [\"apple\", \"banana\", \"cherry\", \"date\"] Important: The append() method adds the entire object as a single element, while extend() adds each element of the iterable individually:\nlist1 = [1, 2, 3] list2 = [4, 5] # Using append list1.append(list2) print(list1) # [1, 2, 3, [4, 5]] # Using extend list1 = [1, 2, 3] # Reset list1 list1.extend(list2) print(list1) # [1, 2, 3, 4, 5] Removing Elements fruits = [\"apple\", \"banana\", \"cherry\", \"banana\", \"date\"] # Remove by value (first occurrence) fruits.remove(\"banana\") print(fruits) # [\"apple\", \"cherry\", \"banana\", \"date\"] # Remove by index and get the value removed_fruit = fruits.pop(1) # Removes item at index 1 print(removed_fruit) # \"cherry\" print(fruits) # [\"apple\", \"banana\", \"date\"] # Remove the last item if no index is specified last_fruit = fruits.pop() print(last_fruit) # \"date\" print(fruits) # [\"apple\", \"banana\"] # Clear all elements fruits.clear() print(fruits) # [] # Delete list items or the entire list with del fruits = [\"apple\", \"banana\", \"cherry\"] del fruits[1] print(fruits) # [\"apple\", \"cherry\"] del fruits # Deletes the entire list # print(fruits) # NameError: name 'fruits' is not defined "},"title":"Lists and List Operations"},"/python-fundamentals/03-data-structures/02-tuples/":{"data":{"":"A tuple is an ordered, immutable collection of elements in Python. Tuples are similar to lists but with one critical difference: once a tuple is created, you cannot modify its elements. This immutability makes tuples useful for representing fixed collections of items.","accessing-tuple-elements#Accessing Tuple Elements":"You can access tuple elements using indexing, just like with lists:\ncoordinates = (10, 20, 30, 40) # Accessing elements first_element = coordinates[0] # 10 last_element = coordinates[-1] # 40 # Slicing first_two = coordinates[0:2] # (10, 20) ","common-pitfalls-and-tips#Common Pitfalls and Tips":"1. Single-Item Tuple Remember to include a trailing comma when creating a tuple with one element:\n# Wrong single_item = (42) # This is an integer, not a tuple # Correct single_item = (42,) # This is a tuple with one element 2. Tuple Modification You cannot modify a tuple after creation, but you can create a new tuple based on an existing one:\ncoordinates = (10, 20, 30) # Can't do this: # coordinates[0] = 100 # But can do this: coordinates = (100,) + coordinates[1:] print(coordinates) # (100, 20, 30) 3. Performance Considerations For very large collections that don’t need to be modified, tuples can be more memory-efficient than lists:\nimport sys # Compare memory usage list_ex = [0, 1, 2, 3, 4, 5] tuple_ex = (0, 1, 2, 3, 4, 5) print(f\"List size: {sys.getsizeof(list_ex)} bytes\") print(f\"Tuple size: {sys.getsizeof(tuple_ex)} bytes\") 4. Tuple Hashability Because tuples are immutable, they can be used as dictionary keys or set elements (as long as they don’t contain mutable objects):\n# This works point_data = { (0, 0): \"Origin\", (1, 0): \"X-axis unit point\", (0, 1): \"Y-axis unit point\" } # This won't work - list is mutable try: bad_keys = {[0, 0]: \"Origin\"} except TypeError as e: print(f\"Error: {e}\") # Error: unhashable type: 'list' # This won't work - tuple contains a mutable object (list) try: bad_tuple_key = {(0, [1, 2]): \"Contains a list\"} except TypeError as e: print(f\"Error: {e}\") # Error: unhashable type: 'list' ","converting-between-tuples-and-lists#Converting Between Tuples and Lists":"You can convert between tuples and lists using the tuple() and list() functions:\n# List to tuple my_list = [1, 2, 3, 4] my_tuple = tuple(my_list) print(my_tuple) # (1, 2, 3, 4) # Tuple to list my_tuple = (5, 6, 7, 8) my_list = list(my_tuple) print(my_list) # [5, 6, 7, 8] ","creating-tuples#Creating Tuples":"There are several ways to create tuples in Python:\n# Creating a tuple using parentheses coordinates = (10, 20) # Creating a tuple without parentheses (tuple packing) person = \"John\", 30, \"New York\" # Creating a tuple with a single element (note the trailing comma) single_item_tuple = (42,) # Without the comma, this would be an integer # Creating an empty tuple empty_tuple = () # Using the tuple() constructor converted_tuple = tuple([1, 2, 3]) # Convert a list to a tuple Important: When creating a tuple with a single element, you must include a trailing comma, or Python will interpret it as a regular value inside parentheses.\n# This is NOT a tuple - it's just an integer in parentheses not_a_tuple = (42) print(type(not_a_tuple)) # \u003cclass 'int'\u003e # This IS a tuple single_item_tuple = (42,) print(type(single_item_tuple)) # \u003cclass 'tuple'\u003e ","exercises#Exercises":"Exercise 1: Create a function that takes two points represented as tuples (x, y) and returns the distance between them using the Pythagorean theorem.\nExercise 2: Create a function that converts a date represented as a tuple (year, month, day) to a formatted string. For example, (2023, 5, 15) should return “May 15, 2023”.\nExercise 3: Create a program that manages a small phone book using tuples. Each contact should be stored as a tuple containing name, phone number, and email. Implement functions to add a contact, search for a contact by name, and display all contacts.\nExercise 4: Create a function that takes a list of tuples representing (student_name, score) and returns the name of the student with the highest score.\nHint for Exercise 1: The Pythagorean theorem states that in a right triangle, the square of the length of the hypotenuse equals the sum of the squares of the other two sides. For two points (x1, y1) and (x2, y2), the distance is:\ndistance = sqrt((x2 - x1)² + (y2 - y1)²) In the next section, we’ll explore dictionaries, another powerful data structure in Python.","named-tuples#Named Tuples":"The collections module provides a namedtuple factory function to create tuple subclasses with named fields:\nfrom collections import namedtuple # Define a named tuple class Point = namedtuple('Point', ['x', 'y']) # Create instances p1 = Point(10, 20) p2 = Point(30, 40) # Access by name print(f\"p1.x = {p1.x}, p1.y = {p1.y}\") # p1.x = 10, p1.y = 20 # Access by index print(f\"p2[0] = {p2[0]}, p2[1] = {p2[1]}\") # p2[0] = 30, p2[1] = 40 # Convert to dictionary p1_dict = p1._asdict() print(p1_dict) # {'x': 10, 'y': 20} Named tuples offer a convenient way to define simple classes with field names, making code more readable.","practical-examples#Practical Examples":"Example 1: Representing RGB Colors def rgb_to_hex(rgb_tuple): \"\"\"Convert RGB values to hex color code.\"\"\" r, g, b = rgb_tuple # Validate RGB values (0-255) for value in (r, g, b): if not (0 \u003c= value \u003c= 255): raise ValueError(\"RGB values must be between 0 and 255\") # Convert to hex return f\"#{r:02x}{g:02x}{b:02x}\" # Define some common colors as tuples red = (255, 0, 0) green = (0, 255, 0) blue = (0, 0, 255) white = (255, 255, 255) black = (0, 0, 0) # Convert to hex print(f\"Red: {rgb_to_hex(red)}\") # Red: #ff0000 print(f\"Green: {rgb_to_hex(green)}\") # Green: #00ff00 print(f\"Blue: {rgb_to_hex(blue)}\") # Blue: #0000ff Example 2: Returning Multiple Values from Functions def calculate_statistics(numbers): \"\"\"Calculate basic statistics for a list of numbers.\"\"\" if not numbers: return (0, 0, 0, 0) # Empty list count = len(numbers) total = sum(numbers) minimum = min(numbers) maximum = max(numbers) # Return multiple values as a tuple return (count, total / count, minimum, maximum) # Test the function data = [4, 7, 2, 9, 3, 5, 8] count, average, minimum, maximum = calculate_statistics(data) print(f\"Count: {count}\") # Count: 7 print(f\"Average: {average}\") # Average: 5.428571428571429 print(f\"Minimum: {minimum}\") # Minimum: 2 print(f\"Maximum: {maximum}\") # Maximum: 9 Example 3: Immutable Database Records def get_employees(): \"\"\"Return employee data as tuples.\"\"\" employees = [ (1001, \"John Smith\", \"Sales\", 55000), (1002, \"Mary Johnson\", \"Engineering\", 78000), (1003, \"James Brown\", \"Marketing\", 62000), (1004, \"Patricia Davis\", \"HR\", 51000), (1005, \"Robert Wilson\", \"Engineering\", 85000), ] return employees def find_employee_by_id(employees, employee_id): \"\"\"Find an employee by their ID.\"\"\" for employee in employees: if employee[0] == employee_id: return employee return None def get_department_stats(employees, department): \"\"\"Calculate average salary and count for a department.\"\"\" count = 0 total_salary = 0 for employee in employees: if employee[2] == department: count += 1 total_salary += employee[3] if count == 0: return (0, 0) return (count, total_salary / count) # Get employee data employees = get_employees() # Find an employee employee = find_employee_by_id(employees, 1003) if employee: employee_id, name, department, salary = employee print(f\"Employee: {name}, Department: {department}, Salary: ${salary}\") # Get department statistics engineering_stats = get_department_stats(employees, \"Engineering\") print(f\"Engineering department: {engineering_stats[0]} employees, Average salary: ${engineering_stats[1]:.2f}\") Note: While this example demonstrates using tuples for records, in a real application, you might prefer named tuples or classes for better readability and maintainability.\nExample 4: Coordinate System with Named Tuples from collections import namedtuple import math # Define Point named tuple Point = namedtuple('Point', ['x', 'y']) def distance(p1, p2): \"\"\"Calculate Euclidean distance between two points.\"\"\" return math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2) def midpoint(p1, p2): \"\"\"Calculate the midpoint between two points.\"\"\" mid_x = (p1.x + p2.x) / 2 mid_y = (p1.y + p2.y) / 2 return Point(mid_x, mid_y) # Create some points origin = Point(0, 0) p1 = Point(3, 4) p2 = Point(6, 8) # Calculate distances print(f\"Distance from origin to p1: {distance(origin, p1)}\") # 5.0 print(f\"Distance from p1 to p2: {distance(p1, p2)}\") # 5.0 # Calculate midpoint mid = midpoint(p1, p2) print(f\"Midpoint of p1 and p2: ({mid.x}, {mid.y})\") # (4.5, 6.0) ","tuple-immutability#Tuple Immutability":"Once a tuple is created, you cannot modify its elements:\ncoordinates = (10, 20, 30) # This will raise a TypeError try: coordinates[0] = 100 except TypeError as e: print(f\"Error: {e}\") # Error: 'tuple' object does not support item assignment However, if a tuple contains mutable objects like lists, the objects themselves can be modified:\nstudent = (\"Alice\", [85, 90, 78]) # Can't modify the student's name # student[0] = \"Bob\" # This would raise TypeError # Can modify the list of scores student[1].append(92) print(student) # ('Alice', [85, 90, 78, 92]) ","tuple-methods#Tuple Methods":"Tuples have only two built-in methods:\n1. count() Returns the number of occurrences of a value:\nnumbers = (1, 2, 3, 2, 4, 2, 5) count_of_2 = numbers.count(2) print(count_of_2) # 3 2. index() Returns the first index where a value appears:\nfruits = (\"apple\", \"banana\", \"cherry\", \"banana\", \"date\") banana_index = fruits.index(\"banana\") print(banana_index) # 1 (first occurrence) # You can specify a start index to search from second_banana = fruits.index(\"banana\", 2) print(second_banana) # 3 (second occurrence) # If the element is not found, ValueError is raised try: fruits.index(\"grape\") except ValueError as e: print(f\"Error: {e}\") # Error: tuple.index(x): x not in tuple ","tuple-operations#Tuple Operations":"1. Concatenation You can concatenate tuples using the + operator:\ntuple1 = (1, 2, 3) tuple2 = (4, 5, 6) combined = tuple1 + tuple2 print(combined) # (1, 2, 3, 4, 5, 6) 2. Repetition You can repeat a tuple using the * operator:\nrepeated = (1, 2) * 3 print(repeated) # (1, 2, 1, 2, 1, 2) 3. Membership Testing You can check if an element exists in a tuple using the in operator:\nnumbers = (1, 2, 3, 4, 5) print(3 in numbers) # True print(6 in numbers) # False 4. Finding Length You can find the length of a tuple using the len() function:\ncoordinates = (10, 20, 30, 40) print(len(coordinates)) # 4 ","tuple-unpacking#Tuple Unpacking":"Tuple unpacking is a powerful feature that allows you to assign tuple elements to individual variables:\n# Basic unpacking coordinates = (10, 20) x, y = coordinates print(f\"x = {x}, y = {y}\") # x = 10, y = 20 # Unpacking with more elements person = (\"John\", 30, \"New York\", \"Engineer\") name, age, city, occupation = person print(f\"{name} is a {age}-year-old {occupation} living in {city}\") # Using _ for values you don't need name, age, _, occupation = person # Ignoring the city print(f\"{name} is a {age}-year-old {occupation}\") You can use the * operator to capture multiple elements in a list:\nnumbers = (1, 2, 3, 4, 5) # Assign first and last elements to variables, middle elements to a list first, *middle, last = numbers print(f\"First: {first}\") # First: 1 print(f\"Middle: {middle}\") # Middle: [2, 3, 4] print(f\"Last: {last}\") # Last: 5 # Assign first elements to variables, remaining to a list first, second, *rest = numbers print(f\"First: {first}\") # First: 1 print(f\"Second: {second}\") # Second: 2 print(f\"Rest: {rest}\") # Rest: [3, 4, 5] ","tuples-vs-lists#Tuples vs. Lists":"Understanding when to use tuples versus lists is important:\nFeature Tuple List Mutability Immutable Mutable Syntax Parentheses: (1, 2, 3) Square brackets: [1, 2, 3] Use case Fixed collections of items Collections that may change Performance Slightly faster access Slightly slower due to mutability Memory usage Slightly more efficient Slightly less efficient Dictionary keys Can be used as dict keys Cannot be used as dict keys Built-in methods Limited (2 methods) Extensive (many methods) # When to use a tuple: coordinates = (40.7128, -74.0060) # Fixed data point days = (\"Monday\", \"Tuesday\", \"Wednesday\") # Fixed collection # When to use a list: scores = [85, 90, 78] # Might need to add more scores later tasks = [\"Buy groceries\", \"Do laundry\"] # Might add or remove tasks ","when-to-use-tuples#When to Use Tuples":"Tuples are ideal for:\nRepresenting fixed collections that shouldn’t change:\ndays_of_week = (\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\") Returning multiple values from a function:\ndef get_dimensions(): return (1920, 1080) # width, height width, height = get_dimensions() Using as dictionary keys:\n# Tuples can be used as dictionary keys because they're immutable locations = { (40.7128, -74.0060): \"New York\", (34.0522, -118.2437): \"Los Angeles\", (41.8781, -87.6298): \"Chicago\" } # Looking up a location print(locations[(40.7128, -74.0060)]) # New York Data integrity:\n# When you want to ensure the data doesn't change def process_settings(settings): # settings is a tuple, so it can't be modified print(f\"Processing settings: {settings}\") process_settings((800, 600, \"high\", True)) "},"title":"Tuples"},"/python-fundamentals/03-data-structures/03-dictionaries/":{"data":{"":"Dictionaries are one of Python’s most powerful data structures. They store data as key-value pairs, allowing you to quickly retrieve, add, modify, and delete values using their associated keys.","accessing-dictionary-values#Accessing Dictionary Values":"You can access values in a dictionary using their keys:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Using square bracket notation print(person[\"name\"]) # Output: John # Using the get() method print(person.get(\"age\")) # Output: 30 # The get() method allows you to specify a default value print(person.get(\"email\", \"Not available\")) # Output: Not available Note: If you try to access a key that doesn’t exist using square brackets (person[\"email\"]), Python will raise a KeyError. The get() method is safer as it returns None (or a specified default value) instead of raising an error.","creating-dictionaries#Creating Dictionaries":"There are several ways to create a dictionary in Python:\n# Empty dictionary empty_dict = {} also_empty = dict() # Dictionary with initial values person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Using the dict() constructor person = dict(name=\"John\", age=30, city=\"New York\") # Creating a dictionary from a list of tuples items = [(\"name\", \"John\"), (\"age\", 30), (\"city\", \"New York\")] person = dict(items) ","dictionary-best-practices#Dictionary Best Practices":"1. Use get() for Safe Key Access # Using square brackets can raise KeyError user = {\"name\": \"John\"} try: email = user[\"email\"] # KeyError if key doesn't exist except KeyError: email = \"No email found\" # Better approach with get() email = user.get(\"email\", \"No email found\") 2. Use Dictionary Comprehensions for Simple Transformations # Traditional approach prices = {\"apple\": 0.5, \"banana\": 0.25, \"orange\": 0.75} sale_prices = {} for item, price in prices.items(): sale_prices[item] = price * 0.8 # Cleaner with dict comprehension sale_prices = {item: price * 0.8 for item, price in prices.items()} 3. Use defaultdict for Automatic Default Values from collections import defaultdict # Regular dictionary requires checking if key exists word_counts = {} for word in words: if word not in word_counts: word_counts[word] = 0 word_counts[word] += 1 # With defaultdict word_counts = defaultdict(int) # Default value is 0 for int for word in words: word_counts[word] += 1 4. Use collections.Counter for Counting from collections import Counter # Manual counting word_counts = {} for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 # Using Counter word_counts = Counter(words) # Counter has additional methods most_common = word_counts.most_common(3) # Get 3 most common words 5. Create Immutable Dictionary with types.MappingProxyType from types import MappingProxyType original = {\"name\": \"John\", \"age\": 30} # Create a read-only view read_only = MappingProxyType(original) # This fails with TypeError try: read_only[\"age\"] = 31 except TypeError as e: print(f\"Error: {e}\") # But the original dictionary can still be modified original[\"age\"] = 31 print(read_only[\"age\"]) # Reflects changes to original 6. Use OrderedDict When Order Matters (pre-Python 3.7) from collections import OrderedDict # Regular dictionaries in Python 3.7+ preserve insertion order regular_dict = {} regular_dict[\"first\"] = 1 regular_dict[\"second\"] = 2 regular_dict[\"third\"] = 3 # OrderedDict provides additional functionality ordered = OrderedDict() ordered[\"first\"] = 1 ordered[\"second\"] = 2 ordered[\"third\"] = 3 # Move an item to the end ordered.move_to_end(\"first\") print(list(ordered.items())) # Output: [('second', 2), ('third', 3), ('first', 1)] # Get the first/last item first_key = next(iter(ordered)) last_key = next(reversed(ordered)) ","dictionary-iteration-patterns#Dictionary Iteration Patterns":"There are several common patterns for iterating through dictionaries:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\", \"email\": \"john@example.com\" } # Iterating through keys (default) for key in person: print(f\"Key: {key}\") # Explicitly iterating through keys for key in person.keys(): print(f\"Key: {key}\") # Iterating through values for value in person.values(): print(f\"Value: {value}\") # Iterating through key-value pairs for key, value in person.items(): print(f\"{key}: {value}\") # Sorting a dictionary by keys during iteration for key in sorted(person.keys()): print(f\"{key}: {person[key]}\") # Sorting a dictionary by values during iteration for key, value in sorted(person.items(), key=lambda item: item[1]): print(f\"{key}: {value}\") ","dictionary-keys-and-values#Dictionary Keys and Values":"In Python dictionaries:\nKeys must be immutable (strings, numbers, tuples, etc.) Values can be any data type (strings, numbers, lists, other dictionaries, etc.) Each key must be unique within a dictionary # Valid keys valid_dict = { \"string_key\": \"value1\", 42: \"value2\", (1, 2): \"value3\", True: \"value4\" } # Invalid key (will raise TypeError) try: invalid_dict = { [\"list\", \"key\"]: \"value\" # Lists are mutable, so they can't be keys } except TypeError as e: print(f\"Error: {e}\") Important: While tuple keys are allowed because tuples are immutable, be cautious if the tuple contains mutable objects like lists. The tuple itself must be immutable in all of its contents.","dictionary-methods#Dictionary Methods":"Python dictionaries come with many useful methods:\nKeys, Values, and Items person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Get all keys keys = person.keys() print(keys) # Output: dict_keys(['name', 'age', 'city']) # Get all values values = person.values() print(values) # Output: dict_values(['John', 30, 'New York']) # Get all key-value pairs as tuples items = person.items() print(items) # Output: dict_items([('name', 'John'), ('age', 30), ('city', 'New York')]) Note: The objects returned by keys(), values(), and items() are view objects that provide a dynamic view of the dictionary’s entries. If the dictionary changes, these views reflect those changes.\nCopying Dictionaries person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Shallow copy person_copy = person.copy() person_copy[\"name\"] = \"Jane\" # This won't affect the original # Alternative shallow copy person_copy2 = dict(person) print(person) # Original unchanged print(person_copy) # Copy with modified name Important: A shallow copy means that nested objects (like lists or dictionaries inside your dictionary) are referenced, not duplicated. To create a deep copy that also duplicates nested objects, use the copy module:\nimport copy nested_dict = { \"name\": \"John\", \"contact\": { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } } # Deep copy deep_copy = copy.deepcopy(nested_dict) deep_copy[\"contact\"][\"email\"] = \"john.doe@example.com\" print(nested_dict[\"contact\"][\"email\"]) # Still \"john@example.com\" print(deep_copy[\"contact\"][\"email\"]) # \"john.doe@example.com\" Checking if a Key Exists person = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Using the in operator if \"name\" in person: print(\"Name exists in the dictionary\") if \"email\" not in person: print(\"Email does not exist in the dictionary\") Setting Default Values person = { \"name\": \"John\", \"age\": 30 } # Get a value, or set a default if it doesn't exist email = person.setdefault(\"email\", \"default@example.com\") print(email) # Output: default@example.com print(person) # Output: {'name': 'John', 'age': 30, 'email': 'default@example.com'} # If the key already exists, setdefault doesn't change it name = person.setdefault(\"name\", \"Jane\") print(name) # Output: John (not changed to Jane) Dictionary Comprehensions Similar to list comprehensions, Python offers dictionary comprehensions for creating dictionaries in a concise way:\n# Create a dictionary of squares squares = {x: x**2 for x in range(1, 6)} print(squares) # Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} # Dictionary comprehension with condition even_squares = {x: x**2 for x in range(1, 11) if x % 2 == 0} print(even_squares) # Output: {2: 4, 4: 16, 6: 36, 8: 64, 10: 100} # Converting between dictionaries prices = {\"apple\": 0.5, \"banana\": 0.25, \"orange\": 0.75} double_prices = {item: price * 2 for item, price in prices.items()} print(double_prices) # Output: {'apple': 1.0, 'banana': 0.5, 'orange': 1.5} ","exercises#Exercises":"Exercise 1: Create a program that reads a text file and counts the frequency of each word. Ignore case and punctuation. Display the 10 most common words and their counts.\nExercise 2: Write a function that takes a list of dictionaries (each representing a person with ’name’ and ‘age’ keys) and returns a new dictionary where keys are age groups (‘0-9’, ‘10-19’, etc.) and values are lists of names of people in that age group.\nExercise 3: Implement a simple contact management system using dictionaries. The system should allow users to add, edit, delete, and search for contacts. Each contact should store name, phone, email, and address information.\nExercise 4: Create a nested dictionary that represents a small library. The main dictionary keys should be book categories. Each category should contain books as dictionaries with title, author, publication year, and availability status. Implement functions to add books, check out books, return books, and search for books by different criteria.\nHint for Exercise 1: Use a combination of string methods like lower(), split(), and strip() to process the text. Consider using the Counter class from the collections module.\n# Exercise 1 solution outline from collections import Counter def count_words_in_file(filename): with open(filename, 'r') as file: text = file.read().lower() # Remove punctuation and split into words import string for char in string.punctuation: text = text.replace(char, ' ') words = text.split() word_counts = Counter(words) # Get the 10 most common words most_common = word_counts.most_common(10) return most_common # Example usage result = count_words_in_file('sample.txt') for word, count in result: print(f\"{word}: {count}\") In the next section, we’ll explore another important Python data structure: Sets.","merging-dictionaries#Merging Dictionaries":"In Python 3.5+, you can merge dictionaries using the unpacking operator (**):\n# Python 3.5+ personal_info = { \"name\": \"John\", \"age\": 30 } contact_info = { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } # Merge dictionaries person = {**personal_info, **contact_info} print(person) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} In Python 3.9+, you can use the merge operator (|):\n# Python 3.9+ personal_info = { \"name\": \"John\", \"age\": 30 } contact_info = { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } # Merge dictionaries person = personal_info | contact_info print(person) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} # In-place merge personal_info |= contact_info # Updates personal_info print(personal_info) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} For older Python versions, you can use the update() method:\n# Compatible with all Python versions personal_info = { \"name\": \"John\", \"age\": 30 } contact_info = { \"email\": \"john@example.com\", \"phone\": \"555-1234\" } # Merge dictionaries person = personal_info.copy() # Create a copy to avoid modifying personal_info person.update(contact_info) print(person) # Output: {'name': 'John', 'age': 30, 'email': 'john@example.com', 'phone': '555-1234'} Note: If there are duplicate keys, the value from the second dictionary (or the rightmost in case of multiple merges) will overwrite the value from the first.","modifying-dictionaries#Modifying Dictionaries":"Dictionaries are mutable, meaning you can change their content without creating a new dictionary:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\" } # Adding a new key-value pair person[\"email\"] = \"john@example.com\" # Modifying an existing value person[\"age\"] = 31 # Updating multiple key-value pairs at once person.update({ \"age\": 32, \"job\": \"Engineer\", \"country\": \"USA\" }) print(person) # Output: {'name': 'John', 'age': 32, 'city': 'New York', 'email': 'john@example.com', 'job': 'Engineer', 'country': 'USA'} ","nested-dictionaries#Nested Dictionaries":"Dictionaries can contain other dictionaries as values, creating a nested structure:\n# Student record with nested dictionaries student = { \"name\": \"Alice\", \"grades\": { \"math\": 90, \"science\": 85, \"history\": 92 }, \"contact\": { \"email\": \"alice@example.com\", \"phone\": \"555-9876\", \"address\": { \"street\": \"123 Main St\", \"city\": \"Boston\", \"state\": \"MA\", \"zip\": \"02101\" } } } # Accessing nested dictionary values math_grade = student[\"grades\"][\"math\"] print(f\"Math grade: {math_grade}\") # Output: Math grade: 90 state = student[\"contact\"][\"address\"][\"state\"] print(f\"State: {state}\") # Output: State: MA # Safer access with get() email = student.get(\"contact\", {}).get(\"email\", \"No email found\") country = student.get(\"contact\", {}).get(\"address\", {}).get(\"country\", \"USA\") print(f\"Email: {email}, Country: {country}\") # Output: Email: alice@example.com, Country: USA ","practical-applications-of-dictionaries#Practical Applications of Dictionaries":"Example 1: Counting Word Frequencies def count_word_frequencies(text): \"\"\"Count the frequency of each word in a text.\"\"\" # Clean and split the text words = text.lower().split() # Clean punctuation from words words = [word.strip('.,!?:;()[]{}\"\"\\'') for word in words] # Count frequencies word_counts = {} for word in words: if word: # Skip empty strings if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 return word_counts # Example text text = \"\"\" Python is a powerful programming language. Python is easy to learn, and its syntax allows programmers to express concepts in fewer lines of code than would be possible in languages such as C++ or Java. Python supports multiple programming paradigms. \"\"\" # Count word frequencies word_frequencies = count_word_frequencies(text) # Display results print(\"Word Frequencies:\") for word, count in sorted(word_frequencies.items()): print(f\"{word}: {count}\") Example 2: Student Grade Management System def grade_management_system(): \"\"\"A simple grade management system using dictionaries.\"\"\" students = {} while True: print(\"\\nStudent Grade Management System\") print(\"1. Add student\") print(\"2. Add/update grade\") print(\"3. Calculate average grade\") print(\"4. List all students\") print(\"5. Exit\") choice = input(\"\\nEnter your choice (1-5): \") if choice == \"1\": # Add student name = input(\"Enter student name: \") if name in students: print(f\"Student '{name}' already exists!\") else: students[name] = {} print(f\"Student '{name}' added successfully.\") elif choice == \"2\": # Add/update grade name = input(\"Enter student name: \") if name not in students: print(f\"Student '{name}' not found!\") continue subject = input(\"Enter subject name: \") try: grade = float(input(\"Enter grade (0-100): \")) if 0 \u003c= grade \u003c= 100: students[name][subject] = grade print(f\"Grade for {name} in {subject} updated successfully.\") else: print(\"Grade must be between 0 and 100.\") except ValueError: print(\"Invalid input. Grade must be a number.\") elif choice == \"3\": # Calculate average grade name = input(\"Enter student name: \") if name not in students: print(f\"Student '{name}' not found!\") continue if not students[name]: print(f\"No grades found for {name}.\") continue average = sum(students[name].values()) / len(students[name]) print(f\"Average grade for {name}: {average:.2f}\") elif choice == \"4\": # List all students if not students: print(\"No students in the system.\") continue print(\"\\nStudent List:\") for name, grades in students.items(): if grades: average = sum(grades.values()) / len(grades) subjects = \", \".join(grades.keys()) print(f\"{name}: Average = {average:.2f}, Subjects = {subjects}\") else: print(f\"{name}: No grades yet\") elif choice == \"5\": # Exit print(\"Exiting the system. Goodbye!\") break else: print(\"Invalid choice. Please enter a number between 1 and 5.\") # Run the grade management system if __name__ == \"__main__\": grade_management_system() Example 3: Inventory Management def inventory_management(): \"\"\"A simple inventory management system using dictionaries.\"\"\" inventory = {} # Initialize with some items inventory = { \"apple\": {\"price\": 0.5, \"quantity\": 100}, \"banana\": {\"price\": 0.25, \"quantity\": 150}, \"orange\": {\"price\": 0.75, \"quantity\": 80} } while True: print(\"\\nInventory Management System\") print(\"1. Add new item\") print(\"2. Update item price\") print(\"3. Update item quantity\") print(\"4. View inventory\") print(\"5. Calculate inventory value\") print(\"6. Exit\") choice = input(\"\\nEnter your choice (1-6): \") if choice == \"1\": # Add new item item_name = input(\"Enter item name: \").lower() if item_name in inventory: print(f\"Item '{item_name}' already exists!\") continue try: price = float(input(\"Enter item price: $\")) quantity = int(input(\"Enter item quantity: \")) if price \u003c 0 or quantity \u003c 0: print(\"Price and quantity must be non-negative.\") continue inventory[item_name] = {\"price\": price, \"quantity\": quantity} print(f\"Item '{item_name}' added successfully.\") except ValueError: print(\"Invalid input. Price must be a number and quantity must be an integer.\") elif choice == \"2\": # Update item price item_name = input(\"Enter item name: \").lower() if item_name not in inventory: print(f\"Item '{item_name}' not found!\") continue try: price = float(input(\"Enter new price: $\")) if price \u003c 0: print(\"Price must be non-negative.\") continue inventory[item_name][\"price\"] = price print(f\"Price for '{item_name}' updated successfully.\") except ValueError: print(\"Invalid input. Price must be a number.\") elif choice == \"3\": # Update item quantity item_name = input(\"Enter item name: \").lower() if item_name not in inventory: print(f\"Item '{item_name}' not found!\") continue try: quantity = int(input(\"Enter new quantity: \")) if quantity \u003c 0: print(\"Quantity must be non-negative.\") continue inventory[item_name][\"quantity\"] = quantity print(f\"Quantity for '{item_name}' updated successfully.\") except ValueError: print(\"Invalid input. Quantity must be an integer.\") elif choice == \"4\": # View inventory if not inventory: print(\"Inventory is empty.\") continue print(\"\\nCurrent Inventory:\") print(f\"{'Item':\u003c10} {'Price':\u003c10} {'Quantity':\u003c10} {'Value':\u003c10}\") print(\"-\" * 40) for item, details in sorted(inventory.items()): price = details[\"price\"] quantity = details[\"quantity\"] value = price * quantity print(f\"{item:\u003c10} ${price:\u003c9.2f} {quantity:\u003c10} ${value:\u003c9.2f}\") elif choice == \"5\": # Calculate inventory value if not inventory: print(\"Inventory is empty.\") continue total_value = sum( details[\"price\"] * details[\"quantity\"] for details in inventory.values() ) print(f\"\\nTotal Inventory Value: ${total_value:.2f}\") elif choice == \"6\": # Exit print(\"Exiting Inventory Management System. Goodbye!\") break else: print(\"Invalid choice. Please enter a number between 1 and 6.\") # Run the inventory management system if __name__ == \"__main__\": inventory_management() Common Dictionary Operations and Their Time Complexity Understanding the time complexity of dictionary operations helps you make efficient choices:\nOperation Description Time Complexity d[key] Access by key O(1) average d[key] = value Assignment by key O(1) average key in d Key membership test O(1) average d.get(key) Access by key with default O(1) average d.items() View all items O(1) for the view, O(n) to iterate d.keys() View all keys O(1) for the view, O(n) to iterate d.values() View all values O(1) for the view, O(n) to iterate len(d) Count entries O(1) d.pop(key) Remove and return value O(1) average d.update(d2) Add items from another dict O(len(d2)) Note: The “average” designation for O(1) operations reflects that dictionary lookups have constant time complexity on average, but in worst-case scenarios (rare with modern hash implementations), they could degrade to O(n).","removing-items-from-dictionaries#Removing Items from Dictionaries":"There are several ways to remove items from a dictionary:\nperson = { \"name\": \"John\", \"age\": 30, \"city\": \"New York\", \"email\": \"john@example.com\" } # Remove a specific item and return its value email = person.pop(\"email\") print(f\"Removed email: {email}\") # Remove and return the last inserted item (Python 3.7+ guarantees insertion order) last_item = person.popitem() print(f\"Removed last item: {last_item}\") # Remove a specific item without returning it del person[\"age\"] # Clear all items person.clear() print(person) # Output: {} "},"title":"Dictionaries"},"/python-fundamentals/03-data-structures/04-sets/":{"data":{"":"A set is an unordered collection of unique elements in Python. Sets are one of Python’s built-in data structures and are particularly useful when you need to ensure that all elements in a collection are distinct or when you need to perform mathematical set operations like unions, intersections, and differences.","basic-set-operations#Basic Set Operations":"Adding Elements fruits = {\"apple\", \"banana\", \"cherry\"} # Add a single element fruits.add(\"orange\") print(fruits) # Output might be: {'orange', 'cherry', 'apple', 'banana'} # Add multiple elements using update() fruits.update([\"mango\", \"grapes\"]) print(fruits) # Output might include all fruits Removing Elements fruits = {\"apple\", \"banana\", \"cherry\", \"orange\", \"mango\"} # Remove an element (raises KeyError if not found) fruits.remove(\"banana\") print(fruits) # Output: set without 'banana' # Discard an element (no error if not found) fruits.discard(\"pear\") # No error even though 'pear' is not in the set print(fruits) # Remove and return an arbitrary element popped = fruits.pop() print(f\"Popped: {popped}\") print(fruits) # Remove all elements fruits.clear() print(fruits) # Output: set() Note: The difference between remove() and discard() is that remove() will raise a KeyError if the element doesn’t exist, while discard() will do nothing.\nChecking Membership fruits = {\"apple\", \"banana\", \"cherry\"} # Check if an element is in the set print(\"banana\" in fruits) # Output: True print(\"pear\" in fruits) # Output: False print(\"pear\" not in fruits) # Output: True ","common-set-pitfalls#Common Set Pitfalls":" Assuming Sets Maintain Order: Before Python 3.7, sets didn’t guarantee any specific order. Even now, you shouldn’t rely on the order of elements in a set. Using Unhashable Types: Trying to add mutable objects like lists or dictionaries to a set will cause an error. Modifying a Set During Iteration: This can lead to unexpected behavior or errors. Forgetting That Set Elements Must Be Unique: If you need to store duplicates, use a list or counter. ","creating-sets#Creating Sets":"There are several ways to create a set in Python:\n1. Using Curly Braces {} # Creating a set with curly braces fruits = {\"apple\", \"banana\", \"cherry\"} print(fruits) # Output might be: {'cherry', 'banana', 'apple'} 2. Using the set() Constructor # Creating a set from a list colors = set([\"red\", \"green\", \"blue\"]) print(colors) # Output might be: {'blue', 'green', 'red'} # Creating a set from a string letters = set(\"hello\") print(letters) # Output: {'h', 'e', 'l', 'o'} (note only unique letters) 3. Creating an Empty Set # Empty set (must use the constructor, as {} creates an empty dictionary) empty_set = set() print(empty_set) # Output: set() print(type(empty_set)) # Output: \u003cclass 'set'\u003e # This creates an empty dictionary, not a set empty_dict = {} print(type(empty_dict)) # Output: \u003cclass 'dict'\u003e Important: You cannot create an empty set using just curly braces {}. This syntax creates an empty dictionary. To create an empty set, you must use the set() constructor.","exercises#Exercises":"Exercise 1: Write a function that takes two lists and returns three lists containing:\nElements that appear in both lists Elements that appear only in the first list Elements that appear only in the second list Exercise 2: Create a function that counts the number of unique characters in a string, ignoring case and spaces.\nExercise 3: Implement a function that determines if two sentences are anagrams of each other (contain the same characters in different orders, ignoring spaces and punctuation).\nExercise 4: Write a program that simulates a classroom attendance system. Allow the user to:\nAdd students to the class Mark students as present or absent Display who’s present Display who’s absent Display the full class roster Hint for Exercise 1: Use set operations like intersection and difference to find the required elements.\ndef analyze_lists(list1, list2): set1 = set(list1) set2 = set(list2) common = list(set1 \u0026 set2) only_in_first = list(set1 - set2) only_in_second = list(set2 - set1) return common, only_in_first, only_in_second In the next section, we’ll explore string manipulation in Python, learning how to work with text efficiently.","frozen-sets#Frozen Sets":"Python also provides an immutable version of sets called frozen sets. Once created, you cannot modify a frozen set:\n# Creating a frozen set frozen = frozenset([1, 2, 3, 4]) print(frozen) # Output: frozenset({1, 2, 3, 4}) # Trying to modify a frozen set raises an error try: frozen.add(5) # This will cause an error except AttributeError as e: print(f\"Error: {e}\") # Output: Error: 'frozenset' object has no attribute 'add' Frozen sets can be used as elements in other sets or as keys in dictionaries since they are hashable (immutable):\n# Using frozen sets as elements in a set set_of_frozensets = {frozenset([1, 2]), frozenset([3, 4])} print(set_of_frozensets) # Output: {frozenset({1, 2}), frozenset({3, 4})} # Using a frozen set as a dictionary key dict_with_frozensets = {frozenset([1, 2]): \"set1\", frozenset([3, 4]): \"set2\"} print(dict_with_frozensets) # Output: {frozenset({1, 2}): 'set1', frozenset({3, 4}): 'set2'} ","key-characteristics-of-sets#Key Characteristics of Sets":" Unordered: Elements in a set have no specific order. You cannot access elements by index or key. Unique Elements: Sets automatically remove duplicates. Each element can appear only once. Mutable: You can add or remove elements from a set after it’s created. Heterogeneous: Sets can contain elements of different data types. Hashable Elements: Set elements must be hashable (immutable) data types like numbers, strings, or tuples. Lists, dictionaries, and other sets cannot be elements of a set. # Demonstrating uniqueness numbers = {1, 2, 3, 2, 1, 4, 5} print(numbers) # Output: {1, 2, 3, 4, 5} (duplicates are removed) # Heterogeneous data types mixed_set = {1, \"hello\", (1, 2, 3)} print(mixed_set) # Output might be: {1, 'hello', (1, 2, 3)} # Error if we try to add unhashable elements try: invalid_set = {1, [2, 3], 4} # This will cause an error except TypeError as e: print(f\"Error: {e}\") # Output: Error: unhashable type: 'list' ","performance-considerations#Performance Considerations":"Sets in Python are implemented using hash tables, which provide several performance benefits:\nFast Membership Testing: Checking if an element is in a set (x in s) is very fast, with O(1) average time complexity. Fast Add and Remove: Adding and removing elements are also O(1) operations on average. Efficient for Uniqueness: Sets automatically handle uniqueness, making them efficient for removing duplicates. Set Operations: Set operations like union, intersection, and difference are optimized and generally faster than equivalent operations on lists. import time # Demonstrate the performance advantage of sets for membership testing def measure_membership_performance(n): \"\"\"Compare membership testing in lists vs. sets.\"\"\" # Create a list and a set with n elements data_list = list(range(n)) data_set = set(range(n)) # Test membership in list start_time = time.time() list_result = n-1 in data_list list_time = time.time() - start_time # Test membership in set start_time = time.time() set_result = n-1 in data_set set_time = time.time() - start_time print(f\"n = {n}:\") print(f\" List membership test: {list_time:.6f} seconds\") print(f\" Set membership test: {set_time:.6f} seconds\") print(f\" Set is {list_time/set_time:.1f}x faster\") # Try with different sizes for n in [1000, 10000, 100000, 1000000]: measure_membership_performance(n) print() Important: While sets provide fast lookups, they have some overhead and are not always the best choice:\nFor very small collections, lists might be faster due to less overhead. Sets consume more memory than lists for the same elements. If you need ordered data or duplicates, lists are more appropriate. ","practical-examples#Practical Examples":"Example 1: Removing Duplicates from a List One of the most common uses of sets is to remove duplicates from a list:\ndef remove_duplicates(items): \"\"\"Remove duplicates from a list while preserving order.\"\"\" return list(dict.fromkeys(items)) # More efficient than using a set # Test the function numbers = [1, 2, 2, 3, 4, 3, 5, 1, 4] unique_numbers = remove_duplicates(numbers) print(unique_numbers) # Output: [1, 2, 3, 4, 5] # Note: If order doesn't matter, you can simply do: unique_numbers = list(set(numbers)) Example 2: Finding Common Elements def find_common_elements(list1, list2): \"\"\"Find common elements between two lists.\"\"\" set1 = set(list1) set2 = set(list2) return list(set1.intersection(set2)) # Test the function group1 = [\"apple\", \"banana\", \"cherry\", \"orange\"] group2 = [\"banana\", \"kiwi\", \"orange\", \"pear\"] common = find_common_elements(group1, group2) print(common) # Output: ['banana', 'orange'] (order may vary) Example 3: Finding Unique Words in a Text def unique_words(text): \"\"\"Find all unique words in a text.\"\"\" # Split by whitespace and remove punctuation words = text.lower().replace(\".\", \"\").replace(\",\", \"\").replace(\"!\", \"\").split() return set(words) # Test the function sample_text = \"The quick brown fox jumps over the lazy dog. The dog barks, but the fox jumps away!\" unique = unique_words(sample_text) print(unique) print(f\"Number of unique words: {len(unique)}\") Example 4: Set-Based Data Analysis def analyze_survey(responses): \"\"\"Analyze survey responses where respondents could select multiple options.\"\"\" # Count total respondents total_respondents = len(responses) # Find all unique options selected all_options = set() for response in responses: all_options.update(response) # Count how many people selected each option option_counts = {} for option in all_options: option_counts[option] = sum(1 for response in responses if option in response) # Find combinations of options that appeared together option_pairs = {} for response in responses: if len(response) \u003e= 2: # Consider all pairs in this response for i, option1 in enumerate(response): for option2 in response[i+1:]: pair = frozenset([option1, option2]) # Order doesn't matter option_pairs[pair] = option_pairs.get(pair, 0) + 1 return { \"total_respondents\": total_respondents, \"unique_options\": all_options, \"option_counts\": option_counts, \"common_pairs\": option_pairs } # Sample survey data: each list represents one person's selections survey_data = [ [\"pizza\", \"burger\", \"pasta\"], [\"pizza\", \"salad\", \"sushi\"], [\"burger\", \"steak\"], [\"pizza\", \"pasta\", \"salad\"], [\"sushi\", \"salad\"] ] analysis = analyze_survey(survey_data) print(f\"Total respondents: {analysis['total_respondents']}\") print(f\"All food options selected: {analysis['unique_options']}\") print(\"\\nOption popularity:\") for option, count in analysis['option_counts'].items(): percentage = (count / analysis['total_respondents']) * 100 print(f\" {option}: {count} responses ({percentage:.1f}%)\") print(\"\\nCommon combinations:\") for pair, count in sorted(analysis['common_pairs'].items(), key=lambda x: x[1], reverse=True): if count \u003e 1: # Only show pairs that appeared more than once pair_list = list(pair) print(f\" {pair_list[0]} and {pair_list[1]}: {count} responses\") ","set-comprehensions#Set Comprehensions":"Similar to list comprehensions, Python allows you to create sets using set comprehensions:\n# Create a set of squares for numbers 1 to 5 squares = {x**2 for x in range(1, 6)} print(squares) # Output: {1, 4, 9, 16, 25} # Create a set of even numbers from 1 to 10 evens = {x for x in range(1, 11) if x % 2 == 0} print(evens) # Output: {2, 4, 6, 8, 10} # Create a set of uppercase letters from a string uppercase_letters = {char.upper() for char in \"hello world\" if char.isalpha()} print(uppercase_letters) # Output: {'H', 'E', 'L', 'O', 'W', 'R', 'D'} ","set-methods-and-operations#Set Methods and Operations":"Python sets support mathematical set operations, which makes them very powerful for certain tasks:\n1. Union The union of two sets includes all unique elements from both sets. You can use the | operator or the union() method:\nset1 = {1, 2, 3} set2 = {3, 4, 5} # Using the | operator union_set = set1 | set2 print(union_set) # Output: {1, 2, 3, 4, 5} # Using the union() method union_set = set1.union(set2) print(union_set) # Output: {1, 2, 3, 4, 5} # You can unite more than two sets set3 = {5, 6, 7} union_set = set1.union(set2, set3) print(union_set) # Output: {1, 2, 3, 4, 5, 6, 7} 2. Intersection The intersection of two sets includes only elements present in both sets. You can use the \u0026 operator or the intersection() method:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Using the \u0026 operator intersection_set = set1 \u0026 set2 print(intersection_set) # Output: {3, 4} # Using the intersection() method intersection_set = set1.intersection(set2) print(intersection_set) # Output: {3, 4} # Intersection of multiple sets set3 = {4, 5, 6, 7} intersection_set = set1.intersection(set2, set3) print(intersection_set) # Output: {4} 3. Difference The difference between two sets includes elements in the first set but not in the second set. You can use the - operator or the difference() method:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Using the - operator difference_set = set1 - set2 print(difference_set) # Output: {1, 2} # Using the difference() method difference_set = set1.difference(set2) print(difference_set) # Output: {1, 2} # The difference is not commutative difference_set = set2 - set1 print(difference_set) # Output: {5, 6} 4. Symmetric Difference The symmetric difference includes elements in either set, but not in both. You can use the ^ operator or the symmetric_difference() method:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Using the ^ operator symmetric_difference = set1 ^ set2 print(symmetric_difference) # Output: {1, 2, 5, 6} # Using the symmetric_difference() method symmetric_difference = set1.symmetric_difference(set2) print(symmetric_difference) # Output: {1, 2, 5, 6} 5. Subset and Superset You can check if one set is a subset or superset of another set:\nset1 = {1, 2, 3} set2 = {1, 2, 3, 4, 5} # Check if set1 is a subset of set2 print(set1.issubset(set2)) # Output: True print(set1 \u003c= set2) # Output: True # Check if set1 is a proper subset of set2 print(set1 \u003c set2) # Output: True # Check if set2 is a superset of set1 print(set2.issuperset(set1)) # Output: True print(set2 \u003e= set1) # Output: True # Check if set2 is a proper superset of set1 print(set2 \u003e set1) # Output: True A proper subset/superset means the sets are not equal.\n6. Disjoint Sets Two sets are disjoint if they have no elements in common:\nset1 = {1, 2, 3} set2 = {4, 5, 6} set3 = {3, 4, 5} print(set1.isdisjoint(set2)) # Output: True (no common elements) print(set1.isdisjoint(set3)) # Output: False ('3' is common) ","update-operations#Update Operations":"Python also provides methods to modify a set in place based on set operations:\nset1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Update set1 with the union set1.update(set2) print(set1) # Output: {1, 2, 3, 4, 5, 6} # Reset set1 set1 = {1, 2, 3, 4} # Update set1 with the intersection set1.intersection_update(set2) print(set1) # Output: {3, 4} # Reset set1 set1 = {1, 2, 3, 4} # Update set1 with the difference set1.difference_update(set2) print(set1) # Output: {1, 2} # Reset set1 set1 = {1, 2, 3, 4} # Update set1 with the symmetric difference set1.symmetric_difference_update(set2) print(set1) # Output: {1, 2, 5, 6} ","when-to-use-sets#When to Use Sets":"Sets are particularly useful in the following scenarios:\nWhen you need to ensure uniqueness: Sets automatically remove duplicates, making them perfect for storing unique items. For membership testing: If you frequently need to check if an item exists in a collection, sets provide fast lookups. When you need to perform set operations: If your problem involves operations like unions, intersections, or differences, sets have built-in methods for these. For removing duplicates from a sequence: Converting a list to a set and back to a list is a quick way to remove duplicates (though it doesn’t preserve order). When order doesn’t matter: If you don’t care about the order of elements, sets can be more efficient than lists. "},"title":"Sets"},"/python-fundamentals/03-data-structures/05-string-manipulations/":{"data":{"":"Strings are one of the most commonly used data types in programming. In Python, strings are sequences of characters enclosed in quotes (single, double, or triple quotes). String manipulation involves various operations to modify, analyze, or extract information from strings.","creating-strings#Creating Strings":"There are several ways to create strings in Python:\n# Single quotes name = 'John' # Double quotes message = \"Hello, World!\" # Triple quotes (for multi-line strings) description = \"\"\"This is a multi-line string that spans multiple lines.\"\"\" # Empty string empty_string = \"\" Both single and double quotes work the same way, but using double quotes allows you to include single quotes within the string without escaping them, and vice versa:\n# Single quotes inside double quotes message = \"Don't worry about apostrophes\" # Double quotes inside single quotes code = 'The variable is called \"counter\"' ","exercises#Exercises":"Exercise 1: Write a function called reverse_words that takes a string as input and returns a new string with the words reversed but the order of the words maintained. For example, “Hello World” should become “olleH dlroW”.\nExercise 2: Create a function that checks if a string is a palindrome (reads the same backward as forward), ignoring case, spaces, and punctuation. For example, “A man, a plan, a canal: Panama” is a palindrome.\nExercise 3: Write a function that extracts all email addresses from a given text. Use string methods (or regular expressions for an extra challenge) to identify and extract email patterns.\nExercise 4: Implement a function called word_censorship that takes two parameters: a text string and a list of words to censor. Replace each occurrence of a censored word with asterisks of the same length. The censorship should be case-insensitive.\nHint for Exercise 1:\ndef reverse_words(text): words = text.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words) In the next section, we’ll explore lists in Python, which are versatile and widely used data structures for storing collections of items.","practical-string-manipulation-examples#Practical String Manipulation Examples":"Example 1: Password Validator def validate_password(password): \"\"\" Validate that a password meets the following criteria: - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character (!@#$%^\u0026*()_+) Returns a list of validation errors or an empty list if valid. \"\"\" errors = [] # Check length if len(password) \u003c 8: errors.append(\"Password must be at least 8 characters long\") # Check for uppercase letter if not any(char.isupper() for char in password): errors.append(\"Password must contain at least one uppercase letter\") # Check for lowercase letter if not any(char.islower() for char in password): errors.append(\"Password must contain at least one lowercase letter\") # Check for digit if not any(char.isdigit() for char in password): errors.append(\"Password must contain at least one digit\") # Check for special character special_chars = \"!@#$%^\u0026*()_+\" if not any(char in special_chars for char in password): errors.append(\"Password must contain at least one special character (!@#$%^\u0026*()_+)\") return errors # Test the validator test_passwords = [ \"abc123\", # Too short \"ALLUPPERCASE123!\", # No lowercase \"alllowercase123!\", # No uppercase \"ABCDEabcde!\", # No digits \"ABCDEabcde123\", # No special chars \"ABCabc123!\", # Valid ] for password in test_passwords: errors = validate_password(password) if errors: print(f\"Password '{password}' is invalid:\") for error in errors: print(f\"- {error}\") else: print(f\"Password '{password}' is valid\") print() Example 2: Text Analyzer def analyze_text(text): \"\"\" Analyze a text and return statistics about it. \"\"\" # Prepare the text: convert to lowercase and remove punctuation import string text = text.lower() for punctuation in string.punctuation: text = text.replace(punctuation, \"\") # Split into words words = text.split() # Count the words word_count = len(words) # Count unique words unique_words = set(words) unique_word_count = len(unique_words) # Find most common words from collections import Counter word_counter = Counter(words) most_common = word_counter.most_common(5) # Calculate average word length total_length = sum(len(word) for word in words) avg_word_length = total_length / word_count if word_count \u003e 0 else 0 # Analyze sentence structure sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") sentences = [s.strip() for s in sentences if s.strip()] sentence_count = len(sentences) avg_sentence_length = word_count / sentence_count if sentence_count \u003e 0 else 0 # Return the analysis return { \"word_count\": word_count, \"unique_word_count\": unique_word_count, \"vocabulary_diversity\": unique_word_count / word_count if word_count \u003e 0 else 0, \"avg_word_length\": avg_word_length, \"sentence_count\": sentence_count, \"avg_sentence_length\": avg_sentence_length, \"most_common_words\": most_common } # Test the analyzer sample_text = \"\"\" Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation. Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including structured, object-oriented and functional programming. It is often described as a \"batteries included\" language due to its comprehensive standard library. \"\"\" analysis = analyze_text(sample_text) print(\"Text Analysis Results:\") print(f\"Word count: {analysis['word_count']}\") print(f\"Unique word count: {analysis['unique_word_count']}\") print(f\"Vocabulary diversity: {analysis['vocabulary_diversity']:.2f}\") print(f\"Average word length: {analysis['avg_word_length']:.2f} characters\") print(f\"Sentence count: {analysis['sentence_count']}\") print(f\"Average sentence length: {analysis['avg_sentence_length']:.2f} words\") print(\"Most common words:\") for word, count in analysis['most_common_words']: print(f\"- '{word}': {count} occurrences\") Example 3: Simple Template Engine def render_template(template, variables): \"\"\" A simple template engine that replaces {{variable}} in the template with the corresponding value from the variables dictionary. \"\"\" result = template for key, value in variables.items(): placeholder = \"{{\" + key + \"}}\" result = result.replace(placeholder, str(value)) return result # Test the template engine template = \"\"\" Dear {{name}}, Thank you for your purchase of {{product}} on {{date}}. Your order number is {{order_id}}. Please contact us at {{support_email}} if you have any questions. Sincerely, {{company_name}} \"\"\" variables = { \"name\": \"John Smith\", \"product\": \"Python Programming Book\", \"date\": \"May 15, 2023\", \"order_id\": \"ORD-12345\", \"support_email\": \"support@example.com\", \"company_name\": \"Tech Books Inc.\" } rendered = render_template(template, variables) print(rendered) ","string-concatenation#String Concatenation":"You can combine strings using the + operator:\nfirst_name = \"John\" last_name = \"Doe\" full_name = first_name + \" \" + last_name print(full_name) # Output: John Doe You can also use the += operator to append to a string:\ngreeting = \"Hello\" greeting += \", World!\" print(greeting) # Output: Hello, World! For more complex string building, especially when combining different data types, it’s often better to use string formatting methods (covered later) rather than concatenation.","string-formatting#String Formatting":"Python provides several ways to format strings:\nf-strings (Python 3.6+) name = \"Alice\" age = 30 height = 5.8 # Basic formatting greeting = f\"Hello, my name is {name} and I am {age} years old.\" print(greeting) # Format specifications height_formatted = f\"My height is {height:.1f} feet.\" print(height_formatted) # My height is 5.8 feet. # Expressions in f-strings print(f\"In five years, I'll be {age + 5} years old.\") # In five years, I'll be 35 years old. # Alignment and padding for num in range(1, 11): print(f\"{num:2d} squared is {num**2:3d}\") # Output: # 1 squared is 1 # 2 squared is 4 # 3 squared is 9 # ... # 10 squared is 100 The format() Method # Basic formatting greeting = \"Hello, my name is {} and I am {} years old.\".format(name, age) print(greeting) # Positional arguments template = \"The order is: {0}, {1}, {2}.\" print(template.format(\"first\", \"second\", \"third\")) # The order is: first, second, third. # Reuse positional arguments template = \"The repeated order is: {0}, {1}, {0}.\" print(template.format(\"first\", \"second\")) # The repeated order is: first, second, first. # Named arguments info = \"Name: {name}, Age: {age}, Height: {height}m\".format(name=\"Bob\", age=25, height=1.85) print(info) # Name: Bob, Age: 25, Height: 1.85m # Format specifications pi = 3.14159265359 print(\"Pi is approximately {:.2f}\".format(pi)) # Pi is approximately 3.14 # Alignment for i in range(1, 11): print(\"Number: {:\u003c2}, Square: {:\u003c3}, Cube: {:\u003c4}\".format(i, i**2, i**3)) # Number: 1 , Square: 1 , Cube: 1 # Number: 2 , Square: 4 , Cube: 8 # ... The % Operator (older style) # Basic formatting greeting = \"Hello, my name is %s and I am %d years old.\" % (name, age) print(greeting) # Format specifiers pi = 3.14159 print(\"Pi is approximately %.2f\" % pi) # Pi is approximately 3.14 # Multiple values print(\"Name: %s, Age: %d, Height: %.1f\" % (name, age, height)) Note: While the % operator is still supported, f-strings and the format() method are generally preferred in modern Python code due to improved readability and flexibility.","string-indexing#String Indexing":"Strings in Python are sequences, and each character has an index. Indexing starts at 0 for the first character:\nmessage = \"Hello, World!\" # Access individual characters first_char = message[0] # 'H' sixth_char = message[5] # ',' # Negative indexing (counting from the end) last_char = message[-1] # '!' second_last = message[-2] # 'd' print(f\"First character: {first_char}\") print(f\"Last character: {last_char}\") Important: Strings in Python are immutable, which means you cannot change individual characters directly:\nmessage = \"Hello\" # This will cause an error: # message[0] = \"h\" # TypeError: 'str' object does not support item assignment # Instead, create a new string message = \"h\" + message[1:] print(message) # Output: hello ","string-interpolation-with-variables#String Interpolation with Variables":"Python 3.6+ introduced a simpler form of string formatting using f-strings, which directly interpolate variables:\nname = \"Charlie\" age = 40 print(f\"{name} is {age} years old.\") # Charlie is 40 years old. ","string-manipulation-best-practices#String Manipulation Best Practices":"1. Use String Methods Instead of Manual Iteration # Less efficient uppercase_chars = \"\" for char in text: if char.isalpha(): uppercase_chars += char.upper() # More efficient uppercase_chars = \"\".join(char.upper() for char in text if char.isalpha()) 2. Use join() Instead of + for Building Strings # Less efficient (creates many intermediate strings) result = \"\" for item in items: result += item + \", \" result = result[:-2] # Remove trailing comma and space # More efficient result = \", \".join(items) 3. Use f-strings for Readable Formatting # Less readable info = \"Name: \" + name + \", Age: \" + str(age) + \", City: \" + city # More readable info = f\"Name: {name}, Age: {age}, City: {city}\" 4. Use String Methods for Validation # Less reliable is_valid = True for char in user_id: if not (char.isalpha() or char.isdigit() or char == '_'): is_valid = False break # More reliable is_valid = all(char.isalpha() or char.isdigit() or char == '_' for char in user_id) # Or even better is_valid = user_id.isalnum() or \"_\" in user_id 5. Consider Regular Expressions for Complex Pattern Matching import re # Check if a string is a valid email address def is_valid_email(email): pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$' return bool(re.match(pattern, email)) # Test the function emails = [\"user@example.com\", \"invalid-email\", \"another.user@domain.co.uk\"] for email in emails: print(f\"{email}: {'Valid' if is_valid_email(email) else 'Invalid'}\") ","string-methods#String Methods":"Python provides many built-in methods for string manipulation:\nCase Conversion Methods message = \"Hello, World!\" # Convert to uppercase upper_case = message.upper() print(upper_case) # HELLO, WORLD! # Convert to lowercase lower_case = message.lower() print(lower_case) # hello, world! # Convert first character of each word to uppercase title_case = \"welcome to python\".title() print(title_case) # Welcome To Python # Capitalize only the first character of the string capitalized = \"welcome to python\".capitalize() print(capitalized) # Welcome to python # Swap case (uppercase becomes lowercase and vice versa) swapped = \"Hello, World!\".swapcase() print(swapped) # hELLO, wORLD! Searching Methods message = \"Python is a powerful programming language\" # Check if a string starts with a specific prefix starts_with_python = message.startswith(\"Python\") print(starts_with_python) # True # Check if a string ends with a specific suffix ends_with_language = message.endswith(\"language\") print(ends_with_language) # True # Find the position of a substring (returns -1 if not found) position = message.find(\"powerful\") print(position) # 11 # Count occurrences of a substring count = message.count(\"p\") print(count) # 3 (two in \"Python\" and one in \"powerful\") # Check if a string contains only alphabetic characters is_alpha = \"Python\".isalpha() print(is_alpha) # True # Check if a string contains only digits is_digit = \"12345\".isdigit() print(is_digit) # True # Check if a string is alphanumeric is_alnum = \"Python3\".isalnum() print(is_alnum) # True # Check if all characters are whitespace is_space = \" \".isspace() print(is_space) # True Transformation Methods # Replace parts of a string original = \"Python is cool, Python is powerful\" replaced = original.replace(\"Python\", \"Java\") print(replaced) # Java is cool, Java is powerful # Replace with a limit replaced_once = original.replace(\"Python\", \"Java\", 1) print(replaced_once) # Java is cool, Python is powerful # Strip whitespace from the beginning and end text = \" Hello, World! \" stripped = text.strip() print(stripped) # \"Hello, World!\" # Strip only from the left left_stripped = text.lstrip() print(left_stripped) # \"Hello, World! \" # Strip only from the right right_stripped = text.rstrip() print(right_stripped) # \" Hello, World!\" # Strip specific characters (not just whitespace) text_with_symbols = \"###Hello, World!###\" stripped_symbols = text_with_symbols.strip(\"#\") print(stripped_symbols) # \"Hello, World!\" # Pad a string to a fixed length padded = \"Hello\".ljust(10, \"*\") print(padded) # \"Hello*****\" right_padded = \"Hello\".rjust(10, \"*\") print(right_padded) # \"*****Hello\" center_padded = \"Hello\".center(10, \"*\") print(center_padded) # \"**Hello***\" Splitting and Joining # Split a string into a list based on a delimiter message = \"apple,banana,cherry,date\" fruits = message.split(\",\") print(fruits) # ['apple', 'banana', 'cherry', 'date'] # Split with a maximum number of splits first_two = message.split(\",\", 2) print(first_two) # ['apple', 'banana', 'cherry,date'] # Split by whitespace (default behavior of split()) sentence = \"Python is a programming language\" words = sentence.split() print(words) # ['Python', 'is', 'a', 'programming', 'language'] # Split by lines multiline = \"\"\"Line 1 Line 2 Line 3\"\"\" lines = multiline.splitlines() print(lines) # ['Line 1', 'Line 2', 'Line 3'] # Join a list of strings into a single string joined = \", \".join(fruits) print(joined) # 'apple, banana, cherry, date' # Join with empty string no_spaces = \"\".join(words) print(no_spaces) # 'Pythonisaprogramminglanguage' ","string-repetition#String Repetition":"The * operator repeats a string a specified number of times:\nseparator = \"-\" * 20 print(separator) # Output: -------------------- word = \"Python \" repeated = word * 3 print(repeated) # Output: Python Python Python ","string-slicing#String Slicing":"Slicing allows you to extract a portion of a string:\nmessage = \"Hello, World!\" # Syntax: string[start:end:step] # The slice includes start but excludes end # Extract \"Hello\" hello = message[0:5] # or simply message[:5] # Extract \"World\" world = message[7:12] # Extract every second character every_second = message[::2] # \"Hlo ol!\" # Extract the last 5 characters last_five = message[-5:] # \"orld!\" # Reverse a string reversed_msg = message[::-1] # \"!dlroW ,olleH\" print(f\"Hello part: {hello}\") print(f\"World part: {world}\") print(f\"Every second character: {every_second}\") print(f\"Last five characters: {last_five}\") print(f\"Reversed message: {reversed_msg}\") ","working-with-unicode-and-special-characters#Working with Unicode and Special Characters":"Python 3 strings are Unicode by default, which means they can contain characters from various languages and special symbols:\n# Unicode characters unicode_string = \"こんにちは\" # Japanese for \"Hello\" print(unicode_string) # Unicode escape sequences heart_symbol = \"\\u2764\" # Unicode code point for heart print(heart_symbol) # ❤ # Special escape sequences text_with_newlines = \"First line\\nSecond line\" print(text_with_newlines) # Output: # First line # Second line text_with_tabs = \"Name\\tAge\\tCity\" print(text_with_tabs) # Output: # Name Age City # Raw strings (ignore escape characters) raw_string = r\"C:\\Users\\John\\Documents\" print(raw_string) # C:\\Users\\John\\Documents "},"title":"String Manipulation"},"/python-fundamentals/04-functions/":{"data":{"":"Imagine writing the same code over and over again - tedious, right?\nFunctions are your secret weapon against repetitive coding, packaging instructions into powerful, reusable components that will revolutionize how you program.\nThey help organize your code into logical, manageable chunks, making your programs more readable, maintainable, and efficient. By defining a function once and calling it multiple times throughout your program, you avoid repetition and reduce the chance of errors.\nHere is what this section covers:\n01. Defining and calling functions 02. Parameters and Arguments 03. Return Statements 04. Variable Scope 05. Lambda Functions "},"title":"Functions"},"/python-fundamentals/04-functions/01-defining-and-calling-functions/":{"data":{"":"","basic-function-syntax#Basic Function Syntax":"","best-practices-for-functions#Best Practices for Functions":"1. Follow the Single Responsibility Principle A function should do one thing and do it well:\n# Bad: Function does too many things def process_user_data(user_data): # Validate data # Save to database # Send confirmation email # Update logs pass # Better: Separate functions for each responsibility def validate_user_data(user_data): pass def save_user_to_database(user_data): pass def send_confirmation_email(user_email): pass def log_user_creation(user_id): pass def process_user_data(user_data): if validate_user_data(user_data): user_id = save_user_to_database(user_data) send_confirmation_email(user_data[\"email\"]) log_user_creation(user_id) 2. Use Descriptive Function Names Choose function names that clearly describe what the function does:\n# Unclear def process(data): pass # Clear def calculate_average_temperature(temperature_readings): pass 3. Keep Functions Short Aim for functions that can fit on one screen (20-30 lines maximum):\n# Too long - break it down def analyze_data(data): # 100 lines of code pass # Better - separate into smaller functions def clean_data(data): pass def compute_statistics(data): pass def generate_report(statistics): pass def analyze_data(data): cleaned_data = clean_data(data) statistics = compute_statistics(cleaned_data) return generate_report(statistics) 4. Use Default Arguments Sparingly Default arguments are useful, but overusing them can make function behavior unpredictable:\n# Too many default arguments def create_user(name=\"\", age=0, email=\"\", address=\"\", role=\"user\", active=True, created_at=None, subscription=None): pass # Better def create_user(name, email, age=None, role=\"user\"): pass # For many optional parameters, use a config dictionary def create_user(name, email, **options): defaults = { \"age\": None, \"role\": \"user\", \"active\": True } # Update defaults with provided options config = {**defaults, **options} # Use the config dictionary pass 5. Avoid Mutable Default Arguments Default arguments are evaluated only once at function definition, which can cause unexpected behavior with mutable defaults:\n# Bad - mutable default argument def add_to_list(item, item_list=[]): item_list.append(item) return item_list print(add_to_list(\"apple\")) # ['apple'] print(add_to_list(\"banana\")) # ['apple', 'banana'] - unexpected! # Good - use None as default and create a new list inside def add_to_list(item, item_list=None): if item_list is None: item_list = [] item_list.append(item) return item_list print(add_to_list(\"apple\")) # ['apple'] print(add_to_list(\"banana\")) # ['banana'] - as expected 6. Provide Clear Documentation Document your functions with clear docstrings:\ndef calculate_bmi(weight_kg, height_m): \"\"\" Calculate Body Mass Index (BMI). The BMI is calculated by dividing the weight in kilograms by the square of the height in meters. Args: weight_kg (float): The weight in kilograms. height_m (float): The height in meters. Returns: float: The BMI value. Raises: ValueError: If weight or height is negative or zero. \"\"\" if weight_kg \u003c= 0: raise ValueError(\"Weight must be positive\") if height_m \u003c= 0: raise ValueError(\"Height must be positive\") return weight_kg / (height_m ** 2) 7. Return Early for Edge Cases Handle edge cases early in your function to avoid deeply nested code:\n# Deeply nested code def process_data(data): if data: if is_valid(data): if has_required_fields(data): # Process the data return result else: return None else: return None else: return None # Better with early returns def process_data(data): if not data: return None if not is_valid(data): return None if not has_required_fields(data): return None # Process the data return result ","default-parameter-values#Default Parameter Values":"","defining-and-calling-a-simple-function#Defining and Calling a Simple Function":"","docstrings#Docstrings":"Docstrings are string literals that appear as the first statement in a function, class, or module. They document what the function does, its parameters, and return values:\ndef calculate_area(length, width): \"\"\" Calculate the area of a rectangle. Args: length (float): The length of the rectangle. width (float): The width of the rectangle. Returns: float: The area of the rectangle. \"\"\" return length * width Good docstrings make your code more maintainable and help other developers (including your future self) understand how to use your functions.","exercises#Exercises":"Exercise 1: Write a function called is_palindrome that takes a string as input and returns True if the string is a palindrome (reads the same backward as forward), and False otherwise. Ignore case and non-alphanumeric characters.\nExercise 2: Create a function called count_words that takes a string of text and returns a dictionary where the keys are the words and the values are the number of times each word appears in the text. Ignore case and punctuation.\nExercise 3: Write a function called fibonacci that takes a positive integer n and returns the nth number in the Fibonacci sequence. Implement it both recursively and iteratively, and compare their performance for larger values of n.\nExercise 4: Create a calculator function that takes two numbers and an operator (as a string: ‘+’, ‘-’, ‘*’, or ‘/’) and returns the result of the operation. The function should handle division by zero appropriately.\nHint for Exercise 1: You can use string methods like lower() to ignore case and create a helper function to remove non-alphanumeric characters. Then compare the cleaned string with its reverse (you can reverse a string with slicing: s[::-1]).\nIn the next section, we’ll explore parameters and arguments in more detail, including different ways to pass arguments to functions.","functions-with-multiple-parameters#Functions with Multiple Parameters":"","functions-with-parameters#Functions with Parameters":"","passing-arguments-to-functions#Passing Arguments to Functions":"Let’s explore the different ways to pass arguments to functions in more detail:\n1. Positional Arguments Arguments are matched to parameters based on their position:\ndef power(base, exponent): \"\"\"Calculate base raised to the exponent power.\"\"\" return base ** exponent # base=2, exponent=3 result1 = power(2, 3) print(result1) # Output: 8 # base=3, exponent=2 result2 = power(3, 2) print(result2) # Output: 9 2. Keyword Arguments Arguments are matched to parameters based on their names:\ndef create_profile(name, age, occupation): \"\"\"Create a user profile dictionary.\"\"\" return { \"name\": name, \"age\": age, \"occupation\": occupation } # Using keyword arguments (order doesn't matter) profile = create_profile(occupation=\"Developer\", name=\"Alice\", age=28) print(profile) # Output: {'name': 'Alice', 'age': 28, 'occupation': 'Developer'} 3. Mixing Positional and Keyword Arguments You can mix positional and keyword arguments, but positional arguments must come before keyword arguments:\ndef display_info(name, age, city): \"\"\"Display a person's information.\"\"\" print(f\"{name} is {age} years old and lives in {city}.\") # Mixing: name and age are positional, city is keyword display_info(\"Alice\", 28, city=\"New York\") # Output: Alice is 28 years old and lives in New York. # This would raise a SyntaxError (positional after keyword) # display_info(name=\"Alice\", 28, city=\"New York\") 4. Variable-Length Arguments: *args The *args parameter allows a function to accept any number of positional arguments:\ndef sum_all(*args): \"\"\"Sum any number of arguments.\"\"\" total = 0 for num in args: total += num return total # Calling with different numbers of arguments print(sum_all(1, 2)) # Output: 3 print(sum_all(1, 2, 3, 4)) # Output: 10 print(sum_all(5)) # Output: 5 print(sum_all()) # Output: 0 In the function, args is a tuple containing all the positional arguments.\n5. Variable-Length Keyword Arguments: **kwargs The **kwargs parameter allows a function to accept any number of keyword arguments:\ndef print_person_details(**kwargs): \"\"\"Print details about a person using keyword arguments.\"\"\" print(\"Person Details:\") for key, value in kwargs.items(): print(f\"{key}: {value}\") # Calling with different keyword arguments print_person_details(name=\"Alice\", age=28, occupation=\"Developer\") # Output: # Person Details: # name: Alice # age: 28 # occupation: Developer print_person_details(name=\"Bob\", country=\"Canada\") # Output: # Person Details: # name: Bob # country: Canada In the function, kwargs is a dictionary containing all the keyword arguments.\n6. Combined Parameter Types You can combine all types of parameters, but they must appear in this order:\nStandard positional parameters *args parameter Standard parameters with default values **kwargs parameter def complex_function(a, b, *args, c=10, d=20, **kwargs): \"\"\"Demonstrate all parameter types.\"\"\" print(f\"a: {a}\") print(f\"b: {b}\") print(f\"args: {args}\") print(f\"c: {c}\") print(f\"d: {d}\") print(f\"kwargs: {kwargs}\") # Calling the function complex_function(1, 2, 3, 4, 5, d=40, e=50, f=60) # Output: # a: 1 # b: 2 # args: (3, 4, 5) # c: 10 # d: 40 # kwargs: {'e': 50, 'f': 60} ","practical-examples#Practical Examples":"Example 1: Temperature Converter def celsius_to_fahrenheit(celsius): \"\"\" Convert a temperature from Celsius to Fahrenheit. Args: celsius (float): Temperature in degrees Celsius. Returns: float: Temperature in degrees Fahrenheit. \"\"\" return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit): \"\"\" Convert a temperature from Fahrenheit to Celsius. Args: fahrenheit (float): Temperature in degrees Fahrenheit. Returns: float: Temperature in degrees Celsius. \"\"\" return (fahrenheit - 32) * 5/9 # Test the functions celsius_temp = 25 fahrenheit_temp = celsius_to_fahrenheit(celsius_temp) print(f\"{celsius_temp}°C = {fahrenheit_temp:.1f}°F\") # Output: 25°C = 77.0°F fahrenheit_temp = 98.6 celsius_temp = fahrenheit_to_celsius(fahrenheit_temp) print(f\"{fahrenheit_temp}°F = {celsius_temp:.1f}°C\") # Output: 98.6°F = 37.0°C Example 2: Password Validator def validate_password(password): \"\"\" Validate a password based on several criteria. Args: password (str): The password to validate. Returns: tuple: (is_valid, message) where is_valid is a boolean and message describes why the password is invalid. \"\"\" # Check length if len(password) \u003c 8: return False, \"Password must be at least 8 characters long.\" # Check for uppercase letter if not any(char.isupper() for char in password): return False, \"Password must contain at least one uppercase letter.\" # Check for lowercase letter if not any(char.islower() for char in password): return False, \"Password must contain at least one lowercase letter.\" # Check for digit if not any(char.isdigit() for char in password): return False, \"Password must contain at least one digit.\" # Check for special character special_chars = \"!@#$%^\u0026*()-_=+[]{}|;:'\\\",.\u003c\u003e/?\" if not any(char in special_chars for char in password): return False, \"Password must contain at least one special character.\" # All checks passed return True, \"Password is valid.\" # Test the function passwords = [ \"password\", \"Password\", \"Password1\", \"Password1!\", ] for pwd in passwords: is_valid, message = validate_password(pwd) print(f\"Password: {pwd}\") print(f\"Valid: {is_valid}\") print(f\"Message: {message}\") print(\"-\" * 30) # Output: # Password: password # Valid: False # Message: Password must contain at least one uppercase letter. # ------------------------------ # Password: Password # Valid: False # Message: Password must contain at least one digit. # ------------------------------ # Password: Password1 # Valid: False # Message: Password must contain at least one special character. # ------------------------------ # Password: Password1! # Valid: True # Message: Password is valid. # ------------------------------ Example 3: Statistical Calculator def calculate_statistics(numbers): \"\"\" Calculate various statistics for a list of numbers. Args: numbers (list): A list of numbers. Returns: dict: A dictionary containing various statistics. \"\"\" if not numbers: return { \"count\": 0, \"sum\": 0, \"mean\": None, \"median\": None, \"min\": None, \"max\": None, \"range\": None, \"variance\": None, \"std_dev\": None } # Basic statistics count = len(numbers) total = sum(numbers) mean = total / count minimum = min(numbers) maximum = max(numbers) range_value = maximum - minimum # Calculate median sorted_numbers = sorted(numbers) if count % 2 == 0: # Even number of elements middle1 = sorted_numbers[count // 2 - 1] middle2 = sorted_numbers[count // 2] median = (middle1 + middle2) / 2 else: # Odd number of elements median = sorted_numbers[count // 2] # Calculate variance and standard deviation squared_diff_sum = sum((x - mean) ** 2 for x in numbers) variance = squared_diff_sum / count std_dev = variance ** 0.5 # Return all statistics as a dictionary return { \"count\": count, \"sum\": total, \"mean\": mean, \"median\": median, \"min\": minimum, \"max\": maximum, \"range\": range_value, \"variance\": variance, \"std_dev\": std_dev } # Test the function test_data = [4, 8, 15, 16, 23, 42] stats = calculate_statistics(test_data) print(\"Statistical Analysis\") print(\"-------------------\") for key, value in stats.items(): if isinstance(value, float): print(f\"{key}: {value:.2f}\") else: print(f\"{key}: {value}\") # Output: # Statistical Analysis # ------------------- # count: 6 # sum: 108 # mean: 18.00 # median: 15.50 # min: 4 # max: 42 # range: 38 # variance: 178.00 # std_dev: 13.34 ","recursive-functions#Recursive Functions":"A recursive function is one that calls itself:\ndef factorial(n): \"\"\" Calculate the factorial of a number using recursion. Args: n (int): A non-negative integer. Returns: int: The factorial of n. \"\"\" # Base case if n == 0 or n == 1: return 1 # Recursive case return n * factorial(n - 1) # Test the function for i in range(6): print(f\"{i}! = {factorial(i)}\") # Output: # 0! = 1 # 1! = 1 # 2! = 2 # 3! = 6 # 4! = 24 # 5! = 120 Every recursive function needs at least one base case to prevent infinite recursion.\nNote: While recursion can lead to elegant solutions for some problems, it’s often less efficient than iterative approaches in Python due to the overhead of function calls. Additionally, Python has a default recursion limit (usually 1000) to prevent stack overflow.","returning-multiple-values#Returning Multiple Values":"Python functions can return multiple values using tuples:\ndef min_max(numbers): \"\"\"Find the minimum and maximum values in a list.\"\"\" return min(numbers), max(numbers) # Unpacking the returned values minimum, maximum = min_max([5, 3, 8, 1, 9, 2]) print(f\"Minimum: {minimum}, Maximum: {maximum}\") # Output: Minimum: 1, Maximum: 9 # Or get the result as a tuple result = min_max([5, 3, 8, 1, 9, 2]) print(f\"Result tuple: {result}\") # Output: Result tuple: (1, 9) ","the-return-statement#The \u003ccode\u003ereturn\u003c/code\u003e Statement":"Functions are reusable blocks of code designed to perform a specific task. They allow you to organize your code, make it more readable, and avoid repetition. In this section, we’ll learn how to define and call functions in Python.\nWhy Use Functions? Before diving into the syntax, let’s understand why functions are essential in programming:\nCode Reusability: Write once, use many times Modularity: Break complex problems into smaller, manageable pieces Abstraction: Hide complex implementation details Organization: Make code more readable and maintainable Testing: Test individual components independently Basic Function Syntax The basic syntax for defining a function in Python is:\ndef function_name(parameters): \"\"\"Docstring describing the function.\"\"\" # Function body # Code to execute return value # Optional return statement Let’s break down each part:\ndef is the keyword used to declare a function function_name is the name of the function (follows variable naming rules) parameters are inputs the function can accept (optional) The function body is indented code block that runs when the function is called return statement specifies what value the function outputs (optional) Defining and Calling a Simple Function Here’s a simple function that prints a greeting:\ndef greet(): \"\"\"Print a simple greeting message.\"\"\" print(\"Hello, World!\") # Calling the function greet() # Output: Hello, World! To call (or execute) a function, write the function name followed by parentheses.\nFunctions with Parameters Parameters allow functions to accept input values:\ndef greet_person(name): \"\"\"Greet a person by name.\"\"\" print(f\"Hello, {name}!\") # Calling the function with an argument greet_person(\"Alice\") # Output: Hello, Alice! greet_person(\"Bob\") # Output: Hello, Bob! In this example, name is a parameter that receives the value passed when the function is called. The value passed during the function call (“Alice” or “Bob”) is called an argument.\nFunctions with Multiple Parameters Functions can accept multiple parameters:\ndef describe_person(name, age, occupation): \"\"\"Print a description of a person.\"\"\" print(f\"{name} is {age} years old and works as a {occupation}.\") # Calling with positional arguments describe_person(\"Alice\", 30, \"engineer\") # Output: Alice is 30 years old and works as a engineer. # Calling with keyword arguments describe_person(age=25, name=\"Bob\", occupation=\"teacher\") # Output: Bob is 25 years old and works as a teacher. As shown above, there are two ways to pass arguments to a function:\nPositional arguments: Values are matched to parameters by position Keyword arguments: Values are matched to parameters by name Default Parameter Values You can provide default values for parameters, which are used when an argument is not provided:\ndef greet_with_message(name, message=\"Hello\"): \"\"\"Greet a person with a customizable message.\"\"\" print(f\"{message}, {name}!\") # Using the default message greet_with_message(\"Alice\") # Output: Hello, Alice! # Providing a custom message greet_with_message(\"Bob\", \"Good morning\") # Output: Good morning, Bob! Important: Parameters with default values must come after parameters without default values in the function definition. This is because Python matches positional arguments first.\n# Correct def function(a, b, c=10, d=20): pass # Incorrect - will raise a SyntaxError def function(a, b=10, c, d=20): pass The return Statement Functions can send values back to the caller using the return statement:\ndef add_numbers(a, b): \"\"\"Add two numbers and return the result.\"\"\" sum_result = a + b return sum_result # Calling the function and storing the result result = add_numbers(5, 3) print(f\"The sum is: {result}\") # Output: The sum is: 8 # Using the return value directly print(f\"10 + 20 = {add_numbers(10, 20)}\") # Output: 10 + 20 = 30 A function without an explicit return statement automatically returns None:\ndef no_return(): \"\"\"This function doesn't return anything explicitly.\"\"\" print(\"Function executed!\") result = no_return() print(f\"Return value: {result}\") # Output: # Function executed! # Return value: None ","type-hints-python-35#Type Hints (Python 3.5+)":"Type hints are annotations that specify the expected types of function parameters and return values:\ndef greet(name: str, age: int) -\u003e str: \"\"\" Create a greeting based on name and age. Args: name: The person's name. age: The person's age. Returns: A greeting message. \"\"\" return f\"Hello {name}, you are {age} years old!\" # The function still works with any types result = greet(\"Alice\", 30) print(result) # Output: Hello Alice, you are 30 years old! Type hints don’t enforce types at runtime but serve as documentation and can be used by linters, IDEs, and type checkers like mypy to catch potential bugs.","unpacking-arguments#Unpacking Arguments":"You can unpack a list or tuple into positional arguments using the * operator:\ndef add(a, b, c): \"\"\"Add three numbers.\"\"\" return a + b + c numbers = [1, 2, 3] result = add(*numbers) # Equivalent to add(1, 2, 3) print(result) # Output: 6 Similarly, you can unpack a dictionary into keyword arguments using the ** operator:\ndef create_person(name, age, occupation): \"\"\"Create a person dictionary.\"\"\" return f\"{name} is a {age}-year-old {occupation}.\" person_data = { \"name\": \"Alice\", \"age\": 28, \"occupation\": \"developer\" } result = create_person(**person_data) # Equivalent to create_person(name=\"Alice\", age=28, occupation=\"developer\") print(result) # Output: Alice is a 28-year-old developer. ","variable-scope-in-functions#Variable Scope in Functions":"Variables defined inside a function have a local scope, meaning they only exist within the function:\ndef demonstrate_scope(): \"\"\"Show variable scope in a function.\"\"\" local_variable = \"I'm local to this function\" print(local_variable) demonstrate_scope() # Output: I'm local to this function # This will raise a NameError try: print(local_variable) except NameError as e: print(f\"Error: {e}\") # Output: Error: name 'local_variable' is not defined Variables defined outside functions have a global scope and can be accessed inside functions:\nglobal_variable = \"I'm a global variable\" def print_global(): \"\"\"Access a global variable.\"\"\" print(global_variable) print_global() # Output: I'm a global variable However, trying to modify a global variable inside a function requires the global keyword:\ncounter = 0 def increment_without_global(): \"\"\"Try to increment the counter without global keyword.\"\"\" # This creates a new local variable instead of modifying the global one counter = counter + 1 # This will raise an UnboundLocalError def increment_with_global(): \"\"\"Increment the counter using the global keyword.\"\"\" global counter counter = counter + 1 # This will raise an error try: increment_without_global() except UnboundLocalError as e: print(f\"Error: {e}\") # This works correctly increment_with_global() print(f\"Counter: {counter}\") # Output: Counter: 1 ","why-use-functions#Why Use Functions?":""},"title":"Defining and calling functions"},"/python-fundamentals/04-functions/02-parameters-and-arguments/":{"data":{"":"","basic-parameter-passing#Basic Parameter Passing":"","common-mistakes-and-best-practices#Common Mistakes and Best Practices":"1. Mutable Default Arguments As mentioned earlier, using mutable objects as default values can lead to unexpected behavior:\n# Problematic def append_to(element, target=[]): target.append(element) return target # Better def append_to(element, target=None): if target is None: target = [] target.append(element) return target 2. Too Many Parameters Functions with many parameters can be hard to use correctly:\n# Hard to use correctly def create_user(name, email, password, age, country, city, address, phone, role): # Function body... # Better: Use a dictionary or a class def create_user(user_data): # Access user_data[\"name\"], user_data[\"email\"], etc. 3. Mixing Positional and Keyword Arguments Positional arguments must come before keyword arguments:\n# This will cause a syntax error # func(a=1, 2, 3) # Correct func(2, 3, a=1) 4. Unclear Parameter Names Choose clear, descriptive parameter names:\n# Unclear def process(x, y, z): # Function body... # Clearer def calculate_total(price, quantity, tax_rate): # Function body... 5. Missing Documentation Always document your function’s parameters, especially when they have special meanings or constraints:\ndef divide(a, b): \"\"\" Divide a by b. Args: a (float): The dividend b (float): The divisor, must not be zero Returns: float: The result of the division Raises: ZeroDivisionError: If b is zero \"\"\" return a / b 6. Not Using Keyword Arguments for Clarity When a function has many parameters, use keyword arguments for clarity:\n# Hard to understand at a glance plot_data(data, True, False, 3, 'r', 2.0) # Much clearer plot_data( data=data, show_grid=True, include_legend=False, line_width=3, color='r', marker_size=2.0 ) ","default-parameter-values#Default Parameter Values":"","exercises#Exercises":"Exercise 1: Write a function called calculate_total that takes a base price and an optional tax rate (default to 0.1 or 10%). The function should return the total price including tax.\nExercise 2: Create a function print_info that takes a name parameter and any number of additional keyword arguments. The function should print the name and then all the additional information provided.\nExercise 3: Implement a function filter_numbers that takes a list of numbers and any number of filtering functions. The function should return a new list containing only numbers that pass all the filtering functions. For example, filtering functions might check if a number is even, positive, or a multiple of 3.\nExercise 4: Create a function create_html_element that generates an HTML tag. It should take the tag name, content, and any number of attributes as keyword arguments. For example, create_html_element(\"a\", \"Click me\", href=\"https://example.com\", class=\"button\") should return \u003ca href=\"https://example.com\" class=\"button\"\u003eClick me\u003c/a\u003e.\nHint for Exercise 1:\ndef calculate_total(base_price, tax_rate=0.1): \"\"\" Calculate the total price including tax. Args: base_price (float): The price before tax tax_rate (float, optional): The tax rate as a decimal. Defaults to 0.1 (10%). Returns: float: The total price including tax \"\"\" return base_price * (1 + tax_rate) In the next section, we’ll explore return statements in Python functions, including how to return multiple values and how to handle early returns for better control flow.","keyword-arguments#Keyword Arguments":"","keyword-only-and-positional-only-parameters-python-38#Keyword-Only and Positional-Only Parameters (Python 3.8+)":"Python 3.8 introduced explicit syntax for specifying positional-only and keyword-only parameters:\nKeyword-Only Parameters Use an asterisk (*) in the parameter list to indicate that subsequent parameters must be specified by keyword:\ndef process_data(data_id, *, format=\"json\", encoding=\"utf-8\"): \"\"\" Process data with the given ID. Parameters after * must be provided as keyword arguments. \"\"\" print(f\"Processing data {data_id} in {format} format with {encoding} encoding\") # Valid calls process_data(42, format=\"xml\") process_data(42, encoding=\"ascii\") # Invalid call - would raise a TypeError # process_data(42, \"xml\") # format must be a keyword argument Positional-Only Parameters Use a slash (/) in the parameter list to indicate that preceding parameters can only be specified positionally:\ndef divide(a, b, /, c=1): \"\"\" Divide a by b and then by c. Parameters before / must be provided positionally. \"\"\" return (a / b) / c # Valid calls divide(10, 2) # a=10, b=2, c=1 (default) divide(10, 2, c=2) # a=10, b=2, c=2 # Invalid calls - would raise a TypeError # divide(a=10, b=2) # a and b must be positional # divide(10, b=2) # b must be positional ","multiple-parameters#Multiple Parameters":"","parameter-type-annotations#Parameter Type Annotations":"Python supports type annotations to indicate the expected types of parameters and return values (though these are not enforced at runtime):\ndef greet(name: str, age: int) -\u003e str: \"\"\" Greet a person by name and mention their age. Parameters: name (str): The person's name age (int): The person's age Returns: str: A greeting message \"\"\" return f\"Hello, {name}! You are {age} years old.\" message = greet(\"Alice\", 30) print(message) # \"Hello, Alice! You are 30 years old.\" Type annotations provide documentation and can be used by static type checkers like mypy, but Python itself does not enforce these types at runtime.","practical-examples#Practical Examples":"Example 1: Flexible Formatting Function def format_name(first, last, middle=None, title=None): \"\"\" Format a person's name with optional middle name and title. Args: first (str): First name last (str): Last name middle (str, optional): Middle name or initial title (str, optional): Title (e.g., \"Dr.\", \"Mr.\", \"Ms.\") Returns: str: Formatted full name \"\"\" parts = [] if title: parts.append(title) parts.append(first) if middle: parts.append(middle) parts.append(last) return \" \".join(parts) # Example usage print(format_name(\"John\", \"Smith\")) # \"John Smith\" print(format_name(\"Jane\", \"Doe\", \"Marie\")) # \"Jane Marie Doe\" print(format_name(\"James\", \"Brown\", title=\"Dr.\")) # \"Dr. James Brown\" print(format_name(\"Emily\", \"Johnson\", \"A.\", \"Prof.\")) # \"Prof. Emily A. Johnson\" Example 2: Flexible Data Processor def process_data(data, *operations, **config): \"\"\" Process data with multiple operations and configuration options. Args: data: The data to process *operations: Functions to apply to the data in sequence **config: Configuration options for processing Returns: The processed data \"\"\" result = data # Apply each operation in sequence for operation in operations: result = operation(result) # Apply configuration-specific processing if config.get(\"uppercase\", False) and isinstance(result, str): result = result.upper() if config.get(\"round_digits\") is not None and isinstance(result, float): result = round(result, config[\"round_digits\"]) return result # Example usage def double(x): return x * 2 def add_10(x): return x + 10 def square(x): return x ** 2 # Process a number with multiple operations result1 = process_data(5, double, add_10, square) print(result1) # (5*2+10)^2 = 400 # Process with configuration result2 = process_data(3.14159, round_digits=2) print(result2) # 3.14 # Process a string result3 = process_data(\"hello\", uppercase=True) print(result3) # \"HELLO\" Example 3: Command-Line Argument Parser def parse_command(command, *args, **kwargs): \"\"\" Parse a command with various arguments and options. Args: command (str): The command to execute *args: Positional arguments for the command **kwargs: Named options for the command Returns: str: A description of the command to be executed \"\"\" # Start building the command description command_str = f\"Executing command '{command}'\" # Add positional arguments if args: args_str = \" \".join(str(arg) for arg in args) command_str += f\" with arguments: {args_str}\" # Add named options if kwargs: options = [] for key, value in kwargs.items(): options.append(f\"--{key}={value}\") options_str = \" \".join(options) command_str += f\" with options: {options_str}\" return command_str # Example usage print(parse_command(\"copy\", \"file1.txt\", \"file2.txt\")) # \"Executing command 'copy' with arguments: file1.txt file2.txt\" print(parse_command(\"search\", \"pattern\", recursive=True, ignore_case=True)) # \"Executing command 'search' with arguments: pattern with options: --recursive=True --ignore_case=True\" ","unpacking-arguments#Unpacking Arguments":"You can also unpack collections into individual arguments:\nUnpacking a List/Tuple into Positional Arguments Use the * operator to unpack a list or tuple into positional arguments:\ndef add(a, b, c): return a + b + c numbers = [1, 2, 3] print(add(*numbers)) # Equivalent to add(1, 2, 3) Unpacking a Dictionary into Keyword Arguments Use the ** operator to unpack a dictionary into keyword arguments:\ndef describe_person(name, age, profession): print(f\"{name} is {age} years old and works as a {profession}.\") person = { \"name\": \"Alice\", \"age\": 30, \"profession\": \"software engineer\" } describe_person(**person) # Equivalent to describe_person(name=\"Alice\", age=30, profession=\"software engineer\") ","variable-length-arguments-args-and-kwargs#Variable-Length Arguments: \u003ccode\u003e*args\u003c/code\u003e and \u003ccode\u003e**kwargs\u003c/code\u003e":"In functions, parameters and arguments allow you to pass information into a function to make it more flexible and reusable. While the terms “parameter” and “argument” are often used interchangeably, there is a technical distinction:\nParameters are the variables listed in the function definition. Arguments are the actual values passed to the function when it is called. Let’s explore the different ways Python handles parameters and arguments.\nBasic Parameter Passing In its simplest form, a function can accept parameters that you define in the function header:\ndef greet(name): # 'name' is a parameter \"\"\"Greet a person by name.\"\"\" print(f\"Hello, {name}!\") # Calling the function greet(\"Alice\") # \"Alice\" is an argument greet(\"Bob\") # \"Bob\" is an argument In this example, name is a parameter of the greet function, and \"Alice\" and \"Bob\" are arguments passed to that parameter when the function is called.\nMultiple Parameters Functions can accept multiple parameters, separated by commas:\ndef describe_person(name, age, profession): \"\"\"Describe a person using their details.\"\"\" print(f\"{name} is {age} years old and works as a {profession}.\") # Calling the function with positional arguments describe_person(\"Alice\", 30, \"software engineer\") describe_person(\"Bob\", 25, \"teacher\") When calling a function with multiple parameters, the order of the arguments matters. The first argument is assigned to the first parameter, the second argument to the second parameter, and so on.\nDefault Parameter Values You can assign default values to parameters, which are used when an argument is not provided:\ndef greet(name, greeting=\"Hello\"): \"\"\"Greet a person with an optional custom greeting.\"\"\" print(f\"{greeting}, {name}!\") # Calling the function greet(\"Alice\") # Uses default greeting greet(\"Bob\", \"Good morning\") # Uses custom greeting In this example, if greeting is not provided, it defaults to \"Hello\". Parameters with default values must come after parameters without default values in the function definition.\nImportant: Default values are evaluated only once, at function definition time. This can lead to unexpected behavior if you use a mutable object (like a list or dictionary) as a default value:\ndef add_item(item, items=[]): # Problematic default value items.append(item) return items print(add_item(\"apple\")) # ['apple'] print(add_item(\"banana\")) # ['apple', 'banana'] - Not a new empty list! To avoid this issue, use None as the default and create the mutable object inside the function:\ndef add_item(item, items=None): # Better approach if items is None: items = [] # Create a new list each time items.append(item) return items print(add_item(\"apple\")) # ['apple'] print(add_item(\"banana\")) # ['banana'] - A new empty list Keyword Arguments Keyword arguments allow you to specify which parameter each argument corresponds to by name, regardless of their order:\ndef describe_person(name, age, profession): \"\"\"Describe a person using their details.\"\"\" print(f\"{name} is {age} years old and works as a {profession}.\") # Using keyword arguments describe_person(name=\"Alice\", age=30, profession=\"software engineer\") describe_person(profession=\"teacher\", name=\"Bob\", age=25) # Different order Keyword arguments make your function calls more readable, especially when a function has many parameters or when the purpose of an argument isn’t obvious from its value alone.\nYou can mix positional and keyword arguments, but positional arguments must come before any keyword arguments:\n# Mixing positional and keyword arguments describe_person(\"Charlie\", profession=\"doctor\", age=35) # Valid # This would cause an error: # describe_person(name=\"David\", 40, \"lawyer\") # SyntaxError: positional argument follows keyword argument Variable-Length Arguments: *args and **kwargs Python provides two special parameters that allow functions to accept a variable number of arguments:\n*args (Variable Positional Arguments) The *args parameter collects any additional positional arguments into a tuple:\ndef sum_all(*args): \"\"\"Sum all the numbers provided as arguments.\"\"\" total = 0 for num in args: total += num return total # Calling the function with different numbers of arguments print(sum_all(1, 2)) # 3 print(sum_all(1, 2, 3, 4, 5)) # 15 print(sum_all()) # 0 You can use any name instead of args, but the asterisk (*) is required:\ndef print_all(*values): for value in values: print(value) You can also use *args in combination with regular parameters, but *args must come after all regular positional parameters:\ndef greet_multiple(greeting, *names): \"\"\"Greet multiple people with the same greeting.\"\"\" for name in names: print(f\"{greeting}, {name}!\") greet_multiple(\"Hello\", \"Alice\", \"Bob\", \"Charlie\") # Hello, Alice! # Hello, Bob! # Hello, Charlie! **kwargs (Variable Keyword Arguments) The **kwargs parameter collects any additional keyword arguments into a dictionary:\ndef create_profile(**kwargs): \"\"\"Create a user profile with provided attributes.\"\"\" print(\"Profile created with these attributes:\") for key, value in kwargs.items(): print(f\" {key}: {value}\") # Calling the function with keyword arguments create_profile(name=\"Alice\", age=30, email=\"alice@example.com\", country=\"USA\") # Profile created with these attributes: # name: Alice # age: 30 # email: alice@example.com # country: USA As with *args, you can use any name instead of kwargs, but the double asterisk (**) is required.\nYou can combine regular parameters, *args, and **kwargs in a single function, but they must appear in that specific order:\ndef example_function(a, b, *args, **kwargs): print(f\"a: {a}\") print(f\"b: {b}\") print(f\"args: {args}\") print(f\"kwargs: {kwargs}\") example_function(1, 2, 3, 4, 5, x=10, y=20) # a: 1 # b: 2 # args: (3, 4, 5) # kwargs: {'x': 10, 'y': 20} "},"title":"Parameters and Arguments"},"/python-fundamentals/04-functions/03-return-statements/":{"data":{"":"The return statement is a fundamental part of functions in Python. It allows a function to send a value back to the code that called it, making functions truly useful for computation and data processing.","basic-return-statement#Basic Return Statement":"A return statement consists of the keyword return followed by an optional expression:\ndef add(a, b): \"\"\"Add two numbers and return the result.\"\"\" result = a + b return result # Call the function and store the returned value sum_result = add(5, 3) print(sum_result) # Output: 8 In this example, the add function computes the sum of two numbers and returns it. The caller (the code that calls the function) can then use this returned value.","best-practices-for-return-statements#Best Practices for Return Statements":"1. Be Consistent with Return Types Try to ensure that a function returns the same type of value for all execution paths:\n# Inconsistent returns (not recommended) def process_number(num): if num \u003e 0: return num * 2 elif num \u003c 0: return str(num) + \" is negative\" # Returns a string! else: return 0 # Consistent returns (better) def process_number(num): if num \u003e 0: return num * 2 elif num \u003c 0: return -1 # Consistent numeric return with a special value else: return 0 2. Document Return Values Always document what your function returns, especially if it’s not obvious:\ndef calculate_score(answers, correct_answers): \"\"\" Calculate a test score based on answers. Args: answers (list): The user's answers correct_answers (list): The correct answers Returns: float: A score from 0.0 to 100.0 representing the percentage of correct answers \"\"\" # Implementation 3. Use Early Returns for Readability Early returns can make your code cleaner by handling edge cases first:\n# Without early returns (more nested) def process_order(order): if order is not None: if \"items\" in order: if len(order[\"items\"]) \u003e 0: # Process the order return True else: return False else: return False else: return False # With early returns (cleaner) def process_order(order): if order is None: return False if \"items\" not in order: return False if len(order[\"items\"]) == 0: return False # Process the order return True 4. Avoid Returning Excessive Values Return only what is necessary. If a function returns too many values, consider restructuring it or using a class or a data structure:\n# Too many return values (not recommended) def analyze_text(text): return word_count, char_count, line_count, sentence_count, uppercase_count, lowercase_count # Better approach using a data structure def analyze_text(text): analysis = { \"word_count\": count_words(text), \"char_count\": len(text), \"line_count\": text.count('\\n') + 1, \"sentence_count\": count_sentences(text), \"uppercase_count\": sum(1 for c in text if c.isupper()), \"lowercase_count\": sum(1 for c in text if c.islower()) } return analysis ","common-mistakes-with-return-statements#Common Mistakes with Return Statements":"1. Forgetting to Return a Value # Function doesn't return anything explicitly def calculate_area(radius): area = 3.14159 * radius ** 2 # No return statement! # The caller gets None result = calculate_area(5) print(result) # Output: None 2. Unreachable Code After Return def process_data(data): if data: return data.upper() print(\"Data processed!\") # This line never executes! return None result = process_data(\"hello\") # \"Data processed!\" is never printed 3. Confusing Return and Print # This function prints but doesn't return a value def add_numbers(a, b): print(a + b) # This prints but doesn't return # This function returns but doesn't print def multiply_numbers(a, b): return a * b # This returns but doesn't print # Using the functions result1 = add_numbers(3, 4) # Prints: 7 print(result1) # Prints: None (function doesn't return anything) result2 = multiply_numbers(3, 4) # Doesn't print anything print(result2) # Prints: 12 (value returned by the function) 4. Inconsistent Return Types def get_age_category(age): if age \u003c 18: return \"minor\" elif age \u003c 65: return \"adult\" else: # Inconsistent return type! Returns a number instead of a string return 65 # Should be \"senior\" to be consistent 5. Missing Return in Some Execution Paths def divide(a, b): if b != 0: return a / b # Missing return for the b == 0 case! # This function implicitly returns None when b is 0 # Better version def divide(a, b): if b != 0: return a / b else: return None # Explicit return for all paths ","early-returns#Early Returns":"A function can have multiple return statements. When a return statement is executed, the function immediately exits, regardless of any remaining code:\ndef check_even_odd(number): \"\"\"Check if a number is even or odd.\"\"\" if number % 2 == 0: return \"Even\" return \"Odd\" print(check_even_odd(4)) # Output: Even print(check_even_odd(7)) # Output: Odd Early returns are useful for handling special cases or for making code more readable by avoiding deep nesting:\ndef divide_safely(a, b): \"\"\"Divide a by b, handling division by zero.\"\"\" # Early return for the special case if b == 0: return \"Cannot divide by zero\" # Regular case return a / b print(divide_safely(10, 2)) # Output: 5.0 print(divide_safely(10, 0)) # Output: Cannot divide by zero ","exercises#Exercises":"Exercise 1: Write a function called calculate_bmi that takes a person’s weight (in kilograms) and height (in meters) as input and returns their Body Mass Index (BMI). The formula for BMI is: weight / (height * height).\nExercise 2: Create a function called get_grade that takes a student’s score as input (0-100) and returns their letter grade according to the following scale:\n90-100: “A” 80-89: “B” 70-79: “C” 60-69: “D” Below 60: “F” Exercise 3: Write a function called find_common_elements that takes two lists as input and returns a new list containing only the elements that appear in both lists.\nExercise 4: Create a function called is_palindrome that takes a string as input and returns True if the string is a palindrome (reads the same forward and backward), and False otherwise. Ignore case and non-alphanumeric characters in your comparison.\nHint for Exercise 1: Make sure to handle potential errors, such as if the height is zero or negative.\ndef calculate_bmi(weight, height): # Input validation if weight \u003c= 0 or height \u003c= 0: return None # Invalid input # Calculate BMI bmi = weight / (height ** 2) return bmi In the next section, we’ll explore variable scope in Python, which determines where variables are accessible within your program.","practical-examples#Practical Examples":"Example 1: Finding Prime Numbers def is_prime(number): \"\"\" Check if a number is prime. Args: number (int): The number to check Returns: bool: True if the number is prime, False otherwise \"\"\" # Handle special cases if number \u003c= 1: return False if number \u003c= 3: return True if number % 2 == 0 or number % 3 == 0: return False # Check divisibility by numbers of the form 6k±1 i = 5 while i * i \u003c= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start, end): \"\"\" Find all prime numbers in a given range. Args: start (int): The start of the range end (int): The end of the range Returns: list: A list of all prime numbers in the range [start, end] \"\"\" primes = [] for number in range(max(2, start), end + 1): if is_prime(number): primes.append(number) return primes # Find primes between 10 and 50 prime_list = find_primes_in_range(10, 50) print(f\"Prime numbers between 10 and 50: {prime_list}\") Example 2: Temperature Converter def celsius_to_fahrenheit(celsius): \"\"\" Convert temperature from Celsius to Fahrenheit. Args: celsius (float): Temperature in Celsius Returns: float: Temperature in Fahrenheit \"\"\" return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit): \"\"\" Convert temperature from Fahrenheit to Celsius. Args: fahrenheit (float): Temperature in Fahrenheit Returns: float: Temperature in Celsius \"\"\" return (fahrenheit - 32) * 5/9 def convert_temperature(temp, source_unit): \"\"\" Convert temperature between Celsius and Fahrenheit. Args: temp (float): The temperature value to convert source_unit (str): The source unit ('C' for Celsius, 'F' for Fahrenheit) Returns: tuple: A tuple containing: - float: The converted temperature value - str: The target unit ('F' for Fahrenheit, 'C' for Celsius) \"\"\" if source_unit.upper() == 'C': return celsius_to_fahrenheit(temp), 'F' elif source_unit.upper() == 'F': return fahrenheit_to_celsius(temp), 'C' else: return None, None # Test the converter temp_c = 25 converted_temp, target_unit = convert_temperature(temp_c, 'C') print(f\"{temp_c}°C = {converted_temp:.1f}°{target_unit}\") # Output: 25°C = 77.0°F temp_f = 98.6 converted_temp, target_unit = convert_temperature(temp_f, 'F') print(f\"{temp_f}°F = {converted_temp:.1f}°{target_unit}\") # Output: 98.6°F = 37.0°C Example 3: Password Validator def validate_password(password): \"\"\" Validate a password based on several criteria. Password criteria: - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character Args: password (str): The password to validate Returns: dict: A dictionary containing: - bool: 'valid' - True if the password meets all criteria, False otherwise - list: 'errors' - List of error messages for failed criteria \"\"\" errors = [] # Check length if len(password) \u003c 8: errors.append(\"Password must be at least 8 characters long\") # Check for uppercase letter if not any(char.isupper() for char in password): errors.append(\"Password must contain at least one uppercase letter\") # Check for lowercase letter if not any(char.islower() for char in password): errors.append(\"Password must contain at least one lowercase letter\") # Check for digit if not any(char.isdigit() for char in password): errors.append(\"Password must contain at least one digit\") # Check for special character special_chars = \"!@#$%^\u0026*()-_=+[]{}|;:'\\\",.\u003c\u003e/?\" if not any(char in special_chars for char in password): errors.append(\"Password must contain at least one special character\") # Determine if the password is valid is_valid = len(errors) == 0 # Return the validation result return { \"valid\": is_valid, \"errors\": errors } # Test the password validator passwords = [ \"password\", # Too simple \"Password1\", # Missing special character \"Abc123!\", # Too short \"SecurePass1!\", # Should be valid ] for pwd in passwords: result = validate_password(pwd) print(f\"Password: {pwd}\") if result[\"valid\"]: print(\"Valid! This password meets all criteria.\") else: print(\"Invalid! Errors:\") for error in result[\"errors\"]: print(f\"- {error}\") print() Example 4: Recursive Factorial Function def factorial(n): \"\"\" Calculate the factorial of a number using recursion. Args: n (int): The number to calculate factorial for Returns: int: The factorial of n (n!), or None for invalid inputs \"\"\" # Check for invalid input if not isinstance(n, int) or n \u003c 0: return None # Base case: 0! = 1 if n == 0: return 1 # Recursive case: n! = n * (n-1)! return n * factorial(n - 1) # Test the factorial function for i in range(6): print(f\"{i}! = {factorial(i)}\") # Output: # 0! = 1 # 1! = 1 # 2! = 2 # 3! = 6 # 4! = 24 # 5! = 120 ","return-type-annotations#Return Type Annotations":"Python supports optional type annotations that indicate what type of value a function returns:\ndef add(a: int, b: int) -\u003e int: \"\"\"Add two integers and return the result.\"\"\" return a + b def get_full_name(first: str, last: str) -\u003e str: \"\"\"Return the full name by combining first and last names.\"\"\" return f\"{first} {last}\" def is_adult(age: int) -\u003e bool: \"\"\"Check if the age corresponds to an adult (18 or older).\"\"\" return age \u003e= 18 Type annotations don’t affect the execution of the code but provide hints for developers and static analysis tools.","returning-functions#Returning Functions":"In Python, functions are first-class objects, which means you can return a function from another function:\ndef get_operation(operation_name): \"\"\"Return a mathematical function based on the operation name.\"\"\" def add(a, b): return a + b def subtract(a, b): return a - b def multiply(a, b): return a * b def divide(a, b): return a / b if b != 0 else \"Cannot divide by zero\" # Return the appropriate function if operation_name == \"add\": return add elif operation_name == \"subtract\": return subtract elif operation_name == \"multiply\": return multiply elif operation_name == \"divide\": return divide else: return None # Get a function and call it operation_func = get_operation(\"multiply\") if operation_func: result = operation_func(6, 7) print(result) # Output: 42 This is an example of a higher-order function (a function that returns another function) and is a powerful technique in functional programming.","returning-multiple-values#Returning Multiple Values":"Python allows functions to return multiple values by separating them with commas:\ndef calculate_statistics(numbers): \"\"\"Calculate the sum, average, and maximum value from a list of numbers.\"\"\" total = sum(numbers) average = total / len(numbers) maximum = max(numbers) return total, average, maximum # Call the function and unpack the returned values data = [10, 15, 20, 25, 30] sum_result, avg_result, max_result = calculate_statistics(data) print(f\"Sum: {sum_result}\") # Output: Sum: 100 print(f\"Average: {avg_result}\") # Output: Average: 20.0 print(f\"Maximum: {max_result}\") # Output: Maximum: 30 Behind the scenes, Python packs multiple return values into a tuple. You can also capture the returned values as a single tuple:\nstats = calculate_statistics(data) print(stats) # Output: (100, 20.0, 30) print(f\"Sum: {stats[0]}\") # Accessing tuple elements ","returning-none#Returning None":"If a function doesn’t explicitly return a value (or uses return without an expression), it implicitly returns None:\ndef greet(name): \"\"\"Greet a person without returning a value.\"\"\" print(f\"Hello, {name}!\") # No return statement result = greet(\"Alice\") # Output: Hello, Alice! print(result) # Output: None You can also explicitly return None to make your intention clear:\ndef process_data(data): \"\"\"Process data if it's valid.\"\"\" if not data: return None # Explicitly return None for invalid data # Process the data and return a result return data.upper() print(process_data(\"hello\")) # Output: HELLO print(process_data(\"\")) # Output: None Note: It’s a common practice to return None to indicate that a function couldn’t produce a meaningful result due to invalid inputs or error conditions."},"title":"Return Statements"},"/python-fundamentals/04-functions/04-variable-scope/":{"data":{"":"Variable scope refers to the region of a program where a variable is visible and can be accessed. Understanding variable scope is crucial for writing correct and maintainable Python code. Python has specific rules that determine where variables can be accessed and how long they exist during program execution.","best-practices-for-variable-scope#Best Practices for Variable Scope":" Limit the use of global variables\nPass data to functions through parameters Return data from functions using return values Keep functions small and focused\nFunctions should ideally do one thing well This naturally minimizes scope complexity Choose descriptive variable names\nEspecially important when scopes overlap Helps prevent confusion and bugs Use constants for values that don’t change\nDefine them at the module level Use ALL_CAPS naming convention Be explicit about scope with annotations\nUse global and nonlocal when needed Consider adding comments for clarity Be careful with mutable default arguments\nUse None as default and create the mutable object inside the function Consider using classes for complex state management\nClass attributes and instance attributes provide a cleaner way to manage state Methods automatically have access to instance attributes via self ","built-in-scope#Built-in Scope":"The broadest scope in Python is the built-in scope, which contains all the built-in functions and variables that are always available (like print(), len(), range(), etc.).","classes-and-variable-scope#Classes and Variable Scope":"When working with classes in Python, you’ll encounter additional scope considerations:\nclass MyClass: class_variable = \"I'm shared among all instances\" # Class variable def __init__(self, instance_var): self.instance_variable = instance_var # Instance variable def print_variables(self): print(f\"Class variable: {self.class_variable}\") print(f\"Instance variable: {self.instance_variable}\") local_var = \"I'm local to this method\" # Method-local variable print(f\"Local variable: {local_var}\") obj1 = MyClass(\"instance 1\") obj2 = MyClass(\"instance 2\") obj1.print_variables() # Output: # Class variable: I'm shared among all instances # Instance variable: instance 1 # Local variable: I'm local to this method obj2.print_variables() # Output: # Class variable: I'm shared among all instances # Instance variable: instance 2 # Local variable: I'm local to this method We’ll cover classes in much more detail in a later section.","common-pitfalls-with-variable-scope#Common Pitfalls with Variable Scope":"1. Forgetting to Use global or nonlocal count = 0 def increment(): # This creates a new local variable instead of modifying the global one count += 1 # UnboundLocalError: local variable 'count' referenced before assignment # Correct version def increment_correct(): global count count += 1 2. Shadowing Built-in Functions # This shadows the built-in sum function sum = 10 # Later, trying to use the built-in function will fail # numbers = [1, 2, 3] # total = sum(numbers) # TypeError: 'int' object is not callable # To fix, delete the variable or rename it del sum # or total_sum = 10 3. Unexpected Behavior with Mutable Default Arguments def append_to(element, to=[]): to.append(element) return to print(append_to(1)) # [1] print(append_to(2)) # [1, 2] - Might be unexpected! # The solution is to use None as the default and create a new list in the function def append_to_fixed(element, to=None): if to is None: to = [] to.append(element) return to print(append_to_fixed(1)) # [1] print(append_to_fixed(2)) # [2] - Each call gets a new list 4. Trying to Access Variables Before They Are Defined def example(): # This will raise an UnboundLocalError print(x) # Error: local variable 'x' referenced before assignment x = 10 # Variable needs to be defined before use def fixed_example(): x = 10 print(x) # Works fine 5. Confusing Local and Global Variables with the Same Name name = \"Global\" def print_name(): # This creates a new local variable, it doesn't use the global one name = \"Local\" print(f\"Inside function: {name}\") print_name() # Inside function: Local print(f\"Outside function: {name}\") # Outside function: Global ","default-arguments-and-variable-scope#Default Arguments and Variable Scope":"Default arguments are evaluated when the function is defined, not when it’s called. This can lead to surprising behavior if you use mutable objects as default values:\ndef add_to_list(item, my_list=[]): my_list.append(item) return my_list print(add_to_list(\"apple\")) # Output: ['apple'] print(add_to_list(\"banana\")) # Output: ['apple', 'banana'] - not a new list! The correct way to handle this is:\ndef add_to_list(item, my_list=None): if my_list is None: my_list = [] my_list.append(item) return my_list print(add_to_list(\"apple\")) # Output: ['apple'] print(add_to_list(\"banana\")) # Output: ['banana'] - a new list ","enclosing-nonlocal-scope#Enclosing (Nonlocal) Scope":"Python allows you to define functions inside other functions, creating nested functions. This introduces another scope level called the enclosing scope:\ndef outer_function(): outer_var = \"I'm in the outer function\" def inner_function(): print(outer_var) # Can access variables from the enclosing scope inner_function() outer_function() # Output: I'm in the outer function Similar to global variables, you need a special keyword to modify variables in the enclosing scope from within a nested function:\ndef counter_function(): count = 0 def increment(): nonlocal count # This tells Python we want to use the count from the enclosing scope count += 1 return count return increment # Return the inner function counter = counter_function() print(counter()) # Output: 1 print(counter()) # Output: 2 print(counter()) # Output: 3 This pattern is quite powerful and is the basis for closures in Python, which allow functions to remember values from their enclosing scope even after the outer function has finished execution.","exercises#Exercises":"Exercise 1: Write a function called create_multiplier that takes a number x and returns a function that multiplies its input by x. For example:\ndouble = create_multiplier(2) triple = create_multiplier(3) print(double(5)) # Should print 10 print(triple(5)) # Should print 15 Exercise 2: Create a function that counts how many times it has been called, using enclosing scope to maintain the count:\n# Your implementation here call_counter() # Should return 1 call_counter() # Should return 2 call_counter() # Should return 3 Exercise 3: Fix the following code so that it correctly modifies the global variable messages:\nmessages = [] def add_message(message): # This doesn't modify the global variable as intended messages.append(message) def clear_messages(): # This doesn't modify the global variable as intended messages = [] add_message(\"Hello\") print(messages) # Should be [\"Hello\"] add_message(\"World\") print(messages) # Should be [\"Hello\", \"World\"] clear_messages() print(messages) # Should be [] Hint for Exercise 1: Use a closure to capture the multiplier value in the enclosing scope of the returned function.\ndef create_multiplier(x): def multiplier(y): return x * y return multiplier In the next section, we’ll explore lambda functions, which are small anonymous functions defined with a more concise syntax than regular function definitions.","function-arguments-and-scope#Function Arguments and Scope":"Function arguments behave like local variables inside the function:\ndef greet(name): # name is a local variable within the greet function message = f\"Hello, {name}!\" # message is also a local variable print(message) greet(\"Alice\") # Output: Hello, Alice! # print(name) # This would cause a NameError ","global-constants#Global Constants":"While modifying global variables is generally discouraged, using global constants (values that don’t change) is perfectly acceptable:\n# Global constants (conventionally written in ALL_CAPS) PI = 3.14159 MAX_USERS = 100 DATABASE_URL = \"postgresql://user:password@localhost/dbname\" def calculate_circle_area(radius): return PI * (radius ** 2) def check_user_limit(current_users): return current_users \u003c MAX_USERS ","global-scope#Global Scope":"Variables defined outside of any function have a global scope, meaning they can be accessed from anywhere in the program:\n# y is a global variable y = 20 def print_global(): print(f\"Inside the function: y = {y}\") print_global() # Output: Inside the function: y = 20 print(f\"Outside the function: y = {y}\") # Output: Outside the function: y = 20 While you can access global variables from within a function, you cannot modify them without explicitly declaring them as global:\nz = 30 def modify_without_global(): # This creates a new local variable z, it doesn't modify the global z z = 40 print(f\"Inside function without global: z = {z}\") def modify_with_global(): global z # This tells Python we want to use the global variable z z = 50 print(f\"Inside function with global: z = {z}\") modify_without_global() # Output: Inside function without global: z = 40 print(f\"After first function: z = {z}\") # Output: After first function: z = 30 modify_with_global() # Output: Inside function with global: z = 50 print(f\"After second function: z = {z}\") # Output: After second function: z = 50 Important: It’s generally considered bad practice to rely heavily on global variables, especially in larger programs. They make code harder to understand, debug, and test because any part of the program can modify them.","local-scope#Local Scope":"Variables defined inside a function have a local scope, meaning they are only accessible within that function:\ndef my_function(): # x is a local variable x = 10 print(f\"Inside the function: x = {x}\") my_function() # Output: Inside the function: x = 10 # This will cause an error because x is not defined in this scope try: print(f\"Outside the function: x = {x}\") except NameError as e: print(f\"Error: {e}\") # Output: Error: name 'x' is not defined Local variables are created when the function is called and destroyed when the function exits. This means local variables don’t retain their values between function calls:\ndef counter(): count = 0 # Local variable initialized to 0 each time the function is called count += 1 return count print(counter()) # Output: 1 print(counter()) # Output: 1 (not 2, because count is re-initialized each time) ","modifying-global-and-nonlocal-variables#Modifying Global and Nonlocal Variables":"Here’s a comprehensive example of how to modify variables in different scopes:\nglobal_var = \"global\" def demonstrate_scopes(): enclosing_var = \"enclosing\" def modify_all(): global global_var nonlocal enclosing_var local_var = \"local\" # Modify all variables global_var = \"modified global\" enclosing_var = \"modified enclosing\" local_var = \"modified local\" print(f\"Inside nested function:\") print(f\"global_var: {global_var}\") print(f\"enclosing_var: {enclosing_var}\") print(f\"local_var: {local_var}\") print(f\"Before calling nested function:\") print(f\"global_var: {global_var}\") print(f\"enclosing_var: {enclosing_var}\") modify_all() print(f\"After calling nested function:\") print(f\"global_var: {global_var}\") print(f\"enclosing_var: {enclosing_var}\") demonstrate_scopes() print(f\"In global scope:\") print(f\"global_var: {global_var}\") # Output: # Before calling nested function: # global_var: global # enclosing_var: enclosing # Inside nested function: # global_var: modified global # enclosing_var: modified enclosing # local_var: modified local # After calling nested function: # global_var: modified global # enclosing_var: modified enclosing # In global scope: # global_var: modified global ","practical-examples#Practical Examples":"Example 1: Counter with Enclosing Scope def create_counter(start=0): \"\"\"Create a counter function that remembers its state.\"\"\" count = start def increment(step=1): nonlocal count count += step return count return increment # Create counters counter_a = create_counter() counter_b = create_counter(10) # Use counters print(counter_a()) # 1 print(counter_a()) # 2 print(counter_b()) # 11 print(counter_b()) # 12 print(counter_a()) # 3 (counter_a maintained its own state) Example 2: Configuration Manager def create_config_manager(): \"\"\"Create a configuration manager with get and set functions.\"\"\" # Private configuration dictionary config = {} def get_config(key, default=None): \"\"\"Get a configuration value.\"\"\" return config.get(key, default) def set_config(key, value): \"\"\"Set a configuration value.\"\"\" config[key] = value def clear_config(): \"\"\"Clear all configuration values.\"\"\" config.clear() # Return a dictionary of functions return { \"get\": get_config, \"set\": set_config, \"clear\": clear_config } # Create a configuration manager config_manager = create_config_manager() get_config = config_manager[\"get\"] set_config = config_manager[\"set\"] clear_config = config_manager[\"clear\"] # Use the configuration manager set_config(\"theme\", \"dark\") set_config(\"font_size\", 14) print(get_config(\"theme\")) # dark print(get_config(\"font_size\")) # 14 print(get_config(\"missing\", \"default\")) # default # Clear the configuration clear_config() print(get_config(\"theme\")) # None Example 3: Memoization with Closure Memoization is a technique to cache function results to avoid redundant calculations:\ndef memoize(func): \"\"\" Create a function that remembers the results of previous calls. Args: func: The function to memoize Returns: A memoized version of the function \"\"\" cache = {} def memoized_func(*args): if args in cache: return cache[args] result = func(*args) cache[args] = result return result return memoized_func # Example function to memoize def fibonacci(n): \"\"\"Calculate the nth Fibonacci number recursively.\"\"\" if n \u003c= 1: return n return fibonacci(n-1) + fibonacci(n-2) # Create a memoized version of fibonacci memoized_fibonacci = memoize(fibonacci) # Compare performance import time print(\"Without memoization:\") start = time.time() result = fibonacci(35) # This will take a while end = time.time() print(f\"Result: {result}, Time: {end - start:.2f} seconds\") print(\"\\nWith memoization:\") start = time.time() result = memoized_fibonacci(35) # This will be much faster end = time.time() print(f\"Result: {result}, Time: {end - start:.2f} seconds\") ","the-legb-rule#The LEGB Rule":"Python follows the LEGB rule to determine the order in which it looks up variable names:\nLocal: Variables defined within the current function Enclosing: Variables defined in the enclosing functions (if any) Global: Variables defined at the top level of the module or declared global Built-in: Names that are pre-defined in Python x = \"global\" # Global scope def outer(): x = \"enclosing\" # Enclosing scope def inner(): x = \"local\" # Local scope print(f\"inner: {x}\") inner() print(f\"outer: {x}\") outer() print(f\"global: {x}\") # Output: # inner: local # outer: enclosing # global: global ","variable-lifetime-vs-scope#Variable Lifetime vs. Scope":"It’s important to distinguish between variable scope and variable lifetime:\nScope refers to where in the code a variable can be accessed. Lifetime refers to how long the variable exists in memory during program execution. def create_counter(): count = 0 # Local variable def increment(): nonlocal count count += 1 return count return increment counter1 = create_counter() counter2 = create_counter() print(counter1()) # Output: 1 print(counter1()) # Output: 2 print(counter2()) # Output: 1 (separate count variable) In this example, even though count is a local variable in create_counter(), it continues to exist as long as the returned increment function exists because increment maintains a reference to it. This is called a “closure.”"},"title":"Variable Scope"},"/python-fundamentals/04-functions/05-lambda-functions/":{"data":{"":"","advantages-of-lambda-functions#Advantages of Lambda Functions":" Conciseness: Lambda functions allow you to write small functions in a compact way. Readability: For simple operations, lambdas can make code more readable by keeping the function definition close to where it’s used. Functional Programming: They facilitate functional programming patterns, working well with functions like map(), filter(), and reduce(). ","basic-syntax#Basic Syntax":"","best-practices-for-using-lambda-functions#Best Practices for Using Lambda Functions":" Keep It Simple: Use lambdas only for simple, one-line functions.\n# Good square = lambda x: x ** 2 # Bad (too complex for a lambda) complex_lambda = lambda x: x ** 2 if x \u003e 0 else \"negative\" if x \u003c 0 else \"zero\" Assign to a Variable When Reused: If you need to use the same lambda multiple times, assign it to a variable.\n# Reusable lambda is_even = lambda x: x % 2 == 0 numbers = [1, 2, 3, 4, 5, 6] even_numbers = list(filter(is_even, numbers)) Consider Regular Functions for Clarity: When a lambda becomes complex or needs documentation, use a regular function.\n# Better as a regular function def calculate_tax(price, tax_rate): \"\"\"Calculate the price after tax.\"\"\" return price * (1 + tax_rate) Use with Higher-Order Functions: Lambdas shine when used with functions like map(), filter(), sorted(), etc.\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"David\"] sorted_names = sorted(names, key=lambda name: len(name)) ","common-mistakes-with-lambda-functions#Common Mistakes with Lambda Functions":" Trying to Include Multiple Statements:\n# This will not work invalid_lambda = lambda x: print(x); return x * 2 # Use a regular function instead def process(x): print(x) return x * 2 Making Lambdas Too Complex:\n# Too complex for a lambda complex_lambda = lambda x: (x ** 2 if x % 2 == 0 else x ** 3) if x \u003e= 0 else -x # Better as a regular function def compute(x): if x \u003c 0: return -x elif x % 2 == 0: return x ** 2 else: return x ** 3 Not Understanding Closure Behavior:\n# This creates a common mistake in loops functions = [] for i in range(5): functions.append(lambda: i) # All functions will use the final value of i for f in functions: print(f()) # Prints 4, 4, 4, 4, 4 # Correct approach using default arguments functions = [] for i in range(5): functions.append(lambda i=i: i) for f in functions: print(f()) # Prints 0, 1, 2, 3, 4 ","default-arguments-in-lambda-functions#Default Arguments in Lambda Functions":"Lambda functions can also have default arguments:\n# Lambda with a default argument greet = lambda name, greeting=\"Hello\": f\"{greeting}, {name}!\" print(greet(\"Alice\")) # Output: Hello, Alice! print(greet(\"Bob\", \"Hi\")) # Output: Hi, Bob! ","exercises#Exercises":"Exercise 1: Write a lambda function that takes a string and returns its length. Use this function with map() to get the lengths of all strings in a list.\nstrings = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"] # Your code here Exercise 2: Create a lambda function that checks if a number is between 10 and 20 (inclusive). Use this function with filter() to get all numbers in that range from a list.\nnumbers = [5, 10, 15, 20, 25, 30] # Your code here Exercise 3: Write a function that returns a lambda function. The returned lambda should multiply its input by a value specified when creating the function.\n# Your function definition here # Test with: double = # Create a function that doubles the input triple = # Create a function that triples the input print(double(5)) # Should print 10 print(triple(5)) # Should print 15 Exercise 4: Use a lambda function as the key parameter in sorted() to sort a list of tuples representing people (name, age, height) by: a) Age (youngest to oldest) b) Height (tallest to shortest) c) Name length (shortest to longest)\npeople = [ (\"Alice\", 25, 165), (\"Bob\", 19, 180), (\"Charlie\", 32, 175), (\"David\", 27, 190) ] # Your sorting code here Hint for Exercise 1: The lambda function will take a parameter s and return len(s). Use this with map() to get a list of lengths.\n# Exercise 1 partial solution length_lambda = lambda s: len(s) lengths = list(map(length_lambda, strings)) In the next section, we’ll explore modules and packages in Python, which allow you to organize and reuse code effectively.","immediately-invoked-lambda-functions#Immediately Invoked Lambda Functions":"You can define and call a lambda function in one step:\n# Define and call in one step result = (lambda x, y: x + y)(5, 3) print(result) # Output: 8 This pattern is less common in Python than in some other languages, but it can be useful in specific situations.","lambda-functions-as-return-values#Lambda Functions as Return Values":"You can return lambda functions from other functions:\ndef power_function(n): return lambda x: x ** n square = power_function(2) cube = power_function(3) fourth_power = power_function(4) print(square(5)) # Output: 25 (5^2) print(cube(5)) # Output: 125 (5^3) print(fourth_power(5)) # Output: 625 (5^4) In this example, power_function() returns a lambda function that raises its argument to the power of n. We create three different functions for squaring, cubing, and raising to the fourth power.","lambda-functions-vs-regular-functions#Lambda Functions vs. Regular Functions":" Feature Lambda Functions Regular Functions Syntax lambda args: expression def name(args): body Named No (anonymous) Yes (has a name) Number of expressions One only Multiple Docstrings Not supported Supported Return statement Implicit (expression value) Explicit (using return) Complexity Simple operations Any complexity # Lambda function addition = lambda x, y: x + y # Equivalent regular function def addition(x, y): \"\"\"Add two numbers and return the result.\"\"\" return x + y ","lambda-functions-with-conditional-expressions#Lambda Functions with Conditional Expressions":"Lambda functions can include conditional expressions:\n# Lambda with a conditional expression is_adult = lambda age: \"Adult\" if age \u003e= 18 else \"Minor\" print(is_adult(20)) # Output: Adult print(is_adult(15)) # Output: Minor # More complex conditional grade = lambda score: \"A\" if score \u003e= 90 else (\"B\" if score \u003e= 80 else (\"C\" if score \u003e= 70 else (\"D\" if score \u003e= 60 else \"F\"))) print(grade(95)) # Output: A print(grade(85)) # Output: B print(grade(60)) # Output: D Note: While you can include conditional expressions in lambda functions, they should remain simple. If the logic becomes complex, it’s better to use a regular function with proper if-else statements for readability.","lambda-with-filter#Lambda with \u003ccode\u003efilter()\u003c/code\u003e":"","lambda-with-map#Lambda with \u003ccode\u003emap()\u003c/code\u003e":"","lambda-with-reduce#Lambda with \u003ccode\u003ereduce()\u003c/code\u003e":"Lambda functions, also known as anonymous functions, are small, unnamed functions defined with the lambda keyword. They provide a concise way to create simple functions without the need for a formal function definition using def.\nBasic Syntax The syntax for a lambda function is:\nlambda arguments: expression A lambda function can take any number of arguments but can only have one expression. The expression is evaluated and returned when the function is called.\n# Regular function definition def add(x, y): return x + y # Equivalent lambda function add_lambda = lambda x, y: x + y # Both functions work the same way print(add(5, 3)) # Output: 8 print(add_lambda(5, 3)) # Output: 8 Important: Lambda functions are limited to a single expression. They cannot contain multiple statements or complex logic that would require multiple lines of code.\nWhen to Use Lambda Functions Lambda functions are most useful in situations where:\nYou need a simple function for a short period You want to pass a function as an argument to another function You need to define a function inside another function Lambda functions are commonly used with higher-order functions like map(), filter(), and sorted().\nLambda with map() The map() function applies a function to each item in an iterable (like a list).\n# Using a regular function with map() def square(x): return x ** 2 numbers = [1, 2, 3, 4, 5] squared_numbers = list(map(square, numbers)) print(squared_numbers) # Output: [1, 4, 9, 16, 25] # Using a lambda function with map() squared_numbers_lambda = list(map(lambda x: x ** 2, numbers)) print(squared_numbers_lambda) # Output: [1, 4, 9, 16, 25] In this example, the lambda function lambda x: x ** 2 is applied to each element in the numbers list, creating a new list with the squared values.\nLambda with filter() The filter() function creates a new iterable with elements from the original iterable for which a function returns True.\n# Using a regular function with filter() def is_even(x): return x % 2 == 0 numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] even_numbers = list(filter(is_even, numbers)) print(even_numbers) # Output: [2, 4, 6, 8, 10] # Using a lambda function with filter() even_numbers_lambda = list(filter(lambda x: x % 2 == 0, numbers)) print(even_numbers_lambda) # Output: [2, 4, 6, 8, 10] Here, the lambda function lambda x: x % 2 == 0 tests each element in the numbers list and keeps only those that are even.\nLambda with sorted() The sorted() function returns a new sorted list from the elements of any iterable. You can use a lambda function as the key parameter to customize the sorting logic.\n# List of tuples (name, age) people = [ (\"Alice\", 25), (\"Bob\", 19), (\"Charlie\", 32), (\"David\", 27) ] # Sort by name (first element in each tuple) sorted_by_name = sorted(people) print(sorted_by_name) # Sorts by the first element by default # Sort by age (second element in each tuple) using lambda sorted_by_age = sorted(people, key=lambda person: person[1]) print(sorted_by_age) # Sort by name length using lambda sorted_by_name_length = sorted(people, key=lambda person: len(person[0])) print(sorted_by_name_length) In this example, we’re using lambda functions to specify which part of the tuple should be used for sorting.\nLambda with reduce() The reduce() function (from the functools module) applies a function of two arguments cumulatively to the items of an iterable, reducing it to a single value.\nfrom functools import reduce # Calculate the product of all numbers in a list numbers = [1, 2, 3, 4, 5] # Using a regular function def multiply(x, y): return x * y product = reduce(multiply, numbers) print(product) # Output: 120 (1*2*3*4*5) # Using a lambda function product_lambda = reduce(lambda x, y: x * y, numbers) print(product_lambda) # Output: 120 The lambda function lambda x, y: x * y takes two arguments and multiplies them together. The reduce() function applies this lambda to the first two elements of the list, then to the result and the next element, and so on.","lambda-with-sorted#Lambda with \u003ccode\u003esorted()\u003c/code\u003e":"","limitations-of-lambda-functions#Limitations of Lambda Functions":" Single Expression Only: Lambda functions are restricted to a single expression, making them unsuitable for complex logic. No Docstrings: You cannot include documentation within lambda functions. Limited Debugging: Debugging lambda functions can be more difficult than regular functions. May Reduce Readability: For anything beyond simple operations, regular functions with descriptive names are often more clear. Important: Lambda functions are best used for simple, short operations. For complex logic or functions that will be reused throughout your code, regular function definitions with the def keyword are more appropriate.","multiple-arguments-in-lambda-functions#Multiple Arguments in Lambda Functions":"Lambda functions can take multiple arguments:\n# Lambda function with two arguments multiply = lambda x, y: x * y print(multiply(5, 3)) # Output: 15 # Lambda function with three arguments calculate = lambda x, y, z: x + y * z print(calculate(2, 3, 4)) # Output: 14 (2 + 3*4) ","practical-examples-of-lambda-functions#Practical Examples of Lambda Functions":"Example 1: Custom Sorting Sort a list of dictionaries by a specific key:\n# List of student dictionaries students = [ {\"name\": \"Alice\", \"grade\": 85}, {\"name\": \"Bob\", \"grade\": 92}, {\"name\": \"Charlie\", \"grade\": 78}, {\"name\": \"David\", \"grade\": 87} ] # Sort by grade (highest to lowest) sorted_by_grade = sorted(students, key=lambda student: student[\"grade\"], reverse=True) print(\"Students sorted by grade (highest to lowest):\") for student in sorted_by_grade: print(f\"{student['name']}: {student['grade']}\") Example 2: Data Transformation Transform a list of data:\n# List of temperatures in Celsius celsius_temps = [20, 25, 30, 35, 40] # Convert to Fahrenheit using map with lambda fahrenheit_temps = list(map(lambda c: (c * 9/5) + 32, celsius_temps)) print(\"Celsius temperatures:\", celsius_temps) print(\"Fahrenheit temperatures:\", fahrenheit_temps) Example 3: Filtering Data Based on Multiple Conditions Filter items based on complex conditions:\n# List of products products = [ {\"name\": \"Laptop\", \"price\": 1200, \"in_stock\": True}, {\"name\": \"Smartphone\", \"price\": 800, \"in_stock\": True}, {\"name\": \"Tablet\", \"price\": 500, \"in_stock\": False}, {\"name\": \"Headphones\", \"price\": 150, \"in_stock\": True}, {\"name\": \"Monitor\", \"price\": 300, \"in_stock\": False} ] # Filter products: in stock and price under 1000 available_affordable = list(filter( lambda product: product[\"in_stock\"] and product[\"price\"] \u003c 1000, products )) print(\"Available and affordable products:\") for product in available_affordable: print(f\"{product['name']} - ${product['price']}\") Example 4: Creating Function Factories Create customized functions dynamically:\ndef price_calculator(tax_rate): \"\"\"Returns a function that calculates the price after tax.\"\"\" return lambda price: price * (1 + tax_rate) # Create tax calculators for different regions calculate_price_ca = price_calculator(0.0725) # 7.25% tax in California calculate_price_ny = price_calculator(0.0845) # 8.45% tax in New York # Test the calculators product_price = 100.00 print(f\"Product base price: ${product_price}\") print(f\"Price in California: ${calculate_price_ca(product_price):.2f}\") print(f\"Price in New York: ${calculate_price_ny(product_price):.2f}\") ","when-to-use-lambda-functions#When to Use Lambda Functions":""},"title":"Lambda Functions"},"/python-fundamentals/05-modules-and-packages/":{"data":{"":"Python’s true power lies in its extensive ecosystem of reusable code.\nModules and packages allow you to organize, share, and leverage code efficiently, turning complex programming challenges into manageable tasks.\nBy mastering how to import built-in modules, create your own, and work with external packages, you’ll dramatically expand what you can accomplish with Python. The modular nature of Python is one of its greatest strengths, enabling everything from simple scripts to enterprise applications.\nHere is what Modules and Packages section covers:\n01. Importing Modules 02. Creating Your Own Modules 03. Standard Library Overview 04. Installing External Packages Using pip 05. Virtual Environments "},"title":"Modules and Packages"},"/python-fundamentals/05-modules-and-packages/01-importing-modules/":{"data":{"":"","creating-your-own-modules#Creating Your Own Modules":"","exercises#Exercises":"Exercise 1: Create a simple module called geometry.py with functions to calculate the area and perimeter of common shapes (circle, rectangle, and triangle). Then create a separate Python file that imports and uses these functions.\nExercise 2: Modify the text_analyzer.py module to include a new function called count_unique_words() that returns the number of unique words in a text. Write a test program that uses this function.\nExercise 3: Create a module that provides utility functions for working with dates and times (e.g., getting the current date in different formats, calculating the difference between two dates, checking if a year is a leap year). Use the datetime module in your implementation.\nHint for Exercise 1: For the geometry module, include functions like circle_area(radius), rectangle_area(length, width), and use the proper formulas for each shape. Remember to import the math module for π (pi).\nIn the next section, we’ll explore creating your own Python packages to organize multiple related modules.","importing-all-items-from-a-module#Importing All Items from a Module":"","importing-specific-items-from-a-module#Importing Specific Items from a Module":"","module-dir-and-help#Module \u003ccode\u003edir()\u003c/code\u003e and \u003ccode\u003ehelp()\u003c/code\u003e":"Modules are one of Python’s most powerful features. They allow you to organize your code into reusable files and make it easier to maintain larger programs. A module is simply a Python file (.py) containing code that can be imported and used in other Python files.\nWhat Are Modules? A module is a file containing Python definitions and statements. The file name is the module name with the suffix .py added. For example, if you have a file named math_operations.py, the module name would be math_operations.\nThe contents of a module are made available to other Python files through the import system. This allows you to reuse code across multiple projects and organize your code logically.\nThe import Statement The simplest way to use a module is with the import statement:\nimport module_name After importing a module, you can access its functions, classes, and variables using dot notation:\nimport math # Using functions from the math module radius = 5 area = math.pi * (radius ** 2) print(f\"Circle area: {area}\") square_root = math.sqrt(16) print(f\"Square root of 16: {square_root}\") In this example, math is a built-in Python module that provides mathematical functions and constants. We access the pi constant and the sqrt() function using dot notation.\nImporting Specific Items from a Module If you only need specific items from a module, you can import them directly:\nfrom module_name import item1, item2 This allows you to use the imported items directly, without the module name prefix:\nfrom math import pi, sqrt # No need for 'math.' prefix radius = 5 area = pi * (radius ** 2) print(f\"Circle area: {area}\") square_root = sqrt(16) print(f\"Square root of 16: {square_root}\") Note: This approach can lead to confusion if you import items with names that conflict with existing variables or functions in your code. Use it judiciously, especially in larger programs.\nImporting All Items from a Module You can import all items from a module using the * wildcard:\nfrom module_name import * from math import * # Using functions and constants directly radius = 5 area = pi * (radius ** 2) print(f\"Circle area: {area}\") square_root = sqrt(16) print(f\"Square root of 16: {square_root}\") Important: While convenient for small scripts, this approach is generally discouraged in production code because:\nIt clutters your namespace with all names from the module It’s not clear where imported names come from It can lead to unexpected name collisions Renaming Imports You can rename imported modules or items using the as keyword:\nimport module_name as alias from module_name import item as alias This is useful for modules with long names or to avoid name conflicts:\nimport numpy as np import matplotlib.pyplot as plt from math import sqrt as square_root # Using the aliases data = np.array([1, 2, 3, 4, 5]) print(f\"Mean: {np.mean(data)}\") result = square_root(16) print(f\"Square root of 16: {result}\") This approach is commonly used for popular scientific libraries like NumPy and Pandas.\nThe Module Search Path When you import a module, Python searches for it in several locations:\nThe directory containing the script being executed The Python standard library directories Directories listed in the PYTHONPATH environment variable Installation-dependent default directories You can view the search path by accessing the sys.path list:\nimport sys print(sys.path) The Standard Library Python comes with a comprehensive standard library of modules. Here are some commonly used ones:\nModule Purpose Example Usage math Mathematical functions math.sqrt(), math.sin() random Random number generation random.randint(), random.choice() datetime Date and time manipulation datetime.now(), date.today() os Interacting with the operating system os.path.join(), os.listdir() sys System-specific parameters and functions sys.argv, sys.exit() json JSON encoding and decoding json.loads(), json.dumps() re Regular expressions re.match(), re.search() collections Specialized container datatypes collections.Counter, collections.defaultdict Let’s see some examples of using these modules:\nMath Module import math # Constants print(f\"Pi: {math.pi}\") print(f\"Euler's number (e): {math.e}\") # Functions print(f\"Sine of 30 degrees: {math.sin(math.radians(30))}\") print(f\"Logarithm (base 10) of 100: {math.log10(100)}\") print(f\"Factorial of 5: {math.factorial(5)}\") Random Module import random # Generate a random integer between 1 and 10 print(f\"Random integer: {random.randint(1, 10)}\") # Select a random element from a list fruits = [\"apple\", \"banana\", \"cherry\", \"date\"] print(f\"Random fruit: {random.choice(fruits)}\") # Shuffle a list numbers = [1, 2, 3, 4, 5] random.shuffle(numbers) print(f\"Shuffled list: {numbers}\") # Generate a random float between 0 and 1 print(f\"Random float: {random.random()}\") Datetime Module from datetime import datetime, date, timedelta # Current date and time now = datetime.now() print(f\"Current date and time: {now}\") # Just the current date today = date.today() print(f\"Current date: {today}\") # Date arithmetic tomorrow = today + timedelta(days=1) print(f\"Tomorrow: {tomorrow}\") # Formatting dates formatted_date = now.strftime(\"%Y-%m-%d %H:%M:%S\") print(f\"Formatted date and time: {formatted_date}\") # Parsing a date string date_string = \"2023-05-15\" parsed_date = datetime.strptime(date_string, \"%Y-%m-%d\") print(f\"Parsed date: {parsed_date}\") OS Module import os # Get the current working directory cwd = os.getcwd() print(f\"Current working directory: {cwd}\") # List all files in a directory files = os.listdir(cwd) print(f\"Files in current directory: {files}\") # Check if a file exists file_path = \"example.txt\" exists = os.path.exists(file_path) print(f\"Does {file_path} exist? {exists}\") # Join paths (works on all operating systems) new_path = os.path.join(cwd, \"data\", \"file.txt\") print(f\"Joined path: {new_path}\") Creating Your Own Modules Creating your own modules is as simple as writing a Python file. Let’s create a simple calculator.py module:\n# calculator.py def add(a, b): \"\"\"Add two numbers and return the result.\"\"\" return a + b def subtract(a, b): \"\"\"Subtract b from a and return the result.\"\"\" return a - b def multiply(a, b): \"\"\"Multiply two numbers and return the result.\"\"\" return a * b def divide(a, b): \"\"\" Divide a by b and return the result. Raises: ZeroDivisionError: If b is zero \"\"\" if b == 0: raise ZeroDivisionError(\"Cannot divide by zero\") return a / b # A constant PI = 3.14159 # A class class Circle: def __init__(self, radius): self.radius = radius def area(self): return PI * (self.radius ** 2) def circumference(self): return 2 * PI * self.radius Now, you can import and use this module in another Python file:\n# main.py # Import the entire module import calculator # Use functions from the module result1 = calculator.add(5, 3) print(f\"5 + 3 = {result1}\") result2 = calculator.multiply(4, 7) print(f\"4 * 7 = {result2}\") # Use the constant print(f\"PI value: {calculator.PI}\") # Create an instance of the Circle class circle = calculator.Circle(5) print(f\"Circle area: {circle.area()}\") print(f\"Circle circumference: {circle.circumference()}\") # Import specific items from calculator import subtract, divide result3 = subtract(10, 4) print(f\"10 - 4 = {result3}\") try: result4 = divide(8, 2) print(f\"8 / 2 = {result4}\") result5 = divide(8, 0) # This will raise an exception print(f\"8 / 0 = {result5}\") except ZeroDivisionError as e: print(f\"Error: {e}\") Module Variables When a module is imported, it is executed. This means any variables at the module level are initialized, and any statements outside of functions or classes are executed.\nEach module has its own namespace, which helps prevent naming conflicts. Here’s a useful pattern for module variables:\n# constants.py # Public constants (intended to be imported) APP_NAME = \"MyApp\" VERSION = \"1.0.0\" MAX_CONNECTIONS = 100 # \"Private\" variables (conventionally not meant to be imported) _config_file = \"settings.ini\" _debug_mode = False def get_app_info(): \"\"\"Return a dictionary of app information.\"\"\" return { \"name\": APP_NAME, \"version\": VERSION, \"max_connections\": MAX_CONNECTIONS, \"debug\": _debug_mode } By convention, variables with a leading underscore are considered “private” and not intended to be imported, though Python doesn’t enforce this.\nThe if __name__ == \"__main__\": Pattern A common pattern in Python modules is to include code that runs only when the module is executed directly, not when it’s imported:\n# geometry.py def calculate_area(length, width): \"\"\"Calculate the area of a rectangle.\"\"\" return length * width def calculate_perimeter(length, width): \"\"\"Calculate the perimeter of a rectangle.\"\"\" return 2 * (length + width) # This block only runs when the file is executed directly if __name__ == \"__main__\": print(\"Testing the geometry module...\") print(f\"Area of a 5x3 rectangle: {calculate_area(5, 3)}\") print(f\"Perimeter of a 5x3 rectangle: {calculate_perimeter(5, 3)}\") Now, if you run geometry.py directly:\n$ python geometry.py Testing the geometry module... Area of a 5x3 rectangle: 15 Perimeter of a 5x3 rectangle: 16 But if you import it in another file, the test code doesn’t run:\nimport geometry # Only the functions are available, the test code doesn't run area = geometry.calculate_area(10, 8) print(f\"Area: {area}\") # Area: 80 This pattern is useful for including tests, examples, or command-line functionality in your modules without affecting their behavior when imported.\nModule dir() and help() You can explore the contents of a module using the dir() function, which returns a list of names defined in the module:\nimport math print(dir(math)) # Output: ['__doc__', '__loader__', ..., 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', ...] To get help on a module or its components, use the help() function:\nimport math help(math) # Displays documentation for the entire module help(math.sin) # Displays documentation for a specific function ","module-variables#Module Variables":"","practical-example-building-a-simple-module#Practical Example: Building a Simple Module":"Let’s create a practical example of a module for text analysis:\n# text_analyzer.py def word_count(text): \"\"\"Count the number of words in a text.\"\"\" if not text: return 0 words = text.split() return len(words) def character_count(text, include_spaces=False): \"\"\" Count the number of characters in a text. Args: text (str): The text to analyze include_spaces (bool): Whether to include spaces in the count Returns: int: The number of characters \"\"\" if not include_spaces: text = text.replace(\" \", \"\") return len(text) def sentence_count(text): \"\"\"Estimate the number of sentences in a text.\"\"\" if not text: return 0 # Simple approach: count period, question mark, and exclamation mark count = text.count('.') + text.count('!') + text.count('?') return max(1, count) # At least 1 sentence if there's text def most_common_words(text, n=5): \"\"\" Find the most common words in a text. Args: text (str): The text to analyze n (int): The number of most common words to return Returns: list: A list of tuples (word, count) of the most common words \"\"\" if not text: return [] # Convert to lowercase and remove punctuation text = text.lower() for char in \".,!?;:\\\"'()[]{}-\": text = text.replace(char, \" \") # Count word occurrences words = text.split() word_counts = {} for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 # Sort by count (descending) and get top n sorted_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True) return sorted_words[:n] def readability_score(text): \"\"\" Calculate a simple readability score based on average word and sentence length. Higher scores indicate more complex text. Returns: float: A readability score \"\"\" if not text: return 0 words = text.split() word_count = len(words) if word_count == 0: return 0 char_count = sum(len(word) for word in words) avg_word_length = char_count / word_count sentences = max(1, sentence_count(text)) avg_sentence_length = word_count / sentences # Simple formula: average word length × average sentence length return round(avg_word_length * avg_sentence_length, 2) # Example usage if __name__ == \"__main__\": sample_text = \"\"\" Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation. Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including structured, object-oriented, and functional programming. It is often described as a \"batteries included\" language due to its comprehensive standard library. \"\"\" print(f\"Word count: {word_count(sample_text)}\") print(f\"Character count (excluding spaces): {character_count(sample_text)}\") print(f\"Character count (including spaces): {character_count(sample_text, include_spaces=True)}\") print(f\"Sentence count: {sentence_count(sample_text)}\") print(f\"Most common words: {most_common_words(sample_text)}\") print(f\"Readability score: {readability_score(sample_text)}\") Now, let’s use this module in another file:\n# analyze_file.py import text_analyzer def analyze_file(filename): \"\"\"Analyze the text content of a file.\"\"\" try: with open(filename, 'r', encoding='utf-8') as file: content = file.read() print(f\"Analysis of {filename}:\") print(f\"Word count: {text_analyzer.word_count(content)}\") print(f\"Character count: {text_analyzer.character_count(content)}\") print(f\"Sentence count: {text_analyzer.sentence_count(content)}\") print(\"Most common words:\") for word, count in text_analyzer.most_common_words(content): print(f\" - {word}: {count} occurrences\") print(f\"Readability score: {text_analyzer.readability_score(content)}\") except FileNotFoundError: print(f\"Error: File '{filename}' not found.\") except Exception as e: print(f\"Error analyzing file: {e}\") if __name__ == \"__main__\": import sys if len(sys.argv) \u003c 2: print(\"Usage: python analyze_file.py \u003cfilename\u003e\") sys.exit(1) filename = sys.argv[1] analyze_file(filename) This example demonstrates:\nCreating a module with related functions Using docstrings to document each function Including example usage and testing code guarded by if __name__ == \"__main__\": Importing and using the module in another file Error handling when using the module ","reloading-a-module#Reloading a Module":"By default, a module is only loaded once per Python session, even if you import it multiple times. If you’ve modified the module and want to reload it without restarting your Python script, you can use importlib.reload():\nimport importlib import my_module # After modifying my_module.py importlib.reload(my_module) # Reloads the module with the changes This is particularly useful during development and in interactive sessions like Jupyter Notebooks.","renaming-imports#Renaming Imports":"","the-if-__name__--__main__-pattern#The \u003ccode\u003eif __name__ == \u0026quot;__main__\u0026quot;:\u003c/code\u003e Pattern":"","the-import-statement#The \u003ccode\u003eimport\u003c/code\u003e Statement":"","the-module-search-path#The Module Search Path":"","the-standard-library#The Standard Library":"","what-are-modules#What Are Modules?":""},"title":"Importing Modules"},"/python-fundamentals/05-modules-and-packages/02-create-modules/":{"data":{"":"","absolute-vs-relative-imports#Absolute vs. Relative Imports":"When working with packages, you need to understand how to import modules from the same package:\nAbsolute imports use the full path from the project root:\n# In geometry/triangles.py import geometry.circles from geometry.rectangles import calculate_rectangle_area Relative imports use dots to indicate the relationship:\n# In geometry/triangles.py from . import circles # Import circles.py from the same package from .circles import calculate_circle_area # Import a specific function from .. import other_package # Import from a parent package Relative imports can be useful in packages that might be renamed or moved, but they can’t be used in top-level scripts (files you run directly).","best-practices-for-module-design#Best Practices for Module Design":"When creating your own modules, consider these best practices:\nKeep modules focused: Each module should have a clear purpose and handle one aspect of your program.\nUse meaningful names: Module names should be short, lowercase, and descriptive of their contents.\nDocument your code: Include docstrings at the module, class, and function levels.\nFollow PEP 8: Adhere to Python’s style guide for consistent, readable code.\nTest your modules: Include tests to ensure your code works as expected. You can use the unittest module or a framework like pytest.\nHandle errors gracefully: Use appropriate error handling and raise specific exceptions with informative messages.\nBe mindful of circular imports: Avoid having modules that import each other, as this can lead to complications.\nUse relative imports within packages: When referring to modules in the same package, use relative imports.\nProvide examples: Include example usage in docstrings or in a separate examples directory.\nVersion your modules: Use semantic versioning to indicate changes in your modules’ APIs.","creating-a-basic-module#Creating a Basic Module":"","creating-a-module-with-multiple-files-creating-a-package#Creating a Module with Multiple Files (Creating a Package)":"For larger projects, a single module file might not be enough. Python allows you to create packages, which are directories containing multiple module files.\nLet’s create a simple package for geometry calculations:\nCreate a directory structure:\ngeometry/ ├── __init__.py ├── circles.py ├── rectangles.py └── triangles.py Create the module files:\n__init__.py:\n\"\"\" Geometry Package This package provides functions for calculating properties of geometric shapes. \"\"\" # You can import specific functions to make them available directly from the package from .circles import calculate_circle_area, calculate_circle_circumference from .rectangles import calculate_rectangle_area, calculate_rectangle_perimeter from .triangles import calculate_triangle_area # Define what gets imported with `from geometry import *` __all__ = ['calculate_circle_area', 'calculate_circle_circumference', 'calculate_rectangle_area', 'calculate_rectangle_perimeter', 'calculate_triangle_area'] circles.py:\n\"\"\"Functions for circle calculations.\"\"\" import math def calculate_circle_area(radius): \"\"\"Calculate the area of a circle.\"\"\" return math.pi * radius ** 2 def calculate_circle_circumference(radius): \"\"\"Calculate the circumference of a circle.\"\"\" return 2 * math.pi * radius rectangles.py:\n\"\"\"Functions for rectangle calculations.\"\"\" def calculate_rectangle_area(length, width): \"\"\"Calculate the area of a rectangle.\"\"\" return length * width def calculate_rectangle_perimeter(length, width): \"\"\"Calculate the perimeter of a rectangle.\"\"\" return 2 * (length + width) triangles.py:\n\"\"\"Functions for triangle calculations.\"\"\" import math def calculate_triangle_area(base, height): \"\"\"Calculate the area of a triangle using base and height.\"\"\" return 0.5 * base * height def calculate_triangle_area_sides(a, b, c): \"\"\"Calculate the area of a triangle using the three sides (Heron's formula).\"\"\" # Semi-perimeter s = (a + b + c) / 2 # Heron's formula area = math.sqrt(s * (s - a) * (s - b) * (s - c)) return area Use the package in another file:\n# Import the entire package import geometry # Use functions made available through __init__.py circle_area = geometry.calculate_circle_area(5) print(f\"Circle area: {circle_area}\") # Import a specific module from the package from geometry import triangles # Use functions from that module triangle_area = triangles.calculate_triangle_area_sides(3, 4, 5) print(f\"Triangle area: {triangle_area}\") # Import specific functions from geometry.rectangles import calculate_rectangle_area, calculate_rectangle_perimeter rect_area = calculate_rectangle_area(4, 5) rect_perimeter = calculate_rectangle_perimeter(4, 5) print(f\"Rectangle area: {rect_area}\") print(f\"Rectangle perimeter: {rect_perimeter}\") Important: The __init__.py file is necessary to make Python treat the directory as a package. In Python 3.3+, directories without an __init__.py file can still be imported as “namespace packages,” but it’s good practice to include an __init__.py file for compatibility and to define package-level behavior.","different-ways-to-import-modules#Different Ways to Import Modules":"","exercises#Exercises":"Exercise 1: Create a module named math_utils.py that includes functions for calculating the factorial of a number, checking if a number is prime, and finding the greatest common divisor (GCD) of two numbers. Include appropriate docstrings and example usage.\nExercise 2: Create a package named text_analysis with separate modules for:\nbasic_stats.py: Functions for counting characters, words, and sentences sentiment.py: A simple function that counts positive and negative words in a text readability.py: Functions to calculate readability scores (e.g., Flesch reading ease) Make sure to create an __init__.py file that exposes the main functions. Exercise 3: Extend the string_utils.py module to include additional features:\nA function to convert snake_case to camelCase A function to capitalize the first letter of each sentence A function to remove duplicate words from a text Hint for Exercise 1: For the factorial function, remember that the factorial of 0 is 1, and factorials are only defined for non-negative integers.\n# math_utils.py (Exercise 1 hint) def factorial(n): \"\"\" Calculate the factorial of a number. Args: n (int): A non-negative integer Returns: int: The factorial of n Raises: ValueError: If n is negative \"\"\" if not isinstance(n, int): raise TypeError(\"Input must be an integer\") if n \u003c 0: raise ValueError(\"Factorial is not defined for negative numbers\") if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result In the next section, we’ll explore the standard library in Python, which provides a wealth of pre-built modules for common tasks.","making-your-module-installable#Making Your Module Installable":"For more complex projects, you can make your package installable using setuptools. This allows users to install your package with pip.\nCreate a setup.py file in the root of your project:\nfrom setuptools import setup, find_packages setup( name=\"geometry\", version=\"0.1\", packages=find_packages(), description=\"A package for geometric calculations\", author=\"Your Name\", author_email=\"your.email@example.com\", ) Install the package in development mode:\npip install -e . This allows you to import your package from anywhere on your system, and changes to the source files will be immediately available without reinstalling.","module-search-path#Module Search Path":"When you import a module, Python searches for it in several locations:\nThe directory containing the script being executed The directories in the PYTHONPATH environment variable The standard library directories The site-packages directories where packages installed by pip are located You can see the complete search path by checking the sys.path list:\nimport sys print(sys.path) To add a new directory to the search path, you can modify sys.path:\nimport sys sys.path.append('/path/to/your/modules') Note: Modifying sys.path in your code is generally not recommended for production applications. It’s better to install your package properly or use virtual environments.","module-variables-and-the-__name__-variable#Module Variables and the \u003ccode\u003e__name__\u003c/code\u003e Variable":"While Python comes with a rich standard library, and there are thousands of third-party packages available, you’ll often need to create your own modules to organize and reuse your code. In this section, we’ll learn how to create, structure, and use custom modules effectively.\nWhat is a Module? In Python, a module is simply a file containing Python code. The filename is the module name with the .py extension. For example, a file named calculator.py would be a module named calculator.\nModules allow you to:\nOrganize related code into separate files Reuse code across different programs Control the namespace (avoid naming conflicts) Make your code more maintainable Creating a Basic Module Let’s start by creating a simple module to understand the basics:\nCreate a new file named my_math.py with the following code: # my_math.py # Define some constants PI = 3.14159 # Define some functions def add(x, y): \"\"\"Add two numbers and return the result.\"\"\" return x + y def subtract(x, y): \"\"\"Subtract y from x and return the result.\"\"\" return x - y def multiply(x, y): \"\"\"Multiply two numbers and return the result.\"\"\" return x * y def divide(x, y): \"\"\"Divide x by y and return the result.\"\"\" if y == 0: raise ValueError(\"Cannot divide by zero\") return x / y def square(x): \"\"\"Return the square of a number.\"\"\" return x * x def sqrt(x): \"\"\"Return the square root of a number.\"\"\" if x \u003c 0: raise ValueError(\"Cannot calculate square root of a negative number\") return x ** 0.5 Create another file named main.py in the same directory to use this module: # main.py # Import the module import my_math # Use the module's functions and variables radius = 5 area = my_math.PI * my_math.square(radius) print(f\"The area of a circle with radius {radius} is: {area}\") print(f\"5 + 3 = {my_math.add(5, 3)}\") print(f\"10 - 4 = {my_math.subtract(10, 4)}\") print(f\"6 * 7 = {my_math.multiply(6, 7)}\") print(f\"8 / 2 = {my_math.divide(8, 2)}\") print(f\"Square root of 16 = {my_math.sqrt(16)}\") Run main.py: The area of a circle with radius 5 is: 78.53975 5 + 3 = 8 10 - 4 = 6 6 * 7 = 42 8 / 2 = 4.0 Square root of 16 = 4.0 Important: When you import a module, Python executes all the code in that module. This happens only once per Python session, even if you import the module multiple times, as Python caches imported modules.\nDifferent Ways to Import Modules Python provides several ways to import modules:\nImport the entire module:\nimport my_math result = my_math.add(5, 3) # Use the module name as a prefix Import specific items from a module:\nfrom my_math import add, subtract result = add(5, 3) # Call directly without the module name prefix Import everything from a module (generally not recommended due to namespace pollution):\nfrom my_math import * result = add(5, 3) # Call directly without the module name prefix Import with an alias:\nimport my_math as mm result = mm.add(5, 3) # Use the alias as a prefix Note: Option 3 (importing everything with *) can lead to unexpected behavior if the imported module has functions or variables with the same names as those in your current namespace. It’s generally better to be explicit about what you’re importing.\nModule Variables and the __name__ Variable Every Python module has a built-in variable called __name__. When you run a module directly, __name__ is set to \"__main__\". When you import a module, __name__ is set to the module’s name.\nThis allows you to include code that only runs when the module is executed directly, not when it’s imported:\n# my_math.py # ... (previous functions and constants) # Code that runs only when this module is executed directly if __name__ == \"__main__\": print(\"Testing the my_math module...\") print(f\"PI = {PI}\") print(f\"2 + 3 = {add(2, 3)}\") print(f\"5 - 2 = {subtract(5, 2)}\") print(f\"4 * 6 = {multiply(4, 6)}\") print(f\"8 / 4 = {divide(8, 4)}\") Now if you run my_math.py directly, you’ll see the test output. But if you import it in another file, the test code won’t run.\nThis pattern is useful for including test code or example usage in your modules.","organizing-modules#Organizing Modules":"As your project grows, you’ll need to organize your modules effectively. Here are some strategies:\nModule Documentation Good documentation is crucial for reusable modules. Use docstrings to document your modules, functions, and classes:\n\"\"\" my_math module This module provides basic mathematical functions and constants. It is designed for educational purposes to demonstrate module creation. Functions: add(x, y): Return the sum of x and y subtract(x, y): Return x minus y multiply(x, y): Return the product of x and y divide(x, y): Return x divided by y square(x): Return x squared sqrt(x): Return the square root of x Constants: PI: The mathematical constant π (pi), approximately 3.14159 \"\"\" # ... (rest of the module code) Separating Implementation Details Sometimes you want to hide implementation details from users of your module. While Python doesn’t have a formal way to make things private, there’s a convention to prefix “private” variables and functions with an underscore:\n# calculator.py # Public function def calculate_area(radius): \"\"\"Calculate the area of a circle.\"\"\" return _PI * _square(radius) # \"Private\" function (implementation detail) def _square(x): \"\"\"Square a number (internal function).\"\"\" return x * x # \"Private\" constant _PI = 3.14159 Users of your module should only use the public functions and variables:\nimport calculator # Good - using public function area = calculator.calculate_area(5) # Bad - using \"private\" function and constant area = calculator._PI * calculator._square(5) Note: The underscore prefix is just a convention. Python doesn’t actually prevent access to these items, but it signals to other developers that these are implementation details that might change.","practical-example-building-a-utility-module#Practical Example: Building a Utility Module":"Let’s create a practical utility module that handles various string operations:\nCreate a file named string_utils.py: \"\"\" String Utility Module This module provides various utility functions for string manipulation. \"\"\" def reverse_string(text): \"\"\" Reverse a string. Args: text (str): The string to reverse Returns: str: The reversed string Examples: \u003e\u003e\u003e reverse_string(\"hello\") 'olleh' \"\"\" return text[::-1] def count_vowels(text): \"\"\" Count the number of vowels in a string. Args: text (str): The string to check Returns: int: The number of vowels Examples: \u003e\u003e\u003e count_vowels(\"hello\") 2 \"\"\" vowels = \"aeiouAEIOU\" count = 0 for char in text: if char in vowels: count += 1 return count def is_palindrome(text): \"\"\" Check if a string is a palindrome (reads the same forwards and backwards). Ignores case and non-alphanumeric characters. Args: text (str): The string to check Returns: bool: True if the string is a palindrome, False otherwise Examples: \u003e\u003e\u003e is_palindrome(\"racecar\") True \u003e\u003e\u003e is_palindrome(\"A man, a plan, a canal, Panama\") True \"\"\" # Remove non-alphanumeric characters and convert to lowercase cleaned = ''.join(char.lower() for char in text if char.isalnum()) return cleaned == cleaned[::-1] def word_count(text): \"\"\" Count the number of words in a string. Args: text (str): The string to check Returns: int: The number of words Examples: \u003e\u003e\u003e word_count(\"Hello world\") 2 \"\"\" # Split by whitespace and count non-empty words return len([word for word in text.split() if word]) def truncate(text, length, suffix=\"...\"): \"\"\" Truncate a string to a specified length and add a suffix if truncated. Args: text (str): The string to truncate length (int): The maximum length suffix (str, optional): The suffix to add if truncated. Defaults to \"...\". Returns: str: The truncated string Examples: \u003e\u003e\u003e truncate(\"Hello world\", 7) 'Hello...' \"\"\" if len(text) \u003c= length: return text return text[:length - len(suffix)] + suffix if __name__ == \"__main__\": # Test the functions test_string = \"A man, a plan, a canal, Panama\" print(f\"Original string: '{test_string}'\") print(f\"Reversed: '{reverse_string(test_string)}'\") print(f\"Vowel count: {count_vowels(test_string)}\") print(f\"Is palindrome? {is_palindrome(test_string)}\") print(f\"Word count: {word_count(test_string)}\") print(f\"Truncated to 15 chars: '{truncate(test_string, 15)}'\") Create a file to use the module: # use_string_utils.py import string_utils user_input = input(\"Enter a string: \") print(f\"Reversed: {string_utils.reverse_string(user_input)}\") print(f\"Vowel count: {string_utils.count_vowels(user_input)}\") print(f\"Is palindrome? {string_utils.is_palindrome(user_input)}\") print(f\"Word count: {string_utils.word_count(user_input)}\") print(f\"Truncated to 10 chars: {string_utils.truncate(user_input, 10)}\") Run the module directly for testing: python string_utils.py Run the usage example: python use_string_utils.py ","what-is-a-module#What is a Module?":""},"title":"Creating Your Own Modules"},"/python-fundamentals/05-modules-and-packages/03-standard-library-overview/":{"data":{"":"Python’s standard library is a collection of modules and packages that come bundled with Python, providing a rich set of tools and functionality right out of the box. This extensive library is one of Python’s greatest strengths, making it a “batteries included” language that allows you to accomplish many common programming tasks without installing additional packages.","1-working-with-data-types-and-structures#1. Working with Data Types and Structures":"collections - Specialized Container Data Types The collections module provides alternatives to Python’s built-in containers:\nfrom collections import Counter, defaultdict, namedtuple # Counter - count occurrences of elements words = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"] word_counts = Counter(words) print(word_counts) # Counter({'apple': 3, 'banana': 2, 'orange': 1}) print(word_counts.most_common(2)) # [('apple', 3), ('banana', 2)] # defaultdict - dictionary with default values for missing keys fruit_colors = defaultdict(list) fruit_colors[\"apple\"].append(\"red\") # No error even though \"apple\" doesn't exist yet fruit_colors[\"apple\"].append(\"green\") fruit_colors[\"banana\"].append(\"yellow\") print(fruit_colors) # defaultdict(\u003cclass 'list'\u003e, {'apple': ['red', 'green'], 'banana': ['yellow']}) # namedtuple - tuple with named fields Person = namedtuple(\"Person\", [\"name\", \"age\", \"city\"]) john = Person(\"John Doe\", 30, \"New York\") print(john.name) # John Doe print(john.age) # 30 print(john[0]) # John Doe (can still use index access) datetime - Date and Time Operations The datetime module provides classes for manipulating dates and times:\nfrom datetime import datetime, date, timedelta # Current date and time now = datetime.now() print(f\"Current date and time: {now}\") # Creating date objects birthday = date(1990, 5, 15) print(f\"Birthday: {birthday}\") # Date arithmetic today = date.today() days_alive = (today - birthday).days print(f\"Days alive: {days_alive}\") # Time deltas one_week_from_now = now + timedelta(weeks=1) print(f\"One week from now: {one_week_from_now}\") # Formatting dates formatted_date = now.strftime(\"%Y-%m-%d %H:%M:%S\") print(f\"Formatted date: {formatted_date}\") # Parsing dates date_string = \"2023-05-15 14:30:00\" parsed_date = datetime.strptime(date_string, \"%Y-%m-%d %H:%M:%S\") print(f\"Parsed date: {parsed_date}\") ","10-development-and-debugging#10. Development and Debugging":"logging - Logging Facility The logging module provides a flexible framework for emitting log messages:\nimport logging # Configure basic logging logging.basicConfig( level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', filename='app.log' ) # Log messages at different levels logging.debug(\"This is a debug message\") logging.info(\"This is an info message\") logging.warning(\"This is a warning message\") logging.error(\"This is an error message\") logging.critical(\"This is a critical message\") # Create a custom logger logger = logging.getLogger(\"my_app\") logger.setLevel(logging.INFO) # Create console handler console_handler = logging.StreamHandler() console_handler.setLevel(logging.INFO) # Create formatter formatter = logging.Formatter('%(name)s - %(levelname)s - %(message)s') console_handler.setFormatter(formatter) # Add handler to logger logger.addHandler(console_handler) # Use the custom logger logger.info(\"This is an info message from my custom logger\") logger.error(\"This is an error message from my custom logger\") unittest - Unit Testing Framework The unittest module provides a framework for creating and running tests:\nimport unittest # Function to test def add(a, b): return a + b # Test case class class TestAddFunction(unittest.TestCase): def test_add_positive_numbers(self): self.assertEqual(add(2, 3), 5) def test_add_negative_numbers(self): self.assertEqual(add(-1, -1), -2) def test_add_mixed_numbers(self): self.assertEqual(add(-1, 1), 0) def test_add_zero(self): self.assertEqual(add(5, 0), 5) def test_add_string_numbers(self): with self.assertRaises(TypeError): add(\"2\", 3) # Run the tests if __name__ == \"__main__\": unittest.main(argv=['first-arg-is-ignored'], exit=False) ","2-mathematics-and-numeric-operations#2. Mathematics and Numeric Operations":"math - Mathematical Functions The math module provides access to mathematical functions:\nimport math # Constants print(f\"Pi: {math.pi}\") print(f\"Euler's number (e): {math.e}\") # Basic functions print(f\"Square root of 16: {math.sqrt(16)}\") print(f\"5 raised to the power of 3: {math.pow(5, 3)}\") print(f\"Absolute value of -7.5: {math.fabs(-7.5)}\") # Trigonometry (angles in radians) print(f\"Sine of 90 degrees: {math.sin(math.pi/2)}\") print(f\"Cosine of 0 degrees: {math.cos(0)}\") # Logarithms print(f\"Natural logarithm of 10: {math.log(10)}\") print(f\"Base-10 logarithm of 100: {math.log10(100)}\") # Rounding print(f\"Ceiling of 4.3: {math.ceil(4.3)}\") print(f\"Floor of 4.8: {math.floor(4.8)}\") print(f\"Truncated 4.8: {math.trunc(4.8)}\") random - Random Number Generation The random module provides functions for generating random numbers:\nimport random # Random float between 0 and 1 print(f\"Random float: {random.random()}\") # Random float within a range print(f\"Random float between 5 and 10: {random.uniform(5, 10)}\") # Random integer within a range (inclusive) print(f\"Random integer between 1 and 10: {random.randint(1, 10)}\") # Random selection from a sequence fruits = [\"apple\", \"banana\", \"cherry\", \"date\"] print(f\"Random fruit: {random.choice(fruits)}\") # Multiple random selections with replacement print(f\"5 random fruits (with replacement): {random.choices(fruits, k=5)}\") # Multiple random selections without replacement print(f\"3 random fruits (without replacement): {random.sample(fruits, k=3)}\") # Shuffle a list in place random.shuffle(fruits) print(f\"Shuffled fruits: {fruits}\") Note: The random module generates pseudo-random numbers that are not suitable for cryptographic purposes. For cryptographically secure random numbers, use the secrets module instead.","3-file-and-data-handling#3. File and Data Handling":"os and os.path - Operating System Interface The os module provides a way to use operating system dependent functionality:\nimport os # Current working directory print(f\"Current directory: {os.getcwd()}\") # List files and directories print(f\"Files in current directory: {os.listdir('.')}\") # Create a directory os.makedirs(\"new_folder\", exist_ok=True) # File path manipulation filepath = os.path.join(\"new_folder\", \"example.txt\") print(f\"File path: {filepath}\") # Check if a file exists print(f\"Does path exist? {os.path.exists(filepath)}\") # Get file information if os.path.exists(\"example.py\"): size = os.path.getsize(\"example.py\") modified_time = os.path.getmtime(\"example.py\") print(f\"File size: {size} bytes\") print(f\"Last modified: {modified_time}\") # Environment variables home_dir = os.environ.get(\"HOME\") # On Windows, use \"USERPROFILE\" print(f\"Home directory: {home_dir}\") json - JSON Data Encoding and Decoding The json module provides functions for working with JSON data:\nimport json # Python dictionary person = { \"name\": \"John Doe\", \"age\": 30, \"city\": \"New York\", \"languages\": [\"Python\", \"JavaScript\", \"Java\"], \"is_employee\": True, \"height\": 1.85 } # Convert Python object to JSON string json_string = json.dumps(person, indent=4) print(f\"JSON string:\\n{json_string}\") # Convert JSON string back to Python object decoded_person = json.loads(json_string) print(f\"Decoded name: {decoded_person['name']}\") # Writing JSON to a file with open(\"person.json\", \"w\") as file: json.dump(person, file, indent=4) # Reading JSON from a file with open(\"person.json\", \"r\") as file: loaded_person = json.load(file) print(f\"Loaded from file: {loaded_person['name']}\") csv - CSV File Reading and Writing The csv module provides functions for working with CSV files:\nimport csv # Writing CSV data data = [ [\"Name\", \"Age\", \"City\"], [\"John Doe\", 30, \"New York\"], [\"Jane Smith\", 25, \"Los Angeles\"], [\"Bob Johnson\", 35, \"Chicago\"] ] with open(\"people.csv\", \"w\", newline=\"\") as file: writer = csv.writer(file) writer.writerows(data) # Reading CSV data with open(\"people.csv\", \"r\") as file: reader = csv.reader(file) for row in reader: print(row) # Reading CSV with dictionaries with open(\"people.csv\", \"r\") as file: reader = csv.DictReader(file) for row in reader: print(f\"{row['Name']} is {row['Age']} years old and lives in {row['City']}\") ","4-string-processing#4. String Processing":"re - Regular Expressions The re module provides support for regular expressions:\nimport re text = \"Contact us at info@example.com or support@company.org\" # Find all email addresses email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b' emails = re.findall(email_pattern, text) print(f\"Emails found: {emails}\") # ['info@example.com', 'support@company.org'] # Search for a pattern match = re.search(r'contact', text, re.IGNORECASE) if match: print(f\"Found 'contact' at position: {match.start()}\") # Replace text new_text = re.sub(r'example\\.com', 'python.org', text) print(f\"After replacement: {new_text}\") # Split text parts = re.split(r'[@\\.]', 'user@example.com') print(f\"Split parts: {parts}\") # ['user', 'example', 'com'] string - Common String Operations The string module provides various string constants and utilities:\nimport string # String constants print(f\"Lowercase letters: {string.ascii_lowercase}\") print(f\"Uppercase letters: {string.ascii_uppercase}\") print(f\"Digits: {string.digits}\") print(f\"Hexadecimal digits: {string.hexdigits}\") print(f\"Punctuation: {string.punctuation}\") # String formatting (older style) template = string.Template(\"$name is $age years old\") result = template.substitute(name=\"Alice\", age=30) print(result) # \"Alice is 30 years old\" ","5-internet-and-network#5. Internet and Network":"urllib - URL Handling The urllib package provides modules for working with URLs:\nfrom urllib.request import urlopen from urllib.parse import urlparse, urlencode # Parse a URL url = \"https://www.example.com/path?query=value\" parsed_url = urlparse(url) print(f\"Scheme: {parsed_url.scheme}\") # https print(f\"Netloc: {parsed_url.netloc}\") # www.example.com print(f\"Path: {parsed_url.path}\") # /path print(f\"Query: {parsed_url.query}\") # query=value # URL encoding params = {\"name\": \"John Doe\", \"age\": 30} encoded_params = urlencode(params) print(f\"Encoded params: {encoded_params}\") # name=John+Doe\u0026age=30 # Fetch URL content try: with urlopen(\"https://www.python.org\") as response: html = response.read() print(f\"Received {len(html)} bytes from python.org\") except Exception as e: print(f\"Error fetching URL: {e}\") Note: For more advanced HTTP requests, consider using the requests library, which is not part of the standard library but is widely used in the Python community.","6-system-and-process-management#6. System and Process Management":"sys - System-Specific Parameters and Functions The sys module provides access to some variables used or maintained by the Python interpreter:\nimport sys # Python version print(f\"Python version: {sys.version}\") print(f\"Version info: {sys.version_info}\") # Command line arguments print(f\"Command line arguments: {sys.argv}\") # Module search path print(f\"Module search paths:\") for path in sys.path: print(f\" - {path}\") # Standard input, output, and error sys.stdout.write(\"This writes directly to standard output\\n\") sys.stderr.write(\"This writes directly to standard error\\n\") # Exit the program # sys.exit(0) # Exit with a success code subprocess - Subprocess Management The subprocess module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes:\nimport subprocess # Run an external command and capture output result = subprocess.run([\"echo\", \"Hello from subprocess\"], capture_output=True, text=True) print(f\"Command output: {result.stdout}\") print(f\"Return code: {result.returncode}\") # Shell commands (use with caution due to security implications) result = subprocess.run(\"dir\" if sys.platform == \"win32\" else \"ls\", shell=True, capture_output=True, text=True) print(f\"Directory listing output:\\n{result.stdout}\") # Run a command with timeout try: result = subprocess.run([\"python\", \"-c\", \"import time; time.sleep(3); print('Done')\"], timeout=1, capture_output=True, text=True) except subprocess.TimeoutExpired: print(\"Command timed out\") ","7-data-compression-and-archiving#7. Data Compression and Archiving":"zipfile - Work with ZIP Archives The zipfile module provides tools to create, read, write, append, and list a ZIP file:\nimport zipfile import os # Create a ZIP file with zipfile.ZipFile(\"example.zip\", \"w\") as zip_file: # Add files to the ZIP if os.path.exists(\"people.csv\"): zip_file.write(\"people.csv\") if os.path.exists(\"person.json\"): zip_file.write(\"person.json\") # Add a file with data from a string zip_file.writestr(\"info.txt\", \"This is a file created directly in the ZIP.\") # Read a ZIP file with zipfile.ZipFile(\"example.zip\", \"r\") as zip_file: # List contents print(\"ZIP file contents:\") for file_info in zip_file.infolist(): print(f\" - {file_info.filename} ({file_info.file_size} bytes)\") # Extract all files zip_file.extractall(\"extracted_files\") # Read a file from the ZIP without extracting if \"info.txt\" in zip_file.namelist(): content = zip_file.read(\"info.txt\").decode(\"utf-8\") print(f\"Content of info.txt: {content}\") ","8-concurrency-and-parallelism#8. Concurrency and Parallelism":"threading - Thread-based Parallelism The threading module provides thread-based parallelism:\nimport threading import time def task(name, delay): \"\"\"A simple function to run in a thread.\"\"\" print(f\"Thread {name} starting\") time.sleep(delay) print(f\"Thread {name} finished after {delay} seconds\") # Create and start threads threads = [] for i in range(3): thread = threading.Thread(target=task, args=(f\"T{i}\", i+1)) threads.append(thread) thread.start() # Wait for all threads to finish for thread in threads: thread.join() print(\"All threads finished\") concurrent.futures - High-level Interface for Async Execution The concurrent.futures module provides a high-level interface for asynchronously executing callables:\nimport concurrent.futures import time def cpu_bound_task(n): \"\"\"A CPU-bound task that computes the sum of squares.\"\"\" return sum(i*i for i in range(n)) def io_bound_task(n): \"\"\"An I/O-bound task that simulates waiting for an external resource.\"\"\" time.sleep(n) return f\"Task {n} completed after {n} seconds\" # Process pool for CPU-bound tasks print(\"Running CPU-bound tasks with ProcessPoolExecutor...\") with concurrent.futures.ProcessPoolExecutor() as executor: results = executor.map(cpu_bound_task, [1000000, 2000000, 3000000]) for result in results: print(f\"Result: {result}\") # Thread pool for I/O-bound tasks print(\"\\nRunning I/O-bound tasks with ThreadPoolExecutor...\") with concurrent.futures.ThreadPoolExecutor() as executor: future_to_task = {executor.submit(io_bound_task, i): i for i in range(1, 4)} for future in concurrent.futures.as_completed(future_to_task): task_id = future_to_task[future] try: result = future.result() print(f\"Task {task_id} result: {result}\") except Exception as e: print(f\"Task {task_id} generated an exception: {e}\") ","9-data-persistence-and-databases#9. Data Persistence and Databases":"sqlite3 - SQLite Database Interface The sqlite3 module provides a SQL interface to SQLite databases:\nimport sqlite3 # Connect to a database (creates it if it doesn't exist) conn = sqlite3.connect(\"example.db\") cursor = conn.cursor() # Create a table cursor.execute(\"\"\" CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, age INTEGER, email TEXT UNIQUE ) \"\"\") # Insert data users = [ (\"John Doe\", 30, \"john@example.com\"), (\"Jane Smith\", 25, \"jane@example.com\"), (\"Bob Johnson\", 35, \"bob@example.com\") ] cursor.executemany(\"INSERT OR REPLACE INTO users (name, age, email) VALUES (?, ?, ?)\", users) conn.commit() # Query data print(\"All users:\") cursor.execute(\"SELECT * FROM users\") for row in cursor.fetchall(): print(f\"ID: {row[0]}, Name: {row[1]}, Age: {row[2]}, Email: {row[3]}\") # Parameterized query min_age = 28 print(f\"\\nUsers older than {min_age}:\") cursor.execute(\"SELECT name, age FROM users WHERE age \u003e ?\", (min_age,)) for row in cursor.fetchall(): print(f\"{row[0]} is {row[1]} years old\") # Close the connection conn.close() pickle - Python Object Serialization The pickle module implements binary protocols for serializing and de-serializing Python objects:\nimport pickle # Object to serialize data = { \"name\": \"John\", \"age\": 30, \"skills\": [\"Python\", \"JavaScript\", \"SQL\"], \"is_active\": True } # Serialize to a file with open(\"data.pickle\", \"wb\") as file: pickle.dump(data, file) # Deserialize from a file with open(\"data.pickle\", \"rb\") as file: loaded_data = pickle.load(file) print(f\"Loaded data: {loaded_data}\") # Serialize to a string serialized = pickle.dumps(data) print(f\"Serialized data (first 50 bytes): {serialized[:50]}\") # Deserialize from a string deserialized = pickle.loads(serialized) print(f\"Deserialized data: {deserialized}\") Important: The pickle module is not secure against erroneous or maliciously constructed data. Never unpickle data received from untrusted or unauthenticated sources.","accessing-and-using-standard-library-modules#Accessing and Using Standard Library Modules":"To use a module from the standard library, you need to import it:\n# Import an entire module import math # Now you can use functions from the math module result = math.sqrt(16) print(result) # 4.0 # Import specific functions from a module from random import randint # Now you can use the imported function directly random_number = randint(1, 10) print(random_number) # A random integer between 1 and 10 ","essential-standard-library-modules#Essential Standard Library Modules":"Let’s explore some of the most commonly used modules in the standard library, organized by category:","exercises#Exercises":"Exercise 1: Write a program that uses the random module to simulate rolling two dice 1000 times. Count how many times each possible sum (2 through 12) appears and display the results.\nExercise 2: Use the os and datetime modules to create a script that walks through a directory structure and lists all files larger than 1MB, along with their creation date.\nExercise 3: Create a simple note-taking application using the json module for storage. Your app should allow the user to add, view, and delete notes. Each note should have a title, content, and timestamp.\nExercise 4: Use the re module to write a function that extracts all phone numbers from a text. Consider various formats like (123) 456-7890, 123-456-7890, and 1234567890.\nHint for Exercise 1: Use random.randint(1, 6) to simulate rolling a single die, and create a dictionary to count the occurrences of each sum.\n# Exercise 1 sample solution outline import random # Initialize a dictionary to count each sum results = {i: 0 for i in range(2, 13)} # Roll two dice 1000 times for _ in range(1000): die1 = random.randint(1, 6) die2 = random.randint(1, 6) total = die1 + die2 results[total] += 1 # Display the results for total, count in results.items(): print(f\"Sum {total}: {count} times ({count/10:.1f}%)\") In the next section, we’ll learn about creating and using our own modules in Python, which allows you to organize your code into reusable components.","finding-the-right-module#Finding the Right Module":"With over 200 modules in the standard library, it can be challenging to find the right one for your needs. Here are some categories to help you navigate:\nBuilt-in Functions: Functions always available without importing anything, like print(), len(), and range().\nText Processing: string, re, difflib, textwrap, unicodedata, etc.\nData Types: collections, array, heapq, bisect, weakref, etc.\nNumeric and Mathematical: math, random, statistics, decimal, fractions, etc.\nFile and Directory Access: os.path, fileinput, pathlib, tempfile, glob, etc.\nData Persistence: pickle, sqlite3, dbm, csv, configparser, etc.\nData Compression: zlib, gzip, bz2, zipfile, tarfile, etc.\nFile Formats: csv, json, xml.*, html.*, etc.\nCryptographic: hashlib, hmac, secrets, etc.\nOperating System: os, io, time, argparse, logging, platform, etc.\nConcurrent Execution: threading, multiprocessing, concurrent, asyncio, etc.\nNetworking: socket, ssl, email, http.*, urllib.*, etc.\nInternet Data Handling: json, webbrowser, cgi, wsgiref, etc.\nDevelopment Tools: unittest, doctest, pydoc, typing, etc.","practical-example-web-scraper#Practical Example: Web Scraper":"Let’s put together several standard library modules to create a simple web scraper:\nimport urllib.request import re import csv import os from datetime import datetime def scrape_website(url, output_file): \"\"\" Scrape a website and extract all the links. Args: url (str): The URL to scrape output_file (str): The CSV file to save the results \"\"\" print(f\"Scraping {url}...\") try: # Fetch the page content with urllib.request.urlopen(url) as response: html = response.read().decode('utf-8') # Extract all links using regular expressions link_pattern = r'href=[\\'\"]?([^\\'\" \u003e]+)' links = re.findall(link_pattern, html) # Process the links to make them absolute processed_links = [] for link in links: # Skip javascript: and mailto: links if link.startswith(('javascript:', 'mailto:')): continue # Make relative links absolute if not link.startswith(('http://', 'https://')): if link.startswith('/'): # Add domain to absolute path parts = urllib.parse.urlparse(url) base = f\"{parts.scheme}://{parts.netloc}\" link = base + link else: # Add path to relative link if url.endswith('/'): link = url + link else: link = url + '/' + link processed_links.append(link) # Write results to CSV with open(output_file, 'w', newline='', encoding='utf-8') as file: writer = csv.writer(file) writer.writerow(['URL', 'Extracted On']) timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S') for link in processed_links: writer.writerow([link, timestamp]) print(f\"Found {len(processed_links)} links. Results saved to {output_file}\") except Exception as e: print(f\"Error: {e}\") # Run the scraper on Python's website if __name__ == \"__main__\": os.makedirs(\"scraped_data\", exist_ok=True) output_file = os.path.join(\"scraped_data\", \"python_links.csv\") scrape_website(\"https://www.python.org\", output_file) ","using-the-python-documentation#Using the Python Documentation":"The standard library is well-documented. You can access the documentation in several ways:\nOnline Documentation: Visit docs.python.org for comprehensive documentation.\nHelp Function: Use the help() function in the Python interpreter:\nimport math help(math) # Shows documentation for the math module help(math.sqrt) # Shows documentation for the sqrt function Docstrings: Most standard library functions and methods have docstrings that provide information about their usage:\nprint(math.sqrt.__doc__) # Prints the docstring for math.sqrt Dir Function: The dir() function shows all the attributes and methods of an object:\nimport random print(dir(random)) # Lists all attributes and methods of the random module ","what-is-the-standard-library#What is the Standard Library?":"The standard library consists of over 200 modules that provide solutions for file I/O, system interaction, internet protocols, data manipulation, mathematics, and much more. These modules are thoroughly tested, well-documented, and designed to work seamlessly across different platforms.\nImportant: The standard library is always available in any Python installation, making your code more portable. When possible, it’s often better to use the standard library before reaching for third-party packages."},"title":"Standard Library Overview"},"/python-fundamentals/05-modules-and-packages/04-install-external-packages/":{"data":{"":"Python’s strength comes not only from its core functionality but also from its vast ecosystem of third-party packages. These packages extend Python’s capabilities, allowing you to perform complex tasks without having to write everything from scratch. In this section, we’ll learn how to use pip, Python’s package installer, to access this rich ecosystem.","advanced-pip-features#Advanced pip Features":"Installing from Version Control pip can install packages directly from version control systems like Git:\npip install git+https://github.com/username/repository.git Installing from Local Files You can install packages from local files:\n# Install from a downloaded .whl file pip install ./downloads/package-1.0.0-py3-none-any.whl # Install from source directory pip install ./path/to/package/ Installing in Development Mode When developing a package, you can install it in “editable” or “development” mode:\npip install -e ./my_package/ This creates a special link to your source code so that changes to the source are immediately reflected in the installed package without needing to reinstall.","basic-pip-commands#Basic pip Commands":"Installing a Package The most common pip command is install, which downloads and installs a package from PyPI:\n# Basic syntax pip install package_name # Example: Install the requests package pip install requests The command above will download the latest version of the specified package and install it along with any dependencies it requires.\nInstalling a Specific Version Sometimes you need a specific version of a package:\n# Install a specific version pip install requests==2.28.1 You can also specify version constraints:\n# Install any version greater than or equal to 2.20.0 but less than 2.30.0 pip install \"requests\u003e=2.20.0,\u003c2.30.0\" Upgrading a Package To upgrade an already installed package to the latest version:\npip install --upgrade requests # OR pip install -U requests Uninstalling a Package To remove a package:\npip uninstall requests This command will ask for confirmation before uninstallation.\nListing Installed Packages To see what packages are installed:\npip list This will display a list of all installed packages along with their versions.\nFor more detailed information about installed packages:\npip show requests This shows information about the package, including its version, dependencies, and installation location.\nFinding Packages You can search for packages on PyPI directly from the command line:\npip search \"web scraping\" Note: As of early 2023, the pip search command might be disabled due to infrastructure limitations on PyPI. In that case, you can search for packages directly on the PyPI website.","checking-if-pip-is-installed#Checking if pip is Installed":"Before using pip, check if it’s already installed on your system:\n# On Windows pip --version # On macOS/Linux (might be pip3 instead of pip) pip --version # OR pip3 --version If pip is installed, you’ll see the version number along with the Python version it’s associated with:\npip 23.0.1 from /path/to/pip (python 3.11) If you get a “command not found” error, you may need to install pip or use pip3 instead of pip (especially on systems that have both Python 2 and Python 3 installed).","common-pip-issues-and-solutions#Common pip Issues and Solutions":"Permission Errors When installing packages system-wide, you might encounter permission errors:\nERROR: Could not install packages due to an OSError: [Errno 13] Permission denied Solutions:\nUse the --user flag to install packages in the user’s home directory:\npip install --user package_name On Unix-like systems, use sudo (not recommended for security reasons):\nsudo pip install package_name Use virtual environments (covered in the next section) for the safest approach.\nSSL Certificate Errors If you encounter SSL certificate errors:\nCould not fetch URL: There was a problem confirming the ssl certificate Solutions:\nUpdate pip to the latest version:\npip install --upgrade pip If that doesn’t work, you can temporarily disable certificate verification (not recommended for security-sensitive environments):\npip install --trusted-host pypi.org --trusted-host files.pythonhosted.org package_name Package or Dependency Conflicts Sometimes packages have conflicting dependencies:\nERROR: Cannot install package_a and package_b because these package versions have conflicting dependencies Solutions:\nInstall different versions of the packages that might be compatible:\npip install \"package_a\u003c2.0.0\" \"package_b\u003e=1.5.0\" Use virtual environments (covered next) to create isolated environments for different projects with conflicting dependencies.","exercises#Exercises":"Exercise 1: Install the requests and beautifulsoup4 packages using pip. Then write a simple script that uses these packages to fetch and extract the title of a webpage.\nExercise 2: Create a virtual environment for a new project. Install at least three packages in it, then generate a requirements.txt file. Deactivate the environment, delete it, create a new one, and install the packages from the requirements file.\nExercise 3: Find a popular Python package for a task you’re interested in (e.g., data visualization, game development, web development). Install the package, read its documentation, and create a simple example project using it.\nExercise 4: Create a simple command-line tool that uses the click package (install it first) to create a more user-friendly command-line interface. The tool can do something simple like converting between different units of measurement.\nHint for Exercise 1: Use requests.get(url) to fetch the webpage content and BeautifulSoup(content, 'html.parser') to parse it. Then you can find the title using soup.title.string.\n# Exercise 1 solution outline import requests from bs4 import BeautifulSoup url = \"https://www.example.com\" response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.title.string print(f\"The title of the webpage is: {title}\") In the next section, we’ll explore object-oriented programming in Python, learning how to define and use classes to structure your code more effectively.","finding-packages-for-your-project#Finding Packages for Your Project":"The Python ecosystem has packages for almost any task. Here are some popular packages you might find useful:\nWeb Development: Django, Flask, FastAPI Data Science: NumPy, pandas, matplotlib, scikit-learn Web Scraping: requests, Beautiful Soup, Scrapy Database Access: SQLAlchemy, psycopg2, pymongo Testing: pytest, unittest Automation: Selenium, PyAutoGUI API Clients: requests, httpx Image Processing: Pillow, OpenCV Machine Learning: TensorFlow, PyTorch, scikit-learn Natural Language Processing: NLTK, spaCy Before installing a package, it’s a good practice to:\nCheck the package’s documentation Verify its compatibility with your Python version Look at when it was last updated (active maintenance is a good sign) Check the number of downloads and GitHub stars (popularity often correlates with quality) ","practical-example-building-a-weather-app#Practical Example: Building a Weather App":"Let’s build a simple weather app using the requests package to fetch weather data from an API:\n# First, install the required package pip install requests Now, create a Python file named weather_app.py:\nimport requests import json from datetime import datetime def get_weather(city): \"\"\" Get current weather for a city using the OpenWeatherMap API. Args: city (str): Name of the city Returns: dict: Weather information or error message \"\"\" # Replace with your actual API key from OpenWeatherMap api_key = \"your_api_key_here\" # Build the API URL base_url = \"https://api.openweathermap.org/data/2.5/weather\" params = { \"q\": city, \"appid\": api_key, \"units\": \"metric\" # Use metric units (Celsius) } try: # Make the API request response = requests.get(base_url, params=params) # Check if the request was successful if response.status_code == 200: # Parse the JSON response weather_data = response.json() # Extract relevant information result = { \"city\": weather_data[\"name\"], \"country\": weather_data[\"sys\"][\"country\"], \"temperature\": weather_data[\"main\"][\"temp\"], \"feels_like\": weather_data[\"main\"][\"feels_like\"], \"humidity\": weather_data[\"main\"][\"humidity\"], \"description\": weather_data[\"weather\"][0][\"description\"], \"wind_speed\": weather_data[\"wind\"][\"speed\"], \"timestamp\": datetime.fromtimestamp(weather_data[\"dt\"]).strftime(\"%Y-%m-%d %H:%M:%S\") } return result else: return {\"error\": f\"Error: API responded with status code {response.status_code}\"} except requests.exceptions.RequestException as e: return {\"error\": f\"Request error: {e}\"} except (KeyError, json.JSONDecodeError) as e: return {\"error\": f\"Data parsing error: {e}\"} def display_weather(weather_data): \"\"\" Display weather information in a readable format. Args: weather_data (dict): Weather information \"\"\" if \"error\" in weather_data: print(f\"Error: {weather_data['error']}\") return print(f\"\\nWeather in {weather_data['city']}, {weather_data['country']}\") print(f\"Time: {weather_data['timestamp']}\") print(f\"Temperature: {weather_data['temperature']}°C (Feels like: {weather_data['feels_like']}°C)\") print(f\"Conditions: {weather_data['description'].capitalize()}\") print(f\"Humidity: {weather_data['humidity']}%\") print(f\"Wind speed: {weather_data['wind_speed']} m/s\") def main(): \"\"\"Main function to run the weather app.\"\"\" print(\"Welcome to the Weather App!\") while True: city = input(\"\\nEnter a city name (or 'quit' to exit): \") if city.lower() == \"quit\": print(\"Thank you for using the Weather App!\") break weather_data = get_weather(city) display_weather(weather_data) if __name__ == \"__main__\": main() To use this app, you’ll need to:\nSign up for a free API key at OpenWeatherMap Replace \"your_api_key_here\" in the code with your actual API key This example demonstrates how easy it is to extend Python’s functionality with external packages. The requests package handles all the complex HTTP communication, allowing us to focus on the application logic.","using-pip-with-requirements-files#Using pip with Requirements Files":"When working on projects, it’s common to use a requirements.txt file to list all the packages your project depends on. This makes it easier to share and replicate your environment.\nCreating a Requirements File You can manually create a requirements.txt file or generate one from your currently installed packages:\npip freeze \u003e requirements.txt This command creates a requirements.txt file with all installed packages and their specific versions.\nA typical requirements.txt file might look like this:\nrequests==2.28.1 numpy==1.24.2 pandas==1.5.3 matplotlib==3.7.1 Installing from a Requirements File To install all packages listed in a requirements.txt file:\npip install -r requirements.txt This will install all packages at the specified versions, making it easy to replicate development environments across different machines.","what-is-pip#What is pip?":"pip (Pip Installs Packages) is the standard package manager for Python. It allows you to install, upgrade, and manage Python packages from the Python Package Index (PyPI) and other repositories.\nImportant: pip comes pre-installed with Python 3.4 and later versions. If you’re using an older Python version, you might need to install pip separately."},"title":"Installing External Packages Using pip"},"/python-fundamentals/05-modules-and-packages/05-virtual-environments/":{"data":{"":"","advanced-pipenv-and-poetry#Advanced: \u003ccode\u003epipenv\u003c/code\u003e and \u003ccode\u003epoetry\u003c/code\u003e":"Virtual environments are a crucial tool in Python development that allow you to create isolated environments for your projects. Each environment can have its own dependencies and packages, regardless of what packages are installed in other environments.\nWhy Virtual Environments Are Important When you develop multiple Python projects, they often require different versions of the same libraries. For example:\nProject A might need version 1.0 of a library Project B might need version 2.0 of the same library Without virtual environments, you’d have to install either version 1.0 or 2.0 globally, which means one of your projects wouldn’t work correctly. Virtual environments solve this problem by creating separate spaces for each project.\nImportant: Using virtual environments is considered a best practice in Python development. They help avoid “dependency hell” and make your projects more reproducible and easier to share with others.\nBenefits of Virtual Environments Isolation: Each project can have its own dependencies, regardless of what other projects need. Reproducibility: You can easily recreate your environment on another machine. Cleanliness: Your global Python installation remains clean and uncluttered. Version Control: You can specify exact versions of libraries needed for your project. Collaboration: Team members can easily recreate the same environment. Tools for Creating Virtual Environments Python offers several tools for creating virtual environments:\nvenv: Built into Python standard library (Python 3.3+) virtualenv: A third-party tool that works with both Python 2 and 3 conda: Part of the Anaconda distribution, specializing in data science pipenv: Combines pip and virtualenv into a single tool poetry: Modern dependency management and packaging We’ll focus primarily on venv since it’s included with Python and is recommended for most use cases.\nCreating Virtual Environments with venv The venv module is included with Python 3.3 and later. It provides a way to create lightweight virtual environments.\nCreating a Virtual Environment To create a virtual environment, open your command prompt or terminal and run:\n# On Windows python -m venv myenv # On macOS/Linux python3 -m venv myenv This creates a directory called myenv (you can choose any name) that contains:\nA copy of the Python interpreter The pip package manager A standard library subset Activating a Virtual Environment Before you can use a virtual environment, you need to activate it:\n# On Windows (Command Prompt) myenv\\Scripts\\activate.bat # On Windows (PowerShell) myenv\\Scripts\\Activate.ps1 # On macOS/Linux source myenv/bin/activate When activated, your command prompt will change to show the name of the virtual environment:\n(myenv) C:\\Users\\username\u003e # Windows (myenv) username@hostname:~$ # macOS/Linux This indicates that any Python commands you run will use the Python interpreter and packages in your virtual environment.\nDeactivating a Virtual Environment To exit the virtual environment and return to your global Python environment:\ndeactivate Your command prompt will return to normal.\nInstalling Packages in a Virtual Environment Once your virtual environment is activated, you can install packages using pip:\n# Make sure your virtual environment is activated (myenv) $ pip install numpy Any packages you install will be isolated to this virtual environment and won’t affect your global Python installation or other virtual environments.\nManaging Requirements Exporting Requirements To share your environment with others or recreate it elsewhere, you can export a list of installed packages:\n(myenv) $ pip freeze \u003e requirements.txt This creates a file called requirements.txt that lists all the packages and their versions.\nImporting Requirements To recreate an environment from a requirements file:\n# Create and activate a new virtual environment first (new_env) $ pip install -r requirements.txt This installs all the packages listed in requirements.txt with the specified versions.\nProject Workflow with Virtual Environments Here’s a common workflow for starting a new Python project:\n# 1. Navigate to your project directory cd my_project # 2. Create a virtual environment python -m venv venv # 3. Activate the virtual environment # On Windows venv\\Scripts\\activate # On macOS/Linux source venv/bin/activate # 4. Install required packages (venv) $ pip install django requests # 5. Work on your project... # 6. Before sharing or committing your project, export requirements (venv) $ pip freeze \u003e requirements.txt # 7. When done, deactivate the environment (venv) $ deactivate Note: It’s common to name the virtual environment directory venv or .venv and add it to your .gitignore file if you’re using Git. This way, you don’t accidentally commit the virtual environment to your repository.\nUsing virtualenv (Alternative to venv) If you need to support Python 2 or want some additional features, you can use virtualenv:\n# Install virtualenv pip install virtualenv # Create a virtual environment virtualenv myenv # Activate (same as venv) # On Windows myenv\\Scripts\\activate # On macOS/Linux source myenv/bin/activate Using conda for Virtual Environments If you’re working with data science libraries, Anaconda’s conda provides a robust environment management system:\n# Create a conda environment conda create --name myenv python=3.8 # Activate the environment conda activate myenv # Install packages conda install numpy pandas matplotlib # Export environment conda env export \u003e environment.yml # Create environment from file conda env create -f environment.yml # Deactivate conda deactivate Conda has the advantage of handling non-Python dependencies, which is particularly useful for complex scientific libraries.\nVirtual Environments in IDEs Most modern Python IDEs support virtual environments:\nPyCharm Go to File → Settings → Project → Python Interpreter Click the gear icon → Add Select “New environment” and configure location and base interpreter Visual Studio Code Open your project folder Press Ctrl+Shift+P (Cmd+Shift+P on macOS) Type “Python: Select Interpreter” Choose your virtual environment from the list or click “Enter interpreter path…” to find it Practical Example: Setting Up a Django Project Let’s walk through setting up a Django web development project with a virtual environment:\n# Create a project directory mkdir my_django_project cd my_django_project # Create a virtual environment python -m venv venv # Activate the virtual environment # On Windows venv\\Scripts\\activate # On macOS/Linux source venv/bin/activate # Install Django (venv) $ pip install django # Start a new Django project (venv) $ django-admin startproject website . # Create a requirements file (venv) $ pip freeze \u003e requirements.txt # Run the development server (venv) $ python manage.py runserver Now you have a Django project isolated in its own environment!\nCommon Issues and Troubleshooting Issue: Permission Errors # On macOS/Linux, you might see permission errors # Solution: Use the --user flag or sudo (but be careful with sudo) pip install --user package_name Issue: Activation Script Not Found # Error: \"cannot find activate script\" # Solution: Make sure the virtual environment was created successfully # Try creating it again with: python -m venv --clear myenv Issue: Packages Not Found After Installation # Make sure your virtual environment is activated # Check which pip you're using (venv) $ which pip # macOS/Linux (venv) $ where pip # Windows Issue: Virtual Environment Not Recognized by IDE # Solution: Make sure you're pointing to the correct python executable # For VS Code, specify the full path in settings.json: \"python.pythonPath\": \"C:\\\\path\\\\to\\\\myenv\\\\Scripts\\\\python.exe\" Best Practices for Virtual Environments Create one virtual environment per project\nThis ensures clean dependency management Always add virtual environment directories to .gitignore\n# In .gitignore venv/ .venv/ env/ Use descriptive names for your environments\npython -m venv env_projectname Store requirements.txt in version control\nThis helps others reproduce your environment Consider using a .env file for environment variables\n# .env DEBUG=True SECRET_KEY=my_secret_key DATABASE_URL=postgresql://user:pass@localhost/dbname Update your requirements.txt when dependencies change\npip freeze \u003e requirements.txt Periodically update packages, but test thoroughly\npip list --outdated pip install --upgrade package_name Advanced: pipenv and poetry For more advanced dependency management, consider these tools:\nUsing pipenv # Install pipenv pip install pipenv # Create a new environment and install packages pipenv install requests numpy # Activate the environment pipenv shell # Install development dependencies (not needed in production) pipenv install pytest --dev # Generate a requirements file pipenv lock -r \u003e requirements.txt Using poetry # Install poetry pip install poetry # Create a new project poetry new my_project # Or initialize in existing project cd existing_project poetry init # Add dependencies poetry add requests numpy # Activate the environment poetry shell # Add development dependencies poetry add pytest --group dev ","benefits-of-virtual-environments#Benefits of Virtual Environments":"","best-practices-for-virtual-environments#Best Practices for Virtual Environments":"","common-issues-and-troubleshooting#Common Issues and Troubleshooting":"","creating-virtual-environments-with-venv#Creating Virtual Environments with \u003ccode\u003evenv\u003c/code\u003e":"","exercises#Exercises":"Exercise 1: Create a virtual environment for a simple web scraping project. Install the requests and beautifulsoup4 packages, and write a short script that fetches and prints the title of a web page.\nExercise 2: Create two different virtual environments with different versions of the same package (e.g., Django 3.2 in one and Django 4.0 in another). Write a simple script to check and print the version of Django in each environment.\nExercise 3: Set up a data analysis project with a virtual environment. Create a requirements.txt file that includes pandas, matplotlib, and numpy. Write a script that generates a simple plot from some sample data.\nHint for Exercise 1: After creating and activating your virtual environment, install the packages with pip install requests beautifulsoup4. Make sure your script can use requests.get() to fetch a page and BeautifulSoup to parse the HTML and find the title tag.\nIn the next section, we’ll explore error handling and debugging techniques in Python, which are essential skills for developing robust applications.","installing-packages-in-a-virtual-environment#Installing Packages in a Virtual Environment":"","managing-requirements#Managing Requirements":"","practical-example-setting-up-a-django-project#Practical Example: Setting Up a Django Project":"","project-workflow-with-virtual-environments#Project Workflow with Virtual Environments":"","tools-for-creating-virtual-environments#Tools for Creating Virtual Environments":"","using-conda-for-virtual-environments#Using \u003ccode\u003econda\u003c/code\u003e for Virtual Environments":"","using-virtualenv-alternative-to-venv#Using \u003ccode\u003evirtualenv\u003c/code\u003e (Alternative to \u003ccode\u003evenv\u003c/code\u003e)":"","virtual-environment-alternatives-docker#Virtual Environment Alternatives: Docker":"For complex applications or microservices, consider using Docker containers instead of or alongside virtual environments:\n# Example Dockerfile FROM python:3.9-slim WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY . . CMD [\"python\", \"app.py\"] Docker provides even stronger isolation than virtual environments and ensures consistency across different development and production environments.","virtual-environments-in-ides#Virtual Environments in IDEs":"","why-virtual-environments-are-important#Why Virtual Environments Are Important":""},"title":"Virtual Environments"},"/python-fundamentals/06-file-operations/":{"data":{"":"Working with files is a fundamental skill in programming that allows your Python applications to store and retrieve data persistently.\nWhether you need to read configuration settings, process large datasets, or save user information, Python’s file handling capabilities provide a straightforward way to interact with the file system.\nThe ability to work with various file formats like plain text, CSV, and JSON enables you to build more powerful and practical applications that can exchange data with other systems. Master these file operations to take your Python projects to the next level and make them truly useful in real-world scenarios.\nHere is what File Operations section covers:\n01. Opening and Closing Files 02. Reading and Writing Files 03. Working with CSV and JSON Files 04. Error Handling in File Operations "},"title":"File Operations"},"/python-fundamentals/06-file-operations/01-opening-and-closing-files/":{"data":{"":"","basic-file-operations-workflow#Basic File Operations Workflow":"","checking-if-a-file-exists#Checking if a File Exists":"Before opening a file, you might want to check if it exists to avoid errors:\nimport os # Using os.path.exists if os.path.exists(\"example.txt\"): with open(\"example.txt\", \"r\") as file: content = file.read() else: print(\"The file does not exist.\") # Using pathlib (Python 3.4+) from pathlib import Path file_path = Path(\"example.txt\") if file_path.exists(): with open(file_path, \"r\") as file: content = file.read() else: print(\"The file does not exist.\") ","closing-files-with-close#Closing Files with \u003ccode\u003eclose()\u003c/code\u003e":"","common-mistakes-and-best-practices#Common Mistakes and Best Practices":"Common Mistakes Not closing files\n# Bad practice file = open(\"data.txt\", \"r\") content = file.read() # File is never closed Using bare except\n# Bad practice - catches all exceptions including KeyboardInterrupt try: with open(\"data.txt\", \"r\") as file: content = file.read() except: print(\"An error occurred\") Hardcoding file paths\n# Bad practice - won't work on different systems file = open(\"C:\\\\Users\\\\username\\\\data.txt\", \"r\") Not handling encoding issues\n# May fail with UnicodeDecodeError for non-UTF-8 files with open(\"data.txt\", \"r\") as file: content = file.read() Best Practices Always use the with statement\n# Good practice with open(\"data.txt\", \"r\") as file: content = file.read() Be specific with exception handling\n# Good practice try: with open(\"data.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"File not found\") except PermissionError: print(\"Permission denied\") except Exception as e: print(f\"Unexpected error: {e}\") Use pathlib for cross-platform path handling\n# Good practice from pathlib import Path data_dir = Path(\"data\") file_path = data_dir / \"info.txt\" with open(file_path, \"r\") as file: content = file.read() Specify encoding when opening text files\n# Good practice with open(\"data.txt\", \"r\", encoding=\"utf-8\") as file: content = file.read() Use binary mode for non-text files\n# Good practice for images, executables, etc. with open(\"image.jpg\", \"rb\") as file: content = file.read() ","error-handling-with-files#Error Handling with Files":"When working with files, various errors can occur, such as the file not existing, permission issues, or disk space problems. It’s important to handle these errors gracefully:\ntry: with open(\"example.txt\", \"r\") as file: content = file.read() print(content) except FileNotFoundError: print(\"The file does not exist.\") except PermissionError: print(\"You don't have permission to access this file.\") except Exception as e: print(f\"An error occurred: {e}\") ","exercises#Exercises":"Exercise 1: Write a program that opens a file named “hello.txt” and writes the text “Hello, World!” to it. If the file already exists, it should be overwritten. After writing, the program should read and print the content of the file.\nExercise 2: Create a function that takes a filename as input and counts the number of lines, words, and characters in the file. The function should return a dictionary with these counts. Handle the case where the file doesn’t exist.\nExercise 3: Write a program that creates a “backup” of a text file by creating a new file with “_backup” appended to the original filename. The backup file should contain the same content as the original file. Test your program with a file that exists and one that doesn’t.\nHint for Exercise 1:\n# First, open the file in write mode to write the message with open(\"hello.txt\", \"w\") as file: file.write(\"Hello, World!\") # Then, open the file in read mode to read and print the content with open(\"hello.txt\", \"r\") as file: content = file.read() print(content) In the next section, we’ll explore reading and writing files in more detail, including various methods to read files efficiently.","file-paths#File Paths":"","opening-files-with-open#Opening Files with \u003ccode\u003eopen()\u003c/code\u003e":"","opening-multiple-files#Opening Multiple Files":"You can open multiple files in a single with statement by separating them with commas:\nwith open(\"input.txt\", \"r\") as input_file, open(\"output.txt\", \"w\") as output_file: content = input_file.read() output_file.write(content.upper()) # Write uppercase content to output file ","path-handling-with-pathlib#Path Handling with \u003ccode\u003epathlib\u003c/code\u003e":"","practical-examples#Practical Examples":"Example 1: Reading a Configuration File def load_configuration(config_file): \"\"\" Load configuration settings from a file. Args: config_file (str): Path to the configuration file Returns: dict: Dictionary containing configuration settings \"\"\" config = {} try: with open(config_file, \"r\") as file: for line in file: # Skip empty lines and comments line = line.strip() if not line or line.startswith('#'): continue # Parse key-value pairs if '=' in line: key, value = line.split('=', 1) config[key.strip()] = value.strip() except FileNotFoundError: print(f\"Configuration file '{config_file}' not found. Using default settings.\") except Exception as e: print(f\"Error loading configuration: {e}\") return config # Example usage config = load_configuration(\"app_config.txt\") print(\"Configuration settings:\", config) Example 2: Creating a Simple Log Function def log_message(log_file, message): \"\"\" Append a message to a log file with timestamp. Args: log_file (str): Path to the log file message (str): Message to log \"\"\" import datetime timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") log_entry = f\"[{timestamp}] {message}\\n\" try: with open(log_file, \"a\") as file: file.write(log_entry) except Exception as e: print(f\"Error writing to log file: {e}\") # Example usage log_message(\"application.log\", \"Application started\") log_message(\"application.log\", \"Processing data...\") log_message(\"application.log\", \"Application stopped\") Example 3: Copying a File def copy_file(source_file, destination_file): \"\"\" Copy content from one file to another. Args: source_file (str): Path to the source file destination_file (str): Path to the destination file Returns: bool: True if successful, False otherwise \"\"\" try: # Open both files with open(source_file, \"rb\") as source, open(destination_file, \"wb\") as destination: # Read source file content content = source.read() # Write content to destination file destination.write(content) print(f\"File copied from '{source_file}' to '{destination_file}'\") return True except FileNotFoundError: print(f\"Source file '{source_file}' not found.\") except PermissionError: print(\"Permission denied. Check file permissions.\") except Exception as e: print(f\"Error copying file: {e}\") return False # Example usage success = copy_file(\"original.txt\", \"backup.txt\") if success: print(\"Backup successful\") Example 4: Checking File Information def file_info(file_path): \"\"\" Display information about a file. Args: file_path (str): Path to the file \"\"\" import os try: # Check if file exists if not os.path.exists(file_path): print(f\"File '{file_path}' does not exist.\") return # Check if it's a file (not a directory) if not os.path.isfile(file_path): print(f\"'{file_path}' is not a file.\") return # Get file stats stats = os.stat(file_path) # Convert size to readable format size_bytes = stats.st_size if size_bytes \u003c 1024: size_str = f\"{size_bytes} bytes\" elif size_bytes \u003c 1024 * 1024: size_str = f\"{size_bytes / 1024:.2f} KB\" else: size_str = f\"{size_bytes / (1024 * 1024):.2f} MB\" # Get modification time import datetime mod_time = datetime.datetime.fromtimestamp(stats.st_mtime) # Print information print(f\"File: {os.path.basename(file_path)}\") print(f\"Path: {os.path.abspath(file_path)}\") print(f\"Size: {size_str}\") print(f\"Last modified: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}\") # Try to open the file to check if it's readable with open(file_path, \"r\") as file: first_line = file.readline().strip() if first_line: if len(first_line) \u003e 50: first_line = first_line[:50] + \"...\" print(f\"First line: {first_line}\") except PermissionError: print(\"Permission denied. Cannot access file.\") except UnicodeDecodeError: print(\"File is not a text file or uses an unsupported encoding.\") except Exception as e: print(f\"Error: {e}\") # Example usage file_info(\"example.txt\") ","using-the-with-statement-context-manager#Using the \u003ccode\u003ewith\u003c/code\u003e Statement (Context Manager)":"File operations are essential for many programming tasks, from processing data to storing application settings. Python makes it straightforward to work with files through its built-in functions and methods.\nWhy Files Are Important Files allow your programs to:\nStore data persistently between program executions Process large amounts of data that wouldn’t fit in memory Share data with other programs Read data from external sources Save results for future use Basic File Operations Workflow Working with files in Python typically follows this pattern:\nOpen the file Perform operations (read from or write to the file) Close the file Opening Files with open() The open() function is the primary way to open files in Python. Its basic syntax is:\nfile_object = open(filename, mode) Where:\nfilename is a string containing the name of the file (and optionally its path) mode is a string that specifies how the file will be opened (read, write, etc.) File Opening Modes Mode Description 'r' Read - Default mode. Opens a file for reading. Raises an error if the file doesn’t exist. 'w' Write - Opens a file for writing. Creates a new file if it doesn’t exist or truncates (empties) the file if it exists. 'a' Append - Opens a file for appending. Creates a new file if it doesn’t exist. 'x' Exclusive Creation - Creates a new file. Raises an error if the file already exists. 'b' Binary - Opens a file in binary mode (e.g., 'rb' for reading binary). 't' Text - Default mode. Opens a file in text mode. '+' Update - Opens a file for both reading and writing (e.g., 'r+'). # Opening a file for reading (text mode) file = open(\"example.txt\", \"r\") # Opening a file for writing (text mode) file = open(\"output.txt\", \"w\") # Opening a file for appending (text mode) file = open(\"log.txt\", \"a\") # Opening a file for reading in binary mode file = open(\"image.jpg\", \"rb\") # Opening a file for reading and writing file = open(\"data.txt\", \"r+\") Important: When opening a file for reading ('r'), the file must already exist, or Python will raise a FileNotFoundError. When opening a file for writing ('w'), Python will create the file if it doesn’t exist, but will erase the contents if the file does exist. Be careful not to accidentally overwrite important data!\nFile Paths You can specify either a relative or absolute path to the file:\n# Relative path (relative to the current working directory) file = open(\"data.txt\", \"r\") file = open(\"data/logs/app.log\", \"r\") # Absolute path file = open(\"/home/user/documents/data.txt\", \"r\") # Unix/Linux/macOS file = open(\"C:\\\\Users\\\\user\\\\Documents\\\\data.txt\", \"r\") # Windows Note: In Windows paths, you need to use double backslashes (\\\\) because a single backslash is an escape character in Python strings. Alternatively, you can use raw strings by prefixing the string with r:\nfile = open(r\"C:\\Users\\user\\Documents\\data.txt\", \"r\") # Raw string Path Handling with pathlib For better cross-platform compatibility, consider using the pathlib module (standard in Python 3.4+):\nfrom pathlib import Path # Create a Path object file_path = Path(\"data\") / \"logs\" / \"app.log\" # Open the file using the Path object with open(file_path, \"r\") as file: content = file.read() Closing Files with close() After you’re done with a file, it’s important to close it using the close() method:\nfile = open(\"example.txt\", \"r\") # Perform operations on the file file.close() # Close the file Why Closing Files Is Important Closing files is crucial for several reasons:\nFrees up system resources Ensures all data is written to disk Prevents data corruption Allows other programs to access the file Important: If you forget to close a file, Python’s garbage collector will eventually close it when the file object is no longer referenced, but this is not guaranteed to happen immediately. Relying on garbage collection for closing files is bad practice, as it can lead to resource leaks and data loss.\nUsing the with Statement (Context Manager) The recommended way to work with files in Python is using the with statement, which automatically closes the file when the block is exited:\n# Using the with statement (recommended) with open(\"example.txt\", \"r\") as file: content = file.read() # File operations here # The file is automatically closed when exiting the with block The with statement creates a context in which the file is open, and ensures that the file is properly closed when the context is exited, even if an exception occurs.\nAdvantages of Using with Using the with statement for file operations offers several advantages:\nAutomatically closes the file, even if exceptions occur Makes code more readable and concise Follows the “Resource Acquisition Is Initialization” (RAII) pattern Reduces the chance of resource leaks # Without using with (error-prone) try: file = open(\"example.txt\", \"r\") content = file.read() # Process content finally: file.close() # Must remember to close the file # Using with (safer and cleaner) with open(\"example.txt\", \"r\") as file: content = file.read() # Process content # No need to explicitly close the file ","why-closing-files-is-important#Why Closing Files Is Important":"","why-files-are-important#Why Files Are Important":""},"title":"Opening and Closing Files"},"/python-fundamentals/06-file-operations/02-reading-and-writing-files/":{"data":{"":"File operations are essential in programming as they allow your applications to store and retrieve data persistently. Python provides simple and powerful tools for working with files of various types.","best-practices-for-file-operations#Best Practices for File Operations":" Always use context managers (with statement)\n# Good practice with open('file.txt', 'r') as file: content = file.read() # Avoid this file = open('file.txt', 'r') content = file.read() file.close() # Might not execute if an exception occurs Specify file encoding explicitly\n# Good practice with open('file.txt', 'r', encoding='utf-8') as file: content = file.read() Handle exceptions properly\ntry: with open('file.txt', 'r') as file: content = file.read() except FileNotFoundError: print(\"File not found. Creating a new one.\") with open('file.txt', 'w') as file: file.write(\"New file content\") Use appropriate file modes\n# Reading only with open('file.txt', 'r') as file: # Read operations # Writing (overwrites existing content) with open('file.txt', 'w') as file: # Write operations # Appending (preserves existing content) with open('file.txt', 'a') as file: # Append operations Process large files line by line\n# Memory efficient for large files with open('large_file.txt', 'r') as file: for line in file: process_line(line) # Avoid this for large files with open('large_file.txt', 'r') as file: content = file.read() # Loads the entire file into memory Use appropriate libraries for specific file formats\n# For CSV files import csv with open('data.csv', 'r', newline='') as file: reader = csv.reader(file) # Process CSV # For JSON files import json with open('data.json', 'r') as file: data = json.load(file) # Process JSON Create backup before overwriting important files\nimport shutil # Create a backup before modifying shutil.copy2('important_file.txt', 'important_file.txt.bak') # Modify the original file with open('important_file.txt', 'w') as file: file.write(\"New content\") Use path manipulation libraries for cross-platform compatibility\n# Good practice with pathlib from pathlib import Path data_dir = Path('data') file_path = data_dir / 'example.txt' # Alternative with os.path import os data_dir = os.path.join('data') file_path = os.path.join(data_dir, 'example.txt') ","error-handling-in-file-operations#Error Handling in File Operations":"File operations can fail for various reasons, such as missing files, permission issues, or disk errors. Proper error handling is crucial:\ntry: with open('non_existent_file.txt', 'r') as file: content = file.read() print(content) except FileNotFoundError: print(\"Error: The file does not exist.\") except PermissionError: print(\"Error: You don't have permission to access this file.\") except Exception as e: print(f\"An unexpected error occurred: {e}\") Here are common file-related exceptions:\nException Description FileNotFoundError The specified file doesn’t exist PermissionError You don’t have the required permissions IOError Input/Output operation failed IsADirectoryError You tried to open a directory as a file UnicodeDecodeError Error decoding the file with the specified encoding ","exercises#Exercises":"Exercise 1: Write a program that reads a text file and counts the occurrences of each word, then writes the results to a new file in the format “word: count”.\nExercise 2: Create a function that takes a CSV file containing student data (name, score1, score2, score3) and calculates the average score for each student. Write the results to a new CSV file with columns for name and average score.\nExercise 3: Build a simple text file encryption/decryption program that reads a file, applies a Caesar cipher (shifting each letter by a fixed number of positions), and writes the result to a new file.\nExercise 4: Create a log file analyzer that reads a log file (you can create a sample one), extracts entries between two specified dates, and saves those entries to a new file.\nHint for Exercise 1: Use a dictionary to keep track of word counts. Remember to strip punctuation and normalize word case (e.g., convert to lowercase) for accurate counting.\n# Exercise 1 solution outline def count_words(input_file, output_file): word_counts = {} with open(input_file, 'r', encoding='utf-8') as file: for line in file: words = line.strip().lower().split() for word in words: # Remove punctuation word = word.strip('.,!?\":;()[]{}') if word: word_counts[word] = word_counts.get(word, 0) + 1 with open(output_file, 'w', encoding='utf-8') as file: for word, count in sorted(word_counts.items()): file.write(f\"{word}: {count}\\n\") In the next section, we’ll explore more file operations, focusing on working with CSV and JSON files in more detail.","file-modes#File Modes":"When opening a file, you specify a mode that determines what operations you can perform:\nMode Description 'r' Read mode (default). Opens file for reading. 'w' Write mode. Creates a new file or truncates (empties) an existing file. 'a' Append mode. Opens for writing, creating the file if it doesn’t exist, but keeps existing content. 'x' Exclusive creation. Creates a new file, fails if the file already exists. 'b' Binary mode (added to other modes, e.g., 'rb', 'wb'). 't' Text mode (default, added to other modes, e.g., 'rt'). '+' Update mode (both reading and writing, added to other modes, e.g., 'r+'). # Examples of opening files with different modes with open('data.txt', 'r') as file: # Open for reading (text mode) # Read operations with open('output.txt', 'w') as file: # Open for writing (text mode) # Write operations with open('log.txt', 'a') as file: # Open for appending (text mode) # Append operations with open('image.jpg', 'rb') as file: # Open for reading (binary mode) # Binary read operations Note: The default mode is 'r' (read text) if not specified. When working with text files, Python automatically handles line ending conversions based on your operating system. When working with binary files (like images or executables), always use binary mode ('b').","opening-and-closing-files#Opening and Closing Files":"Before you can read from or write to a file, you need to open it. In Python, this is done using the built-in open() function:\n# Basic syntax file = open(filename, mode) The open() function takes two main parameters:\nfilename: The name or path of the file you want to open mode: A string that specifies how the file will be opened After you’re done with the file, it’s crucial to close it to free up system resources:\nfile.close() However, the preferred approach in Python is to use a context manager (the with statement), which automatically handles closing the file for you:\n# Recommended approach using context manager with open(filename, mode) as file: # File operations here # No need to explicitly call file.close() Important: Always use the with statement when working with files. It ensures that resources are properly managed even if exceptions occur during file operations.","practical-examples#Practical Examples":"Example 1: Log File Parser This example reads a log file and extracts specific information:\ndef parse_log_file(log_file_path): \"\"\" Parse a log file to extract error messages. Args: log_file_path (str): Path to the log file Returns: list: A list of error messages found in the log \"\"\" error_messages = [] try: with open(log_file_path, 'r', encoding='utf-8') as file: for line_number, line in enumerate(file, 1): if 'ERROR' in line: # Extract and store the error message error_messages.append(f\"Line {line_number}: {line.strip()}\") except FileNotFoundError: print(f\"Error: The log file '{log_file_path}' does not exist.\") except Exception as e: print(f\"An error occurred while parsing the log file: {e}\") return error_messages # Example usage log_errors = parse_log_file('application.log') print(f\"Found {len(log_errors)} error messages:\") for error in log_errors: print(error) Example 2: CSV Data Analyzer This example reads a CSV file containing sales data and performs some analysis:\nimport csv from datetime import datetime def analyze_sales_data(csv_file_path): \"\"\" Analyze sales data from a CSV file. Args: csv_file_path (str): Path to the CSV file Returns: dict: A dictionary containing the analysis results \"\"\" results = { 'total_sales': 0, 'average_sale': 0, 'best_selling_product': '', 'best_selling_quantity': 0, 'product_sales': {} } try: with open(csv_file_path, 'r', newline='', encoding='utf-8') as file: reader = csv.DictReader(file) sale_count = 0 for row in reader: product = row['Product'] quantity = int(row['Quantity']) price = float(row['Price']) sale_amount = quantity * price # Update total sales results['total_sales'] += sale_amount sale_count += 1 # Track product sales if product in results['product_sales']: results['product_sales'][product]['quantity'] += quantity results['product_sales'][product]['amount'] += sale_amount else: results['product_sales'][product] = { 'quantity': quantity, 'amount': sale_amount } # Check for best selling product if results['product_sales'][product]['quantity'] \u003e results['best_selling_quantity']: results['best_selling_product'] = product results['best_selling_quantity'] = results['product_sales'][product]['quantity'] # Calculate average sale if there were any sales if sale_count \u003e 0: results['average_sale'] = results['total_sales'] / sale_count except FileNotFoundError: print(f\"Error: The CSV file '{csv_file_path}' does not exist.\") except Exception as e: print(f\"An error occurred during analysis: {e}\") return results # Example usage sales_analysis = analyze_sales_data('sales_data.csv') print(f\"Total Sales: ${sales_analysis['total_sales']:.2f}\") print(f\"Average Sale: ${sales_analysis['average_sale']:.2f}\") print(f\"Best Selling Product: {sales_analysis['best_selling_product']} ({sales_analysis['best_selling_quantity']} units)\") print(\"\\nProduct Sales Breakdown:\") for product, data in sales_analysis['product_sales'].items(): print(f\"{product}: {data['quantity']} units, ${data['amount']:.2f}\") Example 3: Config File Manager This example creates a simple configuration file manager using JSON:\nimport json import os class ConfigManager: \"\"\"A class to manage configuration files in JSON format.\"\"\" def __init__(self, config_file_path): \"\"\" Initialize the ConfigManager. Args: config_file_path (str): Path to the configuration file \"\"\" self.config_file_path = config_file_path self.config = {} self.load_config() def load_config(self): \"\"\"Load the configuration from the file.\"\"\" if os.path.exists(self.config_file_path): try: with open(self.config_file_path, 'r') as file: self.config = json.load(file) print(f\"Configuration loaded from {self.config_file_path}\") except json.JSONDecodeError: print(f\"Error: The config file {self.config_file_path} is not valid JSON.\") except Exception as e: print(f\"Error loading configuration: {e}\") else: print(f\"Config file {self.config_file_path} not found. Using default settings.\") self.config = {} def save_config(self): \"\"\"Save the configuration to the file.\"\"\" try: # Ensure the directory exists os.makedirs(os.path.dirname(self.config_file_path), exist_ok=True) with open(self.config_file_path, 'w') as file: json.dump(self.config, file, indent=4) print(f\"Configuration saved to {self.config_file_path}\") except Exception as e: print(f\"Error saving configuration: {e}\") def get(self, key, default=None): \"\"\" Get a configuration value. Args: key (str): The configuration key default: The default value if the key doesn't exist Returns: The configuration value or the default \"\"\" return self.config.get(key, default) def set(self, key, value): \"\"\" Set a configuration value. Args: key (str): The configuration key value: The value to set \"\"\" self.config[key] = value def delete(self, key): \"\"\" Delete a configuration key. Args: key (str): The configuration key to delete Returns: bool: True if the key was deleted, False if it didn't exist \"\"\" if key in self.config: del self.config[key] return True return False # Example usage config = ConfigManager('app_config.json') # Get configuration values theme = config.get('theme', 'light') font_size = config.get('font_size', 12) print(f\"Current theme: {theme}, Font size: {font_size}\") # Update configuration config.set('theme', 'dark') config.set('font_size', 14) config.set('auto_save', True) # Save changes config.save_config() Example 4: Text File Backup Utility This example creates a backup of a text file before modifying it:\nimport os import shutil from datetime import datetime def backup_and_modify_file(file_path, new_content): \"\"\" Create a backup of a file and then modify its content. Args: file_path (str): Path to the file to backup and modify new_content (str): New content to write to the file Returns: bool: True if successful, False otherwise \"\"\" # Check if the file exists if not os.path.exists(file_path): print(f\"Error: The file {file_path} does not exist.\") return False try: # Create a backup filename with timestamp timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\") file_name = os.path.basename(file_path) backup_name = f\"{file_name}.{timestamp}.bak\" backup_path = os.path.join(os.path.dirname(file_path), backup_name) # Create the backup shutil.copy2(file_path, backup_path) print(f\"Backup created at {backup_path}\") # Modify the original file with open(file_path, 'w', encoding='utf-8') as file: file.write(new_content) print(f\"File {file_path} has been updated\") return True except Exception as e: print(f\"An error occurred: {e}\") return False # Example usage file_to_modify = 'important_document.txt' # Read the current content try: with open(file_to_modify, 'r') as file: current_content = file.read() print(f\"Current content:\\n{current_content}\") except FileNotFoundError: # Create the file if it doesn't exist with open(file_to_modify, 'w') as file: file.write(\"Initial content\") current_content = \"Initial content\" print(f\"File created with initial content\") # Modify the content new_content = current_content + \"\\nThis line was added on \" + datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") # Backup and modify success = backup_and_modify_file(file_to_modify, new_content) if success: print(\"Backup and modification successful\") else: print(\"Backup and modification failed\") ","reading-from-files#Reading from Files":"Python offers several methods to read from files:\nReading the Entire File # Read the entire file content as a single string with open('example.txt', 'r') as file: content = file.read() print(content) # Limit how much to read by specifying a size with open('example.txt', 'r') as file: content = file.read(10) # Read the first 10 characters print(content) Reading Line by Line # Read a single line with open('example.txt', 'r') as file: first_line = file.readline() second_line = file.readline() print(first_line) print(second_line) # Read all lines into a list with open('example.txt', 'r') as file: lines = file.readlines() print(lines) # List where each element is a line from the file # Iterate through the file line by line (memory efficient) with open('example.txt', 'r') as file: for line in file: print(line.strip()) # strip() removes the trailing newline Important: The strip() method removes whitespace characters (including newlines) from the beginning and end of a string. It’s commonly used when reading lines from a file to remove the trailing newline character.\nFile Position Files have a current position that determines where the next read or write operation will occur. You can control this position:\nwith open('example.txt', 'r') as file: # Read the first 5 characters content = file.read(5) print(content) # Get the current position position = file.tell() print(f\"Current position: {position}\") # Move to a different position (seeking) file.seek(0) # Move back to the beginning new_content = file.read(5) print(new_content) ","working-with-different-file-types#Working with Different File Types":"CSV Files CSV (Comma-Separated Values) files are commonly used for tabular data:\nimport csv # Reading CSV with open('data.csv', 'r', newline='') as file: csv_reader = csv.reader(file) # Skip the header row header = next(csv_reader) print(f\"Headers: {header}\") # Process the data rows for row in csv_reader: print(row) # Writing CSV data = [ ['Name', 'Age', 'Country'], # Header ['Alice', 30, 'USA'], ['Bob', 25, 'Canada'], ['Charlie', 35, 'UK'] ] with open('users.csv', 'w', newline='') as file: csv_writer = csv.writer(file) csv_writer.writerows(data) Note: The newline='' parameter is important when working with CSV files to ensure consistent line endings across different platforms.\nReading and Writing CSV with Dictionaries The csv module also supports working with dictionaries, which can be more intuitive:\nimport csv # Reading CSV into dictionaries with open('data.csv', 'r', newline='') as file: csv_reader = csv.DictReader(file) for row in csv_reader: print(f\"Name: {row['Name']}, Age: {row['Age']}, Country: {row['Country']}\") # Writing dictionaries to CSV data = [ {'Name': 'Alice', 'Age': 30, 'Country': 'USA'}, {'Name': 'Bob', 'Age': 25, 'Country': 'Canada'}, {'Name': 'Charlie', 'Age': 35, 'Country': 'UK'} ] with open('users.csv', 'w', newline='') as file: fieldnames = ['Name', 'Age', 'Country'] csv_writer = csv.DictWriter(file, fieldnames=fieldnames) csv_writer.writeheader() # Write the header row csv_writer.writerows(data) # Write the data rows JSON Files JSON (JavaScript Object Notation) is a lightweight data interchange format:\nimport json # Reading JSON with open('data.json', 'r') as file: data = json.load(file) print(data) # Writing JSON user = { 'name': 'Alice', 'age': 30, 'is_active': True, 'courses': ['Python', 'Data Science', 'Web Development'] } with open('user.json', 'w') as file: # The indent parameter makes the output more readable json.dump(user, file, indent=4) JSON is particularly useful for storing structured data that includes nested objects and arrays.","working-with-file-encodings#Working with File Encodings":"Text files use character encodings to represent text. The most common encoding is UTF-8, but you might encounter others:\n# Specify encoding when opening a file with open('data.txt', 'r', encoding='utf-8') as file: content = file.read() print(content) # Try different encodings if necessary encodings = ['utf-8', 'latin-1', 'cp1252'] for encoding in encodings: try: with open('data.txt', 'r', encoding=encoding) as file: content = file.read() print(f\"Successfully read with {encoding} encoding\") break except UnicodeDecodeError: print(f\"Failed to decode with {encoding} encoding\") Important: Always specify the encoding explicitly when opening text files to ensure consistent behavior across different platforms and Python versions. UTF-8 is a good default choice for most applications.","working-with-file-paths#Working with File Paths":"When working with files, you often need to handle file paths. Python’s os and pathlib modules provide cross-platform solutions:\nUsing os.path import os # Current working directory cwd = os.getcwd() print(f\"Current working directory: {cwd}\") # Join path components (works on all platforms) data_dir = os.path.join('data', 'user_files') file_path = os.path.join(data_dir, 'example.txt') print(f\"File path: {file_path}\") # Check if a file exists if os.path.exists(file_path): print(f\"The file {file_path} exists\") else: print(f\"The file {file_path} does not exist\") # Get file information if os.path.exists(file_path): size = os.path.getsize(file_path) print(f\"File size: {size} bytes\") modified_time = os.path.getmtime(file_path) print(f\"Last modified: {modified_time}\") Using pathlib (Python 3.4+) The pathlib module provides an object-oriented approach to file paths:\nfrom pathlib import Path # Current working directory cwd = Path.cwd() print(f\"Current working directory: {cwd}\") # Create a path data_dir = Path('data') / 'user_files' file_path = data_dir / 'example.txt' print(f\"File path: {file_path}\") # Check if a file exists if file_path.exists(): print(f\"The file {file_path} exists\") else: print(f\"The file {file_path} does not exist\") # Get file information if file_path.exists(): size = file_path.stat().st_size print(f\"File size: {size} bytes\") modified_time = file_path.stat().st_mtime print(f\"Last modified: {modified_time}\") # Creating directories data_dir.mkdir(parents=True, exist_ok=True) # Create parent directories if needed Note: pathlib is generally preferred in modern Python code for its simplicity and readability. It treats paths as objects with methods and properties rather than strings.","writing-to-files#Writing to Files":"Python provides several methods to write to files:\nBasic Writing # Write a string to a file with open('output.txt', 'w') as file: file.write(\"Hello, World!\\n\") file.write(\"This is a new line of text.\\n\") Writing Multiple Lines # Write multiple lines at once lines = [\"First line\\n\", \"Second line\\n\", \"Third line\\n\"] with open('output.txt', 'w') as file: file.writelines(lines) # Alternative approach with a loop lines = [\"First line\", \"Second line\", \"Third line\"] with open('output.txt', 'w') as file: for line in lines: file.write(line + '\\n') Note: The write() method doesn’t automatically add a newline character at the end of the string. If you want each write to start on a new line, you need to add \\n explicitly.\nAppending to Files If you want to add content to an existing file without overwriting it, use append mode:\n# Append to an existing file with open('log.txt', 'a') as file: file.write(\"New log entry at 2023-05-08 10:30\\n\") "},"title":"Reading and Writing Files"},"/python-fundamentals/06-file-operations/03-working-with-csv-and-json-files/":{"data":{"":"CSV (Comma-Separated Values) and JSON (JavaScript Object Notation) are two of the most common file formats used for storing and exchanging data. Python provides built-in modules to work with these formats efficiently.","best-practices-for-working-with-csv-and-json-files#Best Practices for Working with CSV and JSON Files":"CSV Best Practices Always use the newline='' parameter when opening CSV files to ensure consistent handling of line endings across platforms.\nUse DictReader and DictWriter for more readable and maintainable code, especially for files with many columns.\nHandle potential errors in data:\n# Safe value conversion try: age = int(row['Age']) except (ValueError, KeyError): age = 0 # Default value Use appropriate delimiters based on your data. If your data contains commas, consider using a different delimiter like tab (\\t) or pipe (|).\nAlways close files by using the with statement to automatically handle file closing.\nFor large files, process row by row rather than loading the entire file into memory.\nJSON Best Practices Use indent parameter for readable output when writing JSON files meant for human consumption.\nHandle potential JSON parsing errors with try-except blocks.\nBe careful with data types when working with numeric values. JSON doesn’t distinguish between integers and floats, so you might need to convert types after parsing.\nUse custom encoders and decoders for handling types not natively supported by JSON (like datetime).\nValidate JSON schema for critical applications to ensure the data meets your expectations.\nConsider using alternative libraries like ujson or simplejson for better performance with large files.","combining-csv-and-json-processing#Combining CSV and JSON Processing":"Sometimes you might need to convert between CSV and JSON formats or process data from one format to another.\nConverting CSV to JSON import csv import json def csv_to_json(csv_file, json_file): \"\"\"Convert a CSV file to a JSON file.\"\"\" # List to store the data data = [] # Read the CSV file with open(csv_file, 'r', newline='') as file: csv_reader = csv.DictReader(file) for row in csv_reader: data.append(row) # Write the JSON file with open(json_file, 'w') as file: json.dump(data, file, indent=4) print(f\"Converted {csv_file} to {json_file}\") print(f\"Processed {len(data)} records\") # Example usage csv_to_json('data.csv', 'data.json') Converting JSON to CSV import csv import json def json_to_csv(json_file, csv_file): \"\"\"Convert a JSON file to a CSV file.\"\"\" # Read the JSON file with open(json_file, 'r') as file: data = json.load(file) # Ensure data is a list if not isinstance(data, list): data = [data] # Convert single object to a list # Extract field names (column headers) if data: fieldnames = data[0].keys() else: print(\"No data found in JSON file\") return # Write the CSV file with open(csv_file, 'w', newline='') as file: writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() writer.writerows(data) print(f\"Converted {json_file} to {csv_file}\") print(f\"Processed {len(data)} records\") # Example usage json_to_csv('data.json', 'converted_data.csv') ","exercises#Exercises":"Exercise 1: Create a program that reads a CSV file containing student records (name, age, grade) and computes the average grade. Write the results to a new CSV file that includes each student’s name, grade, and whether they are above or below the average.\nExercise 2: Write a script that converts an address book from CSV to JSON format. The CSV file has columns for name, email, phone, and address. The JSON output should group contacts alphabetically by the first letter of their name.\nExercise 3: Create a program that reads weather data from a JSON file containing 7 days of forecasts. The program should calculate the average temperature, find the hottest and coldest days, and write a summary to a CSV file.\nHint for Exercise 1: Use csv.DictReader to read the file and convert the grade values to numbers before calculating the average. Then use csv.DictWriter to write the results.\nIn the next section, we’ll explore Object-Oriented Programming in Python, learning how to create and use classes and objects.","working-with-csv-files#Working with CSV Files":"CSV files store tabular data (numbers and text) in plain text. Each line of the file is a data record, and each record consists of one or more fields, separated by commas (or other delimiters).\nThe csv Module Python’s csv module provides functionality to both read from and write to CSV files.\nimport csv Reading CSV Files There are several ways to read CSV files:\nBasic CSV Reading import csv # Open the CSV file with open('data.csv', 'r', newline='') as file: # Create a CSV reader object csv_reader = csv.reader(file) # Skip the header row (if present) header = next(csv_reader) print(f\"Header: {header}\") # Process each row for row in csv_reader: print(row) # row is a list of strings Note: The newline='' parameter is important when working with CSV files to ensure consistent handling of line endings across different platforms.\nReading CSV with Different Delimiters # For TSV (Tab-Separated Values) with open('data.tsv', 'r', newline='') as file: csv_reader = csv.reader(file, delimiter='\\t') for row in csv_reader: print(row) Reading CSV into a Dictionary The DictReader class creates dictionaries for each row, mapping field names to values:\nwith open('data.csv', 'r', newline='') as file: # Create a dictionary reader object dict_reader = csv.DictReader(file) # Process each row for row in dict_reader: print(row) # row is a dictionary where keys are column names # Access fields by name print(f\"Name: {row['name']}, Age: {row['age']}\") This approach is more readable and less error-prone than accessing fields by index, especially for files with many columns.\nReading CSV Files with Custom Dialects CSV files might have different formatting conventions (quoting, escaping, etc.). You can define custom dialects to handle these:\nimport csv # Register a custom dialect csv.register_dialect('custom', delimiter=';', quotechar='\"', escapechar='\\\\', doublequote=True, skipinitialspace=True) with open('european_data.csv', 'r', newline='') as file: reader = csv.reader(file, dialect='custom') for row in reader: print(row) Writing CSV Files Writing to CSV files is similar to reading:\nBasic CSV Writing import csv data = [ ['Name', 'Age', 'City'], # Header row ['John Doe', '30', 'New York'], ['Jane Smith', '25', 'Los Angeles'], ['Bob Johnson', '45', 'Chicago'] ] with open('output.csv', 'w', newline='') as file: writer = csv.writer(file) # Write all rows at once writer.writerows(data) # Or write row by row # for row in data: # writer.writerow(row) Writing Dictionaries to CSV import csv data = [ {'Name': 'John Doe', 'Age': '30', 'City': 'New York'}, {'Name': 'Jane Smith', 'Age': '25', 'City': 'Los Angeles'}, {'Name': 'Bob Johnson', 'Age': '45', 'City': 'Chicago'} ] with open('output.csv', 'w', newline='') as file: # Define column names (field names) fieldnames = ['Name', 'Age', 'City'] # Create a dictionary writer object writer = csv.DictWriter(file, fieldnames=fieldnames) # Write the header row writer.writeheader() # Write all rows at once writer.writerows(data) # Or write row by row # for row in data: # writer.writerow(row) Practical Example: CSV Data Processing Let’s see a practical example of reading a CSV file, processing the data, and writing the results back to a new CSV file:\nimport csv def calculate_statistics(filename): \"\"\"Calculate average age and salary by department from a CSV file.\"\"\" departments = {} with open(filename, 'r', newline='') as file: reader = csv.DictReader(file) for row in reader: dept = row['Department'] age = int(row['Age']) salary = float(row['Salary'].replace('$', '').replace(',', '')) if dept not in departments: departments[dept] = {'count': 0, 'total_age': 0, 'total_salary': 0} departments[dept]['count'] += 1 departments[dept]['total_age'] += age departments[dept]['total_salary'] += salary # Calculate averages results = [] for dept, data in departments.items(): count = data['count'] avg_age = data['total_age'] / count avg_salary = data['total_salary'] / count results.append({ 'Department': dept, 'Employee Count': count, 'Average Age': round(avg_age, 1), 'Average Salary': f\"${round(avg_salary, 2):,.2f}\" }) # Sort by department name results.sort(key=lambda x: x['Department']) # Write results to a new CSV file output_file = 'department_statistics.csv' with open(output_file, 'w', newline='') as file: fieldnames = ['Department', 'Employee Count', 'Average Age', 'Average Salary'] writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() writer.writerows(results) print(f\"Statistics saved to {output_file}\") return results # Example usage statistics = calculate_statistics('employee_data.csv') for stat in statistics: print(f\"{stat['Department']}: {stat['Employee Count']} employees, \" f\"Avg Age: {stat['Average Age']}, Avg Salary: {stat['Average Salary']}\") Important: When processing CSV files with numerical data, remember that all values are read as strings. You need to convert them to the appropriate data types before performing calculations.\nHandling Common CSV Challenges Dealing with Missing Values with open('data_with_missing.csv', 'r', newline='') as file: reader = csv.DictReader(file) for row in reader: # Handle missing values with get() method and provide default name = row.get('Name', 'Unknown') # Or use conditional logic age = row['Age'] if row['Age'] else 'Not specified' print(f\"Name: {name}, Age: {age}\") Handling Large CSV Files For large CSV files, reading the entire file into memory might not be feasible. Process it row by row instead:\ndef process_large_csv(filename): row_count = 0 total = 0 with open(filename, 'r', newline='') as file: reader = csv.DictReader(file) for row in reader: # Process one row at a time value = float(row['Value']) total += value row_count += 1 # Optionally, report progress periodically if row_count % 100000 == 0: print(f\"Processed {row_count} rows...\") avg = total / row_count if row_count \u003e 0 else 0 print(f\"Processed {row_count} rows. Average value: {avg:.2f}\") ","working-with-json-files#Working with JSON Files":"JSON (JavaScript Object Notation) is a lightweight data interchange format. It’s easy for humans to read and write and easy for machines to parse and generate.\nThe json Module Python’s json module provides methods to encode Python objects as JSON strings and decode JSON strings into Python objects.\nimport json Reading JSON Files Loading JSON from a File import json with open('data.json', 'r') as file: # Parse JSON into a Python object data = json.load(file) # Now data is a Python object (typically a dict or list) print(type(data)) print(data) Working with Nested JSON Data JSON often contains nested structures. You can access them using standard Python dictionary and list operations:\nwith open('nested_data.json', 'r') as file: data = json.load(file) # Access nested elements name = data['person']['name'] first_hobby = data['person']['hobbies'][0] print(f\"Name: {name}\") print(f\"First hobby: {first_hobby}\") # Iterate through nested lists print(\"All hobbies:\") for hobby in data['person']['hobbies']: print(f\"- {hobby}\") Writing JSON Files Saving Python Objects as JSON import json # Python dictionary person = { 'name': 'John Doe', 'age': 30, 'city': 'New York', 'hobbies': ['reading', 'hiking', 'photography'], 'is_student': False, 'has_car': None } # Write to a JSON file with open('person.json', 'w') as file: json.dump(person, file) # Write with pretty formatting (indentation) with open('person_pretty.json', 'w') as file: json.dump(person, file, indent=4) Controlling JSON Serialization You can customize how objects are serialized to JSON:\nimport json from datetime import datetime # Custom data with objects that aren't JSON serializable by default data = { 'name': 'Event Log', 'created_at': datetime.now(), 'entries': [ {'id': 1, 'timestamp': datetime(2023, 1, 15, 10, 30), 'message': 'System started'}, {'id': 2, 'timestamp': datetime(2023, 1, 15, 11, 45), 'message': 'User logged in'} ] } # Define a custom JSON encoder class DateTimeEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, datetime): return obj.isoformat() return super().default(obj) # Use the custom encoder with open('logs.json', 'w') as file: json.dump(data, file, cls=DateTimeEncoder, indent=4) Converting Between JSON and Python Objects JSON to Python Object (Deserialization) # JSON string json_string = '{\"name\": \"Jane Smith\", \"age\": 25, \"city\": \"London\"}' # Convert JSON string to Python object person = json.loads(json_string) print(f\"Name: {person['name']}, Age: {person['age']}\") Python Object to JSON String (Serialization) # Python dictionary person = {'name': 'Bob Johnson', 'age': 45, 'city': 'Chicago'} # Convert Python object to JSON string json_string = json.dumps(person) print(json_string) # Pretty print with indentation pretty_json = json.dumps(person, indent=4) print(pretty_json) Practical Example: JSON Configuration File Let’s see how to use JSON for a configuration file:\nimport json import os def load_config(config_file='config.json'): \"\"\"Load application configuration from a JSON file.\"\"\" # Default configuration default_config = { 'app_name': 'My Application', 'version': '1.0.0', 'debug_mode': False, 'log_level': 'INFO', 'max_connections': 100, 'themes': ['light', 'dark', 'system'], 'default_theme': 'system', 'data_sources': { 'primary': { 'type': 'mysql', 'host': 'localhost', 'port': 3306, 'username': '', 'password': '' }, 'cache': { 'type': 'redis', 'host': 'localhost', 'port': 6379 } } } # Try to load configuration from file config = default_config.copy() try: if os.path.exists(config_file): with open(config_file, 'r') as file: loaded_config = json.load(file) # Update default config with loaded values config.update(loaded_config) print(f\"Configuration loaded from {config_file}\") else: # Create a new config file with default values with open(config_file, 'w') as file: json.dump(default_config, file, indent=4) print(f\"Created new configuration file: {config_file}\") except Exception as e: print(f\"Error loading configuration: {e}\") print(\"Using default configuration\") return config def save_config(config, config_file='config.json'): \"\"\"Save the configuration to a JSON file.\"\"\" try: with open(config_file, 'w') as file: json.dump(config, file, indent=4) print(f\"Configuration saved to {config_file}\") return True except Exception as e: print(f\"Error saving configuration: {e}\") return False # Example usage config = load_config() print(f\"App name: {config['app_name']}\") print(f\"Debug mode: {config['debug_mode']}\") # Modify configuration config['debug_mode'] = True config['log_level'] = 'DEBUG' config['data_sources']['primary']['username'] = 'admin' # Save modified configuration save_config(config) Practical Example: Working with an API Response Many web APIs return data in JSON format. Here’s how you might work with such data:\nimport json import requests # You'll need to install this: pip install requests def get_weather(city, api_key): \"\"\"Get current weather data for a city using a weather API.\"\"\" base_url = \"https://api.openweathermap.org/data/2.5/weather\" params = { 'q': city, 'appid': api_key, 'units': 'metric' # or 'imperial' for Fahrenheit } try: response = requests.get(base_url, params=params) # Check if the request was successful if response.status_code == 200: # Parse JSON response weather_data = json.loads(response.text) # Extract relevant information result = { 'city': weather_data['name'], 'country': weather_data['sys']['country'], 'temperature': weather_data['main']['temp'], 'feels_like': weather_data['main']['feels_like'], 'description': weather_data['weather'][0]['description'], 'humidity': weather_data['main']['humidity'], 'wind_speed': weather_data['wind']['speed'] } return result else: print(f\"Error: API returned status code {response.status_code}\") print(f\"Response: {response.text}\") return None except requests.exceptions.RequestException as e: print(f\"Request error: {e}\") return None except json.JSONDecodeError as e: print(f\"JSON parsing error: {e}\") return None except KeyError as e: print(f\"Data extraction error: {e}\") return None # Example usage (you need to provide your own API key) api_key = \"your_api_key_here\" weather = get_weather(\"London\", api_key) if weather: print(f\"Weather in {weather['city']}, {weather['country']}:\") print(f\"Temperature: {weather['temperature']}°C (Feels like: {weather['feels_like']}°C)\") print(f\"Description: {weather['description']}\") print(f\"Humidity: {weather['humidity']}%\") print(f\"Wind speed: {weather['wind_speed']} m/s\") "},"title":"Working with CSV and JSON Files"},"/python-fundamentals/06-file-operations/04-error-handling-in-file-operations/":{"data":{"":"When working with files in Python, many things can go wrong: files might not exist, you might not have the necessary permissions, or the disk could be full. Proper error handling ensures your program can respond gracefully to these issues rather than crashing unexpectedly.","common-file-error-handling-patterns#Common File Error Handling Patterns":"1. Checking If a File Exists Before Opening import os def read_if_exists(file_path): \"\"\"Read a file only if it exists.\"\"\" if not os.path.isfile(file_path): print(f\"Warning: '{file_path}' does not exist\") return None try: with open(file_path, 'r') as file: return file.read() except Exception as e: print(f\"Error reading file: {e}\") return None 2. Safe File Deletion import os def safe_delete_file(file_path): \"\"\"Safely delete a file if it exists.\"\"\" try: if os.path.isfile(file_path): os.remove(file_path) return True, f\"File '{file_path}' deleted successfully\" else: return False, f\"File '{file_path}' does not exist\" except PermissionError: return False, f\"Permission denied: Cannot delete '{file_path}'\" except Exception as e: return False, f\"Error deleting file: {e}\" 3. Creating Backup Before Modifying import os import shutil def modify_with_backup(file_path, modification_func): \"\"\" Create a backup of a file before modifying it. Args: file_path (str): The file to modify modification_func (callable): A function that takes file content and returns modified content Returns: tuple: (success_flag, result_or_error_message) \"\"\" backup_path = file_path + \".bak\" try: # Check if file exists if not os.path.isfile(file_path): return False, f\"File '{file_path}' does not exist\" # Create backup try: shutil.copy2(file_path, backup_path) except Exception as e: return False, f\"Error creating backup: {e}\" # Read the file try: with open(file_path, 'r') as file: content = file.read() except Exception as e: return False, f\"Error reading file: {e}\" # Modify the content try: modified_content = modification_func(content) except Exception as e: return False, f\"Error in modification function: {e}\" # Write back to the file try: with open(file_path, 'w') as file: file.write(modified_content) except Exception as e: # Try to restore from backup if write fails try: shutil.copy2(backup_path, file_path) except: pass return False, f\"Error writing to file: {e}\" return True, f\"File modified successfully. Backup saved as '{backup_path}'\" except Exception as e: return False, f\"Unexpected error: {e}\" # Example usage def uppercase_content(content): return content.upper() success, message = modify_with_backup(\"example.txt\", uppercase_content) print(message) ","common-file-operation-errors#Common File Operation Errors":"Before diving into error handling techniques, let’s understand the common errors you might encounter when working with files:\nFileNotFoundError: Occurs when trying to open a file that doesn’t exist PermissionError: Occurs when you don’t have the necessary permissions to access a file IsADirectoryError: Occurs when you try to open a directory as a file FileExistsError: Occurs when trying to create a file that already exists (with certain modes) IOError or OSError: General errors for input/output operations UnicodeDecodeError: Occurs when a file can’t be decoded with the specified encoding ","ensuring-directories-exist#Ensuring Directories Exist":"A common issue when writing files is that the directory may not exist. Here’s a function that creates the directory if needed:\nimport os def ensure_directory_exists(directory_path): \"\"\" Ensure that a directory exists, creating it if necessary. Args: directory_path (str): The directory path to check/create Returns: tuple: (success_flag, None_or_error_message) \"\"\" try: if not os.path.exists(directory_path): os.makedirs(directory_path) return True, None except PermissionError: return False, f\"Error: You don't have permission to create '{directory_path}'.\" except Exception as e: return False, f\"Error: An unexpected error occurred: {e}\" # Usage with write_file_safely def write_with_directory_check(file_path, content): # Extract the directory path directory = os.path.dirname(file_path) # If there's a directory part, ensure it exists if directory: dir_success, dir_error = ensure_directory_exists(directory) if not dir_success: return False, dir_error # Write the file return write_file_safely(file_path, content) # Example usage success, error = write_with_directory_check(\"new_folder/test.txt\", \"This is a test\") if not success: print(error) else: print(\"File written successfully\") ","exercises#Exercises":"Exercise 1: Write a function called safe_read_lines that safely reads lines from a file and returns them as a list. If any error occurs, the function should return an empty list and print an appropriate error message.\nExercise 2: Create a function that merges the contents of two files into a third file. Include proper error handling for all file operations. Test your function with both existing and non-existing files.\nExercise 3: Write a program that reads a CSV file containing student records (name, course, grade) and calculates the average grade for each course. Handle all possible errors, including missing files, malformed CSV data, and invalid grades.\nExercise 4: Create a function that recursively searches a directory for files with a specific extension (e.g., .txt) and performs an operation on each one (e.g., counts the number of lines). Handle all possible errors, including permission issues and malformed files.\nHint for Exercise 1: Use a try-except block with the with statement to safely open and read the file. Handle specific exceptions like FileNotFoundError and PermissionError separately.\n# Exercise 1 solution outline def safe_read_lines(file_path): try: with open(file_path, 'r') as file: return file.readlines() except FileNotFoundError: print(f\"Error: The file '{file_path}' was not found.\") except PermissionError: print(f\"Error: You don't have permission to read '{file_path}'.\") except Exception as e: print(f\"An unexpected error occurred: {e}\") return [] # Return empty list on any error In the next section, we’ll explore Object-Oriented Programming in Python, starting with classes and objects.","file-locking-for-concurrent-access#File Locking for Concurrent Access":"When multiple processes might access the same file, file locking becomes important. Here’s an example using the fcntl module (Unix/Linux/Mac) or the msvcrt module (Windows):\ndef append_to_log_with_lock(log_file, message): \"\"\" Append a message to a log file with file locking to prevent conflicts. Args: log_file (str): Path to the log file message (str): Message to append Returns: bool: True if successful, False otherwise \"\"\" import platform import time # Format timestamp timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\") log_entry = f\"[{timestamp}] {message}\\n\" try: # Open file for appending with open(log_file, 'a') as file: # Try to acquire a lock before writing if platform.system() == 'Windows': # Windows locking import msvcrt msvcrt.locking(file.fileno(), msvcrt.LK_LOCK, len(log_entry)) file.write(log_entry) # Release the lock file.seek(0) # Go to the beginning of the locked region msvcrt.locking(file.fileno(), msvcrt.LK_UNLCK, len(log_entry)) else: # Unix-based locking import fcntl fcntl.flock(file, fcntl.LOCK_EX) # Exclusive lock file.write(log_entry) fcntl.flock(file, fcntl.LOCK_UN) # Release lock return True except Exception as e: print(f\"Error writing to log: {e}\") return False # Example usage append_to_log_with_lock(\"application.log\", \"User logged in\") Note: For production applications, consider using established logging solutions like Python’s built-in logging module, which handles many of these concerns automatically.","handling-large-files#Handling Large Files":"When dealing with large files, reading the entire content into memory might not be feasible. Here’s how to process a large file line by line:\ndef process_large_file(file_path, process_line_func): \"\"\" Process a large file line by line without loading it entirely into memory. Args: file_path (str): Path to the large file process_line_func (callable): Function to process each line Returns: tuple: (success_flag, result_or_error_message) \"\"\" try: line_count = 0 with open(file_path, 'r') as file: for line_num, line in enumerate(file, 1): try: process_line_func(line.strip(), line_num) line_count += 1 except Exception as e: return False, f\"Error processing line {line_num}: {e}\" return True, f\"Successfully processed {line_count} lines\" except FileNotFoundError: return False, f\"Error: The file '{file_path}' was not found.\" except PermissionError: return False, f\"Error: You don't have permission to read '{file_path}'.\" except Exception as e: return False, f\"Error: {e}\" # Example usage: Count words in each line def count_words_in_line(line, line_num): words = line.split() print(f\"Line {line_num}: {len(words)} words\") success, result = process_large_file(\"large_document.txt\", count_words_in_line) print(result) ","practical-example-robust-file-reading#Practical Example: Robust File Reading":"Let’s create a function that reads a file’s content with comprehensive error handling:\ndef read_file_safely(file_path, encoding=\"utf-8\"): \"\"\" Safely read a file's content with comprehensive error handling. Args: file_path (str): The path to the file to read encoding (str): The character encoding to use (default: utf-8) Returns: tuple: (success_flag, content_or_error_message) \"\"\" try: with open(file_path, \"r\", encoding=encoding) as file: content = file.read() return True, content except FileNotFoundError: return False, f\"Error: The file '{file_path}' was not found.\" except PermissionError: return False, f\"Error: You don't have permission to read '{file_path}'.\" except IsADirectoryError: return False, f\"Error: '{file_path}' is a directory, not a file.\" except UnicodeDecodeError: return False, f\"Error: The file '{file_path}' couldn't be decoded with {encoding} encoding.\" except Exception as e: return False, f\"Error: An unexpected error occurred: {e}\" # Usage example success, result = read_file_safely(\"sample.txt\") if success: print(\"File content:\") print(result) else: print(result) # Print the error message This function returns a tuple with a success flag and either the file content or an error message, making it easy to handle both successful and failed file operations.","practical-example-robust-file-writing#Practical Example: Robust File Writing":"Similarly, here’s a function for safely writing to a file:\ndef write_file_safely(file_path, content, mode=\"w\", encoding=\"utf-8\"): \"\"\" Safely write content to a file with comprehensive error handling. Args: file_path (str): The path to the file to write content (str): The content to write to the file mode (str): The file mode ('w' for write, 'a' for append) encoding (str): The character encoding to use (default: utf-8) Returns: tuple: (success_flag, None_or_error_message) \"\"\" try: with open(file_path, mode, encoding=encoding) as file: file.write(content) return True, None except PermissionError: return False, f\"Error: You don't have permission to write to '{file_path}'.\" except IsADirectoryError: return False, f\"Error: '{file_path}' is a directory, not a file.\" except FileNotFoundError: # This can occur if intermediate directories don't exist return False, f\"Error: The directory for '{file_path}' does not exist.\" except Exception as e: return False, f\"Error: An unexpected error occurred: {e}\" # Usage example content_to_write = \"Hello, World!\\nThis is a test file.\" success, error = write_file_safely(\"output/test.txt\", content_to_write) if not success: print(error) # Print the error message else: print(f\"Content successfully written to 'output/test.txt'\") ","practical-example-safe-csv-processing#Practical Example: Safe CSV Processing":"Let’s create a more complex example of safely processing a CSV file with error handling at multiple levels:\nimport csv def safe_csv_processor(csv_path, output_path=None): \"\"\" Safely reads a CSV file, processes the data, and optionally writes results. Args: csv_path (str): Path to the input CSV file output_path (str, optional): Path for output CSV with processed data Returns: tuple: (success_flag, result_or_error_message) \"\"\" try: rows = [] row_count = 0 error_count = 0 # Read and process the CSV file try: with open(csv_path, 'r', newline='') as csv_file: reader = csv.reader(csv_file) # Get the header row try: header = next(reader) except StopIteration: return False, \"Error: CSV file is empty\" # Process each data row for row_num, row in enumerate(reader, 2): # Start at 2 (header is row 1) try: # Skip empty rows if not any(row): continue # Ensure row has the correct number of columns if len(row) != len(header): print(f\"Warning: Row {row_num} has {len(row)} columns, expected {len(header)}\") row = row[:len(header)] # Truncate if too long row.extend([''] * (len(header) - len(row))) # Pad if too short # Process the row (example: capitalize all text fields) processed_row = [str(cell).capitalize() for cell in row] rows.append(processed_row) row_count += 1 except Exception as e: error_count += 1 print(f\"Error processing row {row_num}: {e}\") # Continue processing other rows except csv.Error as e: return False, f\"CSV parsing error: {e}\" # Write output file if requested if output_path: try: with open(output_path, 'w', newline='') as out_file: writer = csv.writer(out_file) writer.writerow(header) # Write header writer.writerows(rows) # Write processed rows except Exception as e: return False, f\"Error writing output file: {e}\" return True, f\"Successfully processed {row_count} rows with {error_count} errors. Output written to {output_path}\" # If no output file, return the processed data return True, { \"header\": header, \"rows\": rows, \"row_count\": row_count, \"error_count\": error_count } except FileNotFoundError: return False, f\"Error: The file '{csv_path}' was not found.\" except PermissionError: return False, f\"Error: Permission error accessing '{csv_path}'.\" except Exception as e: return False, f\"Unexpected error: {e}\" # Example usage success, result = safe_csv_processor(\"data.csv\", \"processed_data.csv\") if success: print(result) else: print(f\"Processing failed: {result}\") ","using-try-except-for-error-handling#Using try-except for Error Handling":"The primary mechanism for handling errors in Python is the try-except statement. This allows you to “try” a block of code and “catch” specific exceptions if they occur.\nBasic Structure try: # Code that might raise an exception file = open(\"data.txt\", \"r\") content = file.read() file.close() except FileNotFoundError: # Code to handle the specific exception print(\"Error: The file 'data.txt' was not found.\") Handling Multiple Exception Types You can catch different types of exceptions and handle them accordingly:\ntry: file = open(\"data.txt\", \"r\") content = file.read() file.close() except FileNotFoundError: print(\"Error: The file does not exist.\") except PermissionError: print(\"Error: You don't have permission to read this file.\") except Exception as e: # Catch any other exceptions print(f\"An unexpected error occurred: {e}\") The else Clause You can use an else clause that executes only if no exceptions occur:\ntry: file = open(\"data.txt\", \"r\") content = file.read() file.close() except FileNotFoundError: print(\"Error: The file does not exist.\") else: # This block executes if no exceptions were raised in the try block print(f\"File successfully read. Content length: {len(content)} characters\") The finally Clause The finally clause executes regardless of whether an exception occurred:\ntry: file = open(\"data.txt\", \"r\") content = file.read() except FileNotFoundError: print(\"Error: The file does not exist.\") finally: # This block always executes try: file.close() except: pass # In case file wasn't opened successfully print(\"File operation attempt completed.\") Important: When using the finally clause to close a file, you need to handle the case where the file might not have been successfully opened. This is why using the with statement, as explained below, is often a better approach.","using-with-statement-context-manager#Using with Statement (Context Manager)":"The with statement provides a cleaner way to handle files, automatically closing them even if an exception occurs:\ntry: with open(\"data.txt\", \"r\") as file: content = file.read() # File is automatically closed when the with block ends except FileNotFoundError: print(\"Error: The file does not exist.\") except PermissionError: print(\"Error: You don't have permission to read this file.\") This approach is preferred because:\nIt automatically closes the file, even if an exception occurs It’s more concise and readable It reduces the chances of resource leaks ","working-with-temporary-files-safely#Working with Temporary Files Safely":"When you need to work with temporary files, Python’s tempfile module provides a secure way to do so:\nimport tempfile import os def process_data_in_temp_file(data): \"\"\"Process data in a temporary file that is automatically cleaned up.\"\"\" try: # Create a temporary file with tempfile.NamedTemporaryFile(mode='w+t', delete=False) as temp: temp_path = temp.name # Write data to the temporary file temp.write(data) temp.flush() # Ensure all data is written # Now the file is closed but still exists # Process the file (e.g., read it back) with open(temp_path, 'r') as file: processed_data = file.read().upper() # Example: convert to uppercase # Clean up by removing the temporary file os.unlink(temp_path) return True, processed_data except Exception as e: # Clean up if possible try: os.unlink(temp_path) except: pass return False, f\"Error processing data: {e}\" # Example usage success, result = process_data_in_temp_file(\"This is test data\") if success: print(f\"Processed data: {result}\") else: print(result) # Print error message "},"title":"Error Handling in File Operations"},"/python-fundamentals/07-object-oriented-programming/":{"data":{"":"Object-Oriented Programming (OOP) is a powerful paradigm that allows you to structure your code around objects that combine data and functionality.\nIn Python, everything is an object, making it a truly object-oriented language that implements OOP principles in an elegant and accessible way.\nThis approach helps you create modular, reusable code that’s easier to maintain, especially for larger projects where organization becomes crucial. OOP enables you to model real-world entities in your code, creating intuitive representations of the problems you’re trying to solve.\nHere is what Object-Oriented Programming section covers:\n01. Classes and Objects in Python 02. Attributes and Methods 03. Constructors in Python 04. Inheritance 05. Polymorphism 06. Encapsulation in Python "},"title":"Object-Oriented Programming"},"/python-fundamentals/07-object-oriented-programming/01-classes-and-objects/":{"data":{"":"","best-practices#Best Practices":"1. Follow Naming Conventions Class names should use CapWords convention (e.g., BankAccount). Method and attribute names should use lowercase with underscores (e.g., calculate_interest). Protected attributes should have a single leading underscore (e.g., _balance). “Private” attributes should have double leading underscores (e.g., __account_num). 2. Use Properties for Attribute Access Control Instead of direct attribute access, use properties for validation and computed attributes:\nclass Temperature: def __init__(self, celsius=0): self._celsius = celsius @property def celsius(self): return self._celsius @celsius.setter def celsius(self, value): if value \u003c -273.15: raise ValueError(\"Temperature cannot be below absolute zero\") self._celsius = value @property def fahrenheit(self): return self._celsius * 9/5 + 32 @fahrenheit.setter def fahrenheit(self, value): self.celsius = (value - 32) * 5/9 3. Write Clear Docstrings Document your classes and methods with informative docstrings:\nclass BankAccount: \"\"\" A class representing a bank account. Attributes: owner (str): The name of the account owner. balance (float): The current account balance. \"\"\" def __init__(self, owner, balance=0): \"\"\" Initialize a new BankAccount. Args: owner (str): The name of the account owner. balance (float, optional): The initial balance. Defaults to 0. \"\"\" self.owner = owner self.balance = balance def deposit(self, amount): \"\"\" Deposit money into the account. Args: amount (float): The amount to deposit. Returns: float: The new balance. Raises: ValueError: If amount is negative. \"\"\" if amount \u003c 0: raise ValueError(\"Cannot deposit negative amount\") self.balance += amount return self.balance 4. Keep Classes Focused Each class should have a single responsibility. If a class is doing too many things, consider splitting it into multiple classes:\n# Instead of one large class class CustomerOrder: def __init__(self, customer_name, items): self.customer_name = customer_name self.items = items # Methods for customer info, order processing, payment, shipping, etc. # Better approach: Split into focused classes class Customer: def __init__(self, name, email, address): self.name = name self.email = email self.address = address class Order: def __init__(self, customer, items): self.customer = customer self.items = items self.total = sum(item.price for item in items) class PaymentProcessor: def process_payment(self, order, payment_method): # Payment processing logic pass class ShippingManager: def ship_order(self, order): # Shipping logic pass ","class-methods-and-static-methods#Class Methods and Static Methods":"Python allows you to define methods that are bound to the class rather than its instances:\nClass Methods Class methods are methods that are bound to the class rather than its instances. They can access and modify class state. You define a class method using the @classmethod decorator:\nclass Person: # Class attribute count = 0 def __init__(self, name): self.name = name # Increment the count when a new instance is created Person.count += 1 @classmethod def number_of_people(cls): return cls.count @classmethod def create_anonymous(cls): return cls(\"Anonymous\") # Create instances person1 = Person(\"Alice\") person2 = Person(\"Bob\") # Call class method print(Person.number_of_people()) # Output: 2 # Create an instance using a class method anonymous = Person.create_anonymous() print(anonymous.name) # Output: Anonymous print(Person.number_of_people()) # Output: 3 Class methods receive the class itself as the first parameter, conventionally named cls.\nStatic Methods Static methods are methods that are bound to the class but don’t access or modify class or instance state. You define a static method using the @staticmethod decorator:\nclass MathUtils: @staticmethod def add(x, y): return x + y @staticmethod def multiply(x, y): return x * y # Call static methods directly on the class print(MathUtils.add(5, 3)) # Output: 8 print(MathUtils.multiply(5, 3)) # Output: 15 # You can also call static methods on instances, but it's not common practice math = MathUtils() print(math.add(5, 3)) # Output: 8 Static methods don’t receive a special first parameter. They behave like regular functions but belong to the class’s namespace.\nImportant:\nUse instance methods when you need to access or modify instance state. Use class methods when you need to access or modify class state. Use static methods when you don’t need to access or modify instance or class state. ","common-mistakes-and-gotchas#Common Mistakes and Gotchas":"1. Forgetting self Parameter One of the most common mistakes is forgetting to include self as the first parameter in instance methods:\nclass Counter: def __init__(self): self.count = 0 # Incorrect: missing self parameter def increment(): self.count += 1 # This will raise an error # Correct def decrement(self): self.count -= 1 2. Modifying Class Variables Unintentionally As we saw earlier, modifying mutable class variables affects all instances:\nclass MyClass: shared_list = [] # Shared among all instances def add_item(self, item): self.shared_list.append(item) # Modifies the class variable for all instances 3. Shadow Instance Variables If an instance variable has the same name as a class variable, it shadows (hides) the class variable:\nclass Example: value = 10 # Class variable def update_value(self, new_value): self.value = new_value # Creates an instance variable, doesn't affect the class variable e1 = Example() e2 = Example() print(e1.value) # Output: 10 e1.update_value(20) print(e1.value) # Output: 20 print(e2.value) # Output: 10 (unchanged) print(Example.value) # Output: 10 (unchanged) 4. Circular References Circular references can prevent objects from being garbage collected:\nclass Node: def __init__(self, value): self.value = value self.next = None # Create a circular reference node1 = Node(1) node2 = Node(2) node1.next = node2 node2.next = node1 # Circular reference # These objects reference each other, so they won't be garbage collected # until the reference is explicitly broken ","creating-a-class#Creating a Class":"In Python, you define a class using the class keyword:\nclass Dog: # Class attribute - shared by all instances species = \"Canis familiaris\" # Initializer / Constructor def __init__(self, name, age): # Instance attributes - unique to each instance self.name = name self.age = age # Instance method def description(self): return f\"{self.name} is {self.age} years old\" # Another instance method def speak(self, sound): return f\"{self.name} says {sound}\" Let’s break down this class definition:\nclass Dog: - This declares a new class named Dog. species = \"Canis familiaris\" - This is a class attribute, shared by all instances of the class. def __init__(self, name, age): - This is the initializer method (constructor). It’s called when you create a new instance. The self parameter refers to the instance being created. self.name = name - Creating instance attributes by assigning values to self.\u003cattribute_name\u003e. def description(self): - This is an instance method. It can access and modify the instance’s attributes via the self parameter. Note: In Python methods, the first parameter is always a reference to the current instance of the class. By convention, this parameter is named self, but you could technically use any name (though it’s strongly recommended to stick with the convention).","creating-objects-instances#Creating Objects (Instances)":"Once you’ve defined a class, you can create objects (instances) of that class:\n# Create instances of the Dog class buddy = Dog(\"Buddy\", 9) miles = Dog(\"Miles\", 4) # Access attributes print(buddy.name) # Output: Buddy print(miles.age) # Output: 4 # Access class attribute through instances print(buddy.species) # Output: Canis familiaris print(miles.species) # Output: Canis familiaris # Access class attribute through the class itself print(Dog.species) # Output: Canis familiaris # Call methods print(buddy.description()) # Output: Buddy is 9 years old print(miles.speak(\"Woof\")) # Output: Miles says Woof Each object has its own set of attributes (like name and age) but shares class attributes (like species).","exercises#Exercises":"Exercise 1: Create a Rectangle class with attributes for width and height. Include methods to calculate the area and perimeter. Add a method is_square() that returns True if the rectangle is a square.\nExercise 2: Create a BankAccount class with methods for deposit and withdrawal. Ensure that withdrawals cannot exceed the account balance. Add a method to display the account details.\nExercise 3: Design a Student class to track student information. Include attributes for name, ID, and a list of courses. Add methods to add a course, drop a course, and calculate the GPA based on course grades.\nExercise 4: Create a ShoppingCart class that simulates an online shopping cart. Allow users to add items, remove items, and calculate the total cost. Each item should have a name, price, and quantity.\nHint for Exercise 1:\nclass Rectangle: def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) def is_square(self): return self.width == self.height In the next section, we’ll explore the concept of inheritance, which allows you to create new classes that inherit attributes and methods from existing classes.","instance-methods-in-detail#Instance Methods in Detail":"Instance methods are functions defined within a class that operate on instances of that class. They always take self as their first parameter:\nclass Rectangle: def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) def resize(self, width, height): self.width = width self.height = height return self.area() # Returns the new area # Create a rectangle rect = Rectangle(10, 5) print(f\"Area: {rect.area()}\") # Output: Area: 50 print(f\"Perimeter: {rect.perimeter()}\") # Output: Perimeter: 30 # Resize the rectangle and get the new area new_area = rect.resize(20, 10) print(f\"New area: {new_area}\") # Output: New area: 200 ","instance-variables-vs-class-variables#Instance Variables vs. Class Variables":"Understanding the difference between instance variables and class variables is critical:\nclass Dog: # Class variable species = \"Canis familiaris\" # Class variable (mutable - be careful!) tricks = [] def __init__(self, name): # Instance variable self.name = name def add_trick(self, trick): # This modifies the class variable! self.tricks.append(trick) # Create two dogs dog1 = Dog(\"Buddy\") dog2 = Dog(\"Max\") # Add a trick for dog1 dog1.add_trick(\"roll over\") print(dog1.tricks) # Output: ['roll over'] # But dog2 also has the trick! print(dog2.tricks) # Output: ['roll over'] This behavior might be surprising! Since tricks is a class variable and lists are mutable, changes to it affect all instances. The correct approach for instance-specific lists:\nclass Dog: # Class variable species = \"Canis familiaris\" def __init__(self, name): # Instance variable self.name = name # Initialize an empty list for each instance self.tricks = [] def add_trick(self, trick): # This modifies the instance variable self.tricks.append(trick) # Create two dogs dog1 = Dog(\"Buddy\") dog2 = Dog(\"Max\") # Add a trick for dog1 dog1.add_trick(\"roll over\") print(dog1.tricks) # Output: ['roll over'] # dog2's tricks are separate print(dog2.tricks) # Output: [] Note: Be cautious when using mutable types (like lists or dictionaries) as class variables. If you want each instance to have its own copy, initialize them in the __init__ method as instance variables.","practical-example-building-a-library-system#Practical Example: Building a Library System":"Let’s build a more complex example of a library system using classes and objects:\nclass Book: def __init__(self, title, author, isbn, publication_year, available=True): self.title = title self.author = author self.isbn = isbn self.publication_year = publication_year self.available = available def __str__(self): return f\"{self.title} by {self.author} ({self.publication_year})\" def check_out(self): if self.available: self.available = False return True return False def return_book(self): self.available = True class Library: def __init__(self, name): self.name = name self.books = [] def add_book(self, book): self.books.append(book) def remove_book(self, isbn): for book in self.books: if book.isbn == isbn: self.books.remove(book) return True return False def search_by_title(self, title): results = [] for book in self.books: if title.lower() in book.title.lower(): results.append(book) return results def search_by_author(self, author): results = [] for book in self.books: if author.lower() in book.author.lower(): results.append(book) return results def check_out_book(self, isbn): for book in self.books: if book.isbn == isbn: return book.check_out() return False def return_book(self, isbn): for book in self.books: if book.isbn == isbn: book.return_book() return True return False def get_available_books(self): return [book for book in self.books if book.available] def get_checked_out_books(self): return [book for book in self.books if not book.available] class Member: def __init__(self, name, member_id): self.name = name self.member_id = member_id self.checked_out_books = [] def check_out_book(self, book): if book.check_out(): self.checked_out_books.append(book) return True return False def return_book(self, book): if book in self.checked_out_books: book.return_book() self.checked_out_books.remove(book) return True return False def __str__(self): return f\"Member: {self.name} (ID: {self.member_id})\" # Create a library city_library = Library(\"City Public Library\") # Add books to the library book1 = Book(\"The Great Gatsby\", \"F. Scott Fitzgerald\", \"9780743273565\", 1925) book2 = Book(\"To Kill a Mockingbird\", \"Harper Lee\", \"9780061120084\", 1960) book3 = Book(\"1984\", \"George Orwell\", \"9780451524935\", 1949) book4 = Book(\"Pride and Prejudice\", \"Jane Austen\", \"9780141439518\", 1813) city_library.add_book(book1) city_library.add_book(book2) city_library.add_book(book3) city_library.add_book(book4) # Create a member alice = Member(\"Alice Johnson\", \"M001\") # Search for books print(\"Search results for 'the':\") for book in city_library.search_by_title(\"the\"): print(f\"- {book}\") # Alice checks out a book print(\"\\nAlice checks out 'The Great Gatsby':\") if alice.check_out_book(book1): print(f\"Successfully checked out: {book1}\") else: print(f\"Failed to check out: {book1}\") # List available books print(\"\\nAvailable books:\") for book in city_library.get_available_books(): print(f\"- {book}\") # List checked out books print(\"\\nChecked out books:\") for book in city_library.get_checked_out_books(): print(f\"- {book}\") # Alice returns the book print(\"\\nAlice returns 'The Great Gatsby':\") if alice.return_book(book1): print(f\"Successfully returned: {book1}\") else: print(f\"Failed to return: {book1}\") # Verify it's available again print(\"\\nAvailable books after return:\") for book in city_library.get_available_books(): print(f\"- {book}\") This library system demonstrates several OOP concepts:\nClasses representing real-world entities (Book, Library, Member) Encapsulation of data and methods Object interaction (Members check out Books from a Library) Data validation (can’t check out an unavailable book) ","private-and-protected-attributes#Private and Protected Attributes":"Python doesn’t have true private attributes, but it does have naming conventions:\nPublic attributes: Regular names, accessible from anywhere. Protected attributes: Names with a single leading underscore (_name), indicating they shouldn’t be accessed directly (by convention). Name-mangled attributes: Names with double leading underscores (__name), which are transformed by Python to avoid name conflicts in subclasses. class BankAccount: def __init__(self, owner, balance=0): self.owner = owner # Public attribute self._balance = balance # Protected attribute (by convention) self.__account_num = \"12345\" # Name-mangled attribute def deposit(self, amount): self._balance += amount return self._balance def withdraw(self, amount): if amount \u003e self._balance: return \"Insufficient funds\" self._balance -= amount return self._balance def get_balance(self): return self._balance def get_account_details(self): # We can access the mangled attribute within the class return f\"Account for {self.owner}, Account #: {self.__account_num}\" # Create an account account = BankAccount(\"Alice\", 1000) # Accessing public attribute print(account.owner) # Output: Alice # Accessing protected attribute (possible but discouraged) print(account._balance) # Output: 1000 # Accessing name-mangled attribute try: print(account.__account_num) # This raises an AttributeError except AttributeError as e: print(f\"Error: {e}\") # Output: Error: 'BankAccount' object has no attribute '__account_num' # The mangled name is actually accessible if you know the pattern print(account._BankAccount__account_num) # Output: 12345 # Using the public methods print(account.deposit(500)) # Output: 1500 print(account.withdraw(200)) # Output: 1300 print(account.get_balance()) # Output: 1300 print(account.get_account_details()) # Output: Account for Alice, Account #: 12345 Important: Python’s approach to privacy is based on the principle “we’re all consenting adults here.” It doesn’t prevent access to attributes but uses naming conventions to indicate developer intent.","properties#Properties":"Properties allow you to define methods that can be accessed like attributes, providing better control over attribute access:\nclass Circle: def __init__(self, radius): self._radius = radius # Using underscore to indicate \"private\" attribute @property def radius(self): \"\"\"Get the radius of the circle.\"\"\" return self._radius @radius.setter def radius(self, value): \"\"\"Set the radius of the circle.\"\"\" if value \u003c= 0: raise ValueError(\"Radius must be positive\") self._radius = value @property def diameter(self): \"\"\"Get the diameter of the circle.\"\"\" return 2 * self._radius @property def area(self): \"\"\"Get the area of the circle.\"\"\" import math return math.pi * self._radius ** 2 # Create a circle circle = Circle(5) # Access properties as if they were attributes print(f\"Radius: {circle.radius}\") # Output: Radius: 5 print(f\"Diameter: {circle.diameter}\") # Output: Diameter: 10 print(f\"Area: {circle.area:.2f}\") # Output: Area: 78.54 # Modify radius using the setter circle.radius = 7 print(f\"New radius: {circle.radius}\") # Output: New radius: 7 print(f\"New area: {circle.area:.2f}\") # Output: New area: 153.94 # This will raise a ValueError try: circle.radius = -1 except ValueError as e: print(f\"Error: {e}\") # Output: Error: Radius must be positive # Properties without setters are read-only try: circle.area = 100 # This will raise an AttributeError except AttributeError as e: print(f\"Error: {e}\") # Output: Error: can't set attribute Properties provide several benefits:\nThey allow computed attributes. They enable validation when setting attribute values. They maintain backward compatibility if you need to change how an attribute is calculated. They can be read-only if you only define the getter. ","special-methods-magic-methods#Special Methods (Magic Methods)":"Python classes can implement special methods (also called magic methods or dunder methods) that enable instances to work with Python’s built-in functions and operators:\nclass Vector: def __init__(self, x, y): self.x = x self.y = y # String representation def __str__(self): return f\"Vector({self.x}, {self.y})\" # Detailed string representation def __repr__(self): return f\"Vector({self.x}, {self.y})\" # Addition (v1 + v2) def __add__(self, other): return Vector(self.x + other.x, self.y + other.y) # Subtraction (v1 - v2) def __sub__(self, other): return Vector(self.x - other.x, self.y - other.y) # Equality comparison (v1 == v2) def __eq__(self, other): return self.x == other.x and self.y == other.y # Get length of vector (len(v)) def __len__(self): import math return int(math.sqrt(self.x ** 2 + self.y ** 2)) # Make object callable (v()) def __call__(self): return (self.x, self.y) # Create vectors v1 = Vector(3, 4) v2 = Vector(5, 6) # Use the special methods print(v1) # Output: Vector(3, 4) print(v1 + v2) # Output: Vector(8, 10) print(v1 - v2) # Output: Vector(-2, -2) print(v1 == v2) # Output: False print(len(v1)) # Output: 5 print(v1()) # Output: (3, 4) Here are some common special methods:\nMethod Description Example __init__(self, ...) Constructor obj = MyClass() __str__(self) String representation for users print(obj) __repr__(self) String representation for developers repr(obj) __len__(self) Length len(obj) __add__(self, other) Addition obj1 + obj2 __sub__(self, other) Subtraction obj1 - obj2 __mul__(self, other) Multiplication obj1 * obj2 __truediv__(self, other) Division obj1 / obj2 __eq__(self, other) Equality obj1 == obj2 __lt__(self, other) Less than obj1 \u003c obj2 __gt__(self, other) Greater than obj1 \u003e obj2 __getitem__(self, key) Indexing obj[key] __call__(self, ...) Calling as function obj() ","understanding-pythons-object-oriented-programming#Understanding Python\u0026rsquo;s Object-Oriented Programming":"Object-Oriented Programming (OOP) is a programming paradigm that uses “objects” to model real-world entities. Python is a multi-paradigm programming language that fully supports object-oriented programming through its class system.\nUnderstanding Python’s Object-Oriented Programming Before diving into the syntax, let’s understand the fundamental concepts of OOP:\nClasses: Templates or blueprints that define the structure and behavior of objects. Objects: Instances of classes, representing specific entities. Attributes: Data stored inside an object (variables). Methods: Functions that define what an object can do. Encapsulation: Bundling data and methods that work on that data within a single unit. Inheritance: The ability to create new classes that inherit properties and methods from existing classes. Polymorphism: The ability to use a single interface with different underlying forms. "},"title":"Classes and Objects in Python"},"/python-fundamentals/07-object-oriented-programming/02-attributes-and-methods/":{"data":{"":"In object-oriented programming, classes serve as blueprints for creating objects. These objects have two main components: attributes (data) and methods (functions). Together, they define the state and behavior of objects.","class-attributes-vs-instance-attributes#Class Attributes vs. Instance Attributes":"Python objects can have two types of attributes:\nClass attributes: Shared by all instances of a class Instance attributes: Unique to each instance of a class Class Attributes Class attributes are defined at the class level and are the same for all instances of the class. They’re useful for:\nConstants shared across all instances Default values Tracking information about the class as a whole class Circle: # Class attribute pi = 3.14159 def __init__(self, radius): # Instance attribute self.radius = radius def area(self): return Circle.pi * self.radius ** 2 # Creating objects circle1 = Circle(5) circle2 = Circle(7) # All instances share the same class attribute print(circle1.pi) # 3.14159 print(circle2.pi) # 3.14159 # You can also access class attributes through the class itself print(Circle.pi) # 3.14159 Important: Class attributes can be accessed through the class (e.g., Circle.pi) or through instances (e.g., circle1.pi). However, if you modify a class attribute through an instance, it creates a new instance attribute that shadows the class attribute for that specific instance.\n# Modifying a class attribute through the class Circle.pi = 3.14 print(Circle.pi) # 3.14 print(circle1.pi) # 3.14 print(circle2.pi) # 3.14 # Modifying through an instance (creates a new instance attribute) circle1.pi = 3.0 print(Circle.pi) # 3.14 (class attribute unchanged) print(circle1.pi) # 3.0 (instance attribute shadows class attribute) print(circle2.pi) # 3.14 (still sees the class attribute) Instance Attributes Instance attributes are unique to each object and define the object’s state. They’re typically defined in the class’s __init__ method (constructor):\nclass Person: def __init__(self, name, age): # Instance attributes self.name = name self.age = age # Creating instances with different attributes person1 = Person(\"Alice\", 30) person2 = Person(\"Bob\", 25) print(person1.name) # Alice print(person2.name) # Bob You can also add or modify instance attributes outside the constructor:\n# Adding a new attribute to person1 person1.email = \"alice@example.com\" print(person1.email) # alice@example.com # This attribute only exists for person1 # print(person2.email) # AttributeError Note: While Python allows adding attributes dynamically, it’s better practice to define all attributes in the __init__ method for clarity and to avoid attribute errors.","exercises#Exercises":"Exercise 1: Create a Rectangle class with attributes for width and height. Include methods to calculate area and perimeter. Add a property that returns a tuple representing the dimensions and implement a method that allows the rectangle to be scaled by a given factor.\nExercise 2: Create a Book class to represent books in a library. Include attributes for title, author, ISBN, and availability status. Implement methods to check out and return the book. Use proper encapsulation with property decorators for attributes like ISBN that shouldn’t change after initialization.\nExercise 3: Implement a ShoppingCart class that stores items added by the user. Each item should be a dictionary with a name, price, and quantity. Include methods to add items, remove items, update quantities, and calculate the total cost. Implement __str__ and __repr__ methods and a property for the item count.\nHint for Exercise 1: Use properties to ensure width and height cannot be negative. The scale method should multiply both dimensions by the factor and return self for method chaining.\nIn the next section, we’ll explore constructors in more detail and how they work in Python’s object-oriented programming model.","method-chaining#Method Chaining":"Method chaining is a programming pattern where multiple methods are called in a sequence, with each method returning self (the instance):\nclass StringBuilder: def __init__(self): self.parts = [] def append(self, text): self.parts.append(str(text)) return self # Return self for chaining def clear(self): self.parts = [] return self # Return self for chaining def build(self): return ''.join(self.parts) # Create a StringBuilder sb = StringBuilder() # Use method chaining result = sb.append(\"Hello\").append(\" \").append(\"World!\").build() print(result) # Hello World! # Chain more methods result = sb.clear().append(\"Python \").append(\"is \").append(\"awesome!\").build() print(result) # Python is awesome! Method chaining makes code more concise and readable when performing multiple operations on the same object.","method-types-comparison#Method Types Comparison":" Feature Instance Method Class Method Static Method Decorator None @classmethod @staticmethod First parameter self (instance) cls (class) None Can access instance attributes Yes No No Can access class attributes Yes Yes No Can modify instance state Yes No No Can modify class state Yes Yes No Can be called via Instance Class or instance Class or instance Typical use Operations on instance data Alternative constructors, class-level operations Utility functions ","methods-in-python-classes#Methods in Python Classes":"Methods are functions defined within a class that operate on instances of the class. There are several types of methods in Python:\nInstance Methods Instance methods are the most common type of methods. They:\nTake self as the first parameter (referring to the instance) Can access and modify instance attributes Can access class attributes class Rectangle: def __init__(self, width, height): self.width = width self.height = height # Instance method def area(self): return self.width * self.height # Instance method that modifies the instance def resize(self, width, height): self.width = width self.height = height return self.area() # Create a rectangle rect = Rectangle(5, 10) print(f\"Area: {rect.area()}\") # Area: 50 # Resize the rectangle new_area = rect.resize(7, 3) print(f\"New area: {new_area}\") # New area: 21 The self parameter refers to the specific instance that calls the method, allowing the method to access and modify that instance’s attributes.\nClass Methods Class methods are methods that operate on the class itself rather than instances. They:\nAre defined with the @classmethod decorator Take cls as the first parameter (referring to the class) Can access and modify class attributes Cannot access instance attributes class Student: # Class attribute to track the number of students count = 0 def __init__(self, name, grade): self.name = name self.grade = grade # Increment the student count Student.count += 1 # Instance method def display_info(self): return f\"Name: {self.name}, Grade: {self.grade}\" # Class method to create a student from a string @classmethod def from_string(cls, student_str): name, grade_str = student_str.split(',') grade = int(grade_str) # Create and return a new instance return cls(name, grade) # Class method to get the student count @classmethod def get_count(cls): return cls.count # Create students normally student1 = Student(\"Alice\", 95) student2 = Student(\"Bob\", 87) # Create a student using the class method student3 = Student.from_string(\"Charlie,91\") print(student3.display_info()) # Name: Charlie, Grade: 91 print(f\"Total students: {Student.get_count()}\") # Total students: 3 Class methods are useful for:\nCreating alternative constructors Tracking class-level statistics Operations that involve the class but don’t need a specific instance Static Methods Static methods are methods that don’t operate on either the class or instances. They:\nAre defined with the @staticmethod decorator Don’t take self or cls as a first parameter Cannot access instance or class attributes directly Are essentially regular functions that are logically related to the class class MathUtils: @staticmethod def is_prime(n): \"\"\"Check if a number is prime.\"\"\" if n \u003c= 1: return False if n \u003c= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i \u003c= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True @staticmethod def factorial(n): \"\"\"Calculate factorial of n.\"\"\" if n \u003c 0: raise ValueError(\"Factorial is not defined for negative numbers\") result = 1 for i in range(2, n + 1): result *= i return result # Static methods can be called on the class print(MathUtils.is_prime(17)) # True print(MathUtils.factorial(5)) # 120 # They can also be called on instances, but this is less common math = MathUtils() print(math.is_prime(23)) # True Static methods are useful for utility functions that are related to the class’s purpose but don’t need to access instance or class data.","practical-example-building-a-complete-class#Practical Example: Building a Complete Class":"Let’s create a comprehensive BankAccount class that demonstrates all the concepts we’ve covered:\nclass BankAccount: # Class attribute interest_rate = 0.01 # 1% annual interest account_count = 0 def __init__(self, owner, initial_balance=0): # Validate initial balance if initial_balance \u003c 0: raise ValueError(\"Initial balance cannot be negative\") # Instance attributes self.owner = owner self._balance = initial_balance self.__account_number = BankAccount.account_count + 10000 self.__transactions = [] # Log the opening transaction self.__add_transaction(\"OPEN\", initial_balance) # Update class attribute BankAccount.account_count += 1 # Property for balance @property def balance(self): return self._balance # Property for account number @property def account_number(self): return self.__account_number # Property for transaction history @property def transaction_history(self): return self.__transactions.copy() # Instance methods def deposit(self, amount): \"\"\"Deposit money into the account.\"\"\" if amount \u003c= 0: raise ValueError(\"Deposit amount must be positive\") self._balance += amount self.__add_transaction(\"DEPOSIT\", amount) return self # For method chaining def withdraw(self, amount): \"\"\"Withdraw money from the account.\"\"\" if amount \u003c= 0: raise ValueError(\"Withdrawal amount must be positive\") if amount \u003e self._balance: raise ValueError(\"Insufficient funds\") self._balance -= amount self.__add_transaction(\"WITHDRAW\", -amount) return self # For method chaining def apply_interest(self): \"\"\"Apply annual interest to the account.\"\"\" interest = self._balance * BankAccount.interest_rate self._balance += interest self.__add_transaction(\"INTEREST\", interest) return self # For method chaining def transfer(self, other_account, amount): \"\"\"Transfer money to another account.\"\"\" if not isinstance(other_account, BankAccount): raise TypeError(\"Transfer target must be a BankAccount\") # First withdraw from this account self.withdraw(amount) # Then deposit to the other account other_account.deposit(amount) # Update transaction descriptions self.__transactions[-1][\"description\"] = f\"TRANSFER TO {other_account.account_number}\" other_account.__transactions[-1][\"description\"] = f\"TRANSFER FROM {self.__account_number}\" return self # For method chaining # Private method def __add_transaction(self, description, amount): \"\"\"Add a transaction to the history.\"\"\" import datetime transaction = { \"date\": datetime.datetime.now(), \"description\": description, \"amount\": amount, \"balance\": self._balance } self.__transactions.append(transaction) # Special methods def __str__(self): return f\"BankAccount of {self.owner} (#{self.__account_number}): Balance ${self._balance:.2f}\" def __repr__(self): return f\"BankAccount('{self.owner}', {self._balance})\" # Class methods @classmethod def set_interest_rate(cls, rate): \"\"\"Set the interest rate for all accounts.\"\"\" if rate \u003c 0: raise ValueError(\"Interest rate cannot be negative\") cls.interest_rate = rate @classmethod def get_account_count(cls): \"\"\"Get the total number of accounts.\"\"\" return cls.account_count # Static method @staticmethod def validate_owner_name(name): \"\"\"Validate that a name is appropriate for an account owner.\"\"\" if not isinstance(name, str): return False if len(name.strip()) \u003c 2: return False return True # Using the BankAccount class if __name__ == \"__main__\": # Create accounts alice_account = BankAccount(\"Alice Smith\", 1000) bob_account = BankAccount(\"Bob Johnson\", 500) # Display account information print(alice_account) # BankAccount of Alice Smith (#10000): Balance $1000.00 print(bob_account) # BankAccount of Bob Johnson (#10001): Balance $500.00 # Perform operations with method chaining alice_account.deposit(300).withdraw(50).apply_interest() # Transfer money alice_account.transfer(bob_account, 200) # Display updated balances print(f\"{alice_account.owner}'s balance: ${alice_account.balance:.2f}\") print(f\"{bob_account.owner}'s balance: ${bob_account.balance:.2f}\") # Check transaction history print(\"\\nAlice's Transaction History:\") for t in alice_account.transaction_history: print(f\"{t['date'].strftime('%Y-%m-%d %H:%M:%S')} - {t['description']}: ${abs(t['amount']):.2f} - Balance: ${t['balance']:.2f}\") # Use class methods print(f\"\\nTotal accounts: {BankAccount.get_account_count()}\") # Change interest rate for all accounts BankAccount.set_interest_rate(0.02) # Change to 2% print(f\"New interest rate: {BankAccount.interest_rate * 100:.1f}%\") # Validate a name using the static method print(f\"Is 'John Doe' a valid owner name? {BankAccount.validate_owner_name('John Doe')}\") print(f\"Is 'J' a valid owner name? {BankAccount.validate_owner_name('J')}\") This comprehensive example demonstrates:\nClass and instance attributes Property decorators Public, protected, and private attributes Instance, class, and static methods Special methods Method chaining Various OOP best practices ","property-decorators#Property Decorators":"Python provides property decorators that allow you to define methods that can be accessed like attributes. This enables you to:\nControl attribute access (getters and setters) Validate data Calculate attributes on-the-fly class Temperature: def __init__(self, celsius=0): self._celsius = celsius # Getter @property def celsius(self): return self._celsius # Setter @celsius.setter def celsius(self, value): if value \u003c -273.15: raise ValueError(\"Temperature below absolute zero is not possible\") self._celsius = value # Calculated property @property def fahrenheit(self): return (self.celsius * 9/5) + 32 # Setter for the calculated property @fahrenheit.setter def fahrenheit(self, value): self.celsius = (value - 32) * 5/9 # Create a temperature temp = Temperature(25) # Access properties as if they were attributes print(f\"Celsius: {temp.celsius}°C\") # Celsius: 25°C print(f\"Fahrenheit: {temp.fahrenheit}°F\") # Fahrenheit: 77.0°F # Set the temperature using properties temp.celsius = 30 print(f\"Celsius: {temp.celsius}°C\") # Celsius: 30°C print(f\"Fahrenheit: {temp.fahrenheit}°F\") # Fahrenheit: 86.0°F temp.fahrenheit = 68 print(f\"Celsius: {temp.celsius}°C\") # Celsius: 20.0°C print(f\"Fahrenheit: {temp.fahrenheit}°F\") # Fahrenheit: 68.0°F # Validation prevents invalid values try: temp.celsius = -300 # Below absolute zero except ValueError as e: print(f\"Error: {e}\") # Error: Temperature below absolute zero is not possible Properties are an excellent way to enforce encapsulation, allowing you to:\nHide the internal implementation Validate values before setting attributes Provide computed attributes Control access to attributes ","public-protected-and-private-attributes#Public, Protected, and Private Attributes":"Python doesn’t enforce access control like some other languages, but it follows certain conventions for attribute visibility:\nPublic attributes: Regular attributes with no underscore prefix Protected attributes: Attributes with a single underscore prefix, indicating they’re intended for internal use Private attributes: Attributes with a double underscore prefix, which are name-mangled to avoid accidental access class Account: def __init__(self, owner, balance): self.owner = owner # Public attribute self._balance = balance # Protected attribute self.__pin = \"1234\" # Private attribute def deposit(self, amount): self._balance += amount return self._balance def withdraw(self, amount, pin): if pin != self.__pin: return \"Invalid PIN\" if amount \u003e self._balance: return \"Insufficient funds\" self._balance -= amount return self._balance def __get_pin(self): # Private method return self.__pin # Create an account acc = Account(\"Alice\", 1000) # Access public attribute print(acc.owner) # Alice # Access protected attribute (not recommended, but possible) print(acc._balance) # 1000 # Try to access private attribute try: print(acc.__pin) # AttributeError except AttributeError as e: print(f\"Error: {e}\") # Error: 'Account' object has no attribute '__pin' # Name mangling: Private attributes are accessible, but their names are mangled print(acc._Account__pin) # 1234 (not recommended to access directly) # Proper way to interact with protected/private attributes is through methods print(acc.deposit(500)) # 1500 print(acc.withdraw(200, \"1234\")) # 1300 print(acc.withdraw(100, \"wrong\")) # Invalid PIN Important: These access conventions are not enforced by Python but are followed by convention:\nPublic attributes are freely accessible Protected attributes (single underscore) indicate “intended for internal use” but are still accessible Private attributes (double underscore) use name mangling to avoid accidental access, but can still be accessed if you know the mangled name ","special-methods-magic-methods#Special Methods (Magic Methods)":"Python classes can define special methods (also called “dunder” or “magic” methods) that enable instances to work with Python’s built-in operations and functions. These methods have names surrounded by double underscores.\n__init__ - Constructor We’ve already seen __init__, which initializes a new instance:\nclass Person: def __init__(self, name, age): self.name = name self.age = age __str__ - String Representation The __str__ method defines the string representation of an object, used by the str() function and print():\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\"Person({self.name}, {self.age})\" person = Person(\"Alice\", 30) print(person) # Person(Alice, 30) __repr__ - Official Representation The __repr__ method returns the “official” string representation of an object, aimed at developers:\nclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\"Person: {self.name}, {self.age}\" def __repr__(self): return f\"Person('{self.name}', {self.age})\" person = Person(\"Alice\", 30) print(str(person)) # Person: Alice, 30 print(repr(person)) # Person('Alice', 30) The __repr__ output should ideally be a valid Python expression that could recreate the object.\nOperator Overloading Special methods allow objects to work with Python’s operators:\nclass Vector: def __init__(self, x, y): self.x = x self.y = y def __str__(self): return f\"Vector({self.x}, {self.y})\" # Addition: v1 + v2 def __add__(self, other): return Vector(self.x + other.x, self.y + other.y) # Subtraction: v1 - v2 def __sub__(self, other): return Vector(self.x - other.x, self.y - other.y) # Multiplication by scalar: v1 * 3 def __mul__(self, scalar): return Vector(self.x * scalar, self.y * scalar) # Length (magnitude): len(v1) def __len__(self): return int((self.x ** 2 + self.y ** 2) ** 0.5) # Comparison: v1 == v2 def __eq__(self, other): return self.x == other.x and self.y == other.y # Create vectors v1 = Vector(3, 4) v2 = Vector(1, 2) # Use operators with vectors v3 = v1 + v2 print(v3) # Vector(4, 6) v4 = v1 - v2 print(v4) # Vector(2, 2) v5 = v1 * 2 print(v5) # Vector(6, 8) print(len(v1)) # 5 (magnitude of vector is 5) print(v1 == Vector(3, 4)) # True print(v1 == v2) # False Here are more common special methods:\nMethod Description Example Usage __init__(self, ...) Constructor obj = MyClass() __del__(self) Destructor del obj __str__(self) String representation str(obj), print(obj) __repr__(self) Official representation repr(obj) __len__(self) Length len(obj) __getitem__(self, key) Get item by key obj[key] __setitem__(self, key, value) Set item by key obj[key] = value __delitem__(self, key) Delete item by key del obj[key] __iter__(self) Iterator for x in obj __next__(self) Next item in iterator next(obj) __contains__(self, item) Membership test item in obj __call__(self, ...) Call as function obj() __add__(self, other) Addition obj + other __sub__(self, other) Subtraction obj - other __mul__(self, other) Multiplication obj * other __truediv__(self, other) Division obj / other __eq__(self, other) Equality obj == other __lt__(self, other) Less than obj \u003c other __gt__(self, other) Greater than obj \u003e other "},"title":"Attributes and Methods"},"/python-fundamentals/07-object-oriented-programming/03-constructors/":{"data":{"":"","best-practices-for-constructors#Best Practices for Constructors":" Keep constructors simple: Constructors should primarily initialize attributes. Avoid complex operations or side effects.\nValidate input parameters: Check parameter types and values early to prevent issues later.\nProvide sensible defaults: Use default parameter values to make object creation easier and more flexible.\nUse docstrings: Document what the class represents and what parameters the constructor accepts.\nConsider alternative constructors: Use class methods to provide different ways to create objects.\nInitialize all attributes in the constructor: Don’t leave attributes to be initialized later, as this can lead to errors if they’re accessed before initialization.\nUse proper inheritance: Always call the parent constructor when inheriting.","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"1. Forgetting self Parameter # Incorrect - missing self parameter class Rectangle: def __init__(width, height): # Missing self! self.width = width self.height = height # Correct class Rectangle: def __init__(self, width, height): self.width = width self.height = height 2. Forgetting to Call Parent Constructor # Incorrect - not calling parent constructor class Vehicle: def __init__(self, make, model): self.make = make self.model = model class Car(Vehicle): def __init__(self, make, model, doors): # Missing super().__init__(make, model) self.doors = doors # Parent attributes not initialized! # Correct class Car(Vehicle): def __init__(self, make, model, doors): super().__init__(make, model) self.doors = doors 3. Modifying Mutable Default Arguments # Incorrect - using mutable default argument class Student: def __init__(self, name, courses=[]): # ❌ Shared list for all instances! self.name = name self.courses = courses # Correct approach class Student: def __init__(self, name, courses=None): self.name = name self.courses = courses if courses is not None else [] 4. Too Many Parameters # Unwieldy constructor with too many parameters class User: def __init__(self, first_name, last_name, email, phone, address, city, state, zip_code, birth_date, gender, preferences): self.first_name = first_name # ... many more assignments # Better approach: use a dictionary or dataclass class User: def __init__(self, **user_data): self.first_name = user_data.get('first_name', '') self.last_name = user_data.get('last_name', '') # ... and so on # Or better yet, use a dataclass (Python 3.7+) from dataclasses import dataclass @dataclass class User: first_name: str last_name: str email: str phone: str = \"\" # Optional fields can have defaults address: str = \"\" # ... and so on 5. Overusing __init__ # Overloaded __init__ with too much responsibility class Database: def __init__(self, connection_string): self.connection_string = connection_string self.connection = self._connect() # Side effect in constructor self.initialize_schema() # Another side effect self.load_cached_data() # Yet another side effect # Better approach: Separate initialization from connection class Database: def __init__(self, connection_string): self.connection_string = connection_string self.connection = None def connect(self): self.connection = self._connect() return self def initialize_schema(self): # Implementation here return self # This allows for method chaining # db = Database(\"connection_string\").connect().initialize_schema() ","constructor-chaining-with-inheritance#Constructor Chaining with Inheritance":"When a class inherits from another class, you often need to call the parent class’s constructor from the child class’s constructor. This is done using super():\nclass Vehicle: def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.is_running = False def start(self): self.is_running = True print(f\"The {self.year} {self.make} {self.model} is now running.\") class Car(Vehicle): def __init__(self, make, model, year, fuel_type): # Call the parent class constructor first super().__init__(make, model, year) # Then initialize Car-specific attributes self.fuel_type = fuel_type self.doors = 4 class Motorcycle(Vehicle): def __init__(self, make, model, year, has_sidecar=False): # Call the parent class constructor super().__init__(make, model, year) # Initialize Motorcycle-specific attributes self.has_sidecar = has_sidecar self.doors = 0 # Create a car my_car = Car(\"Toyota\", \"Camry\", 2022, \"Gasoline\") print(f\"{my_car.year} {my_car.make} {my_car.model}, Fuel: {my_car.fuel_type}, Doors: {my_car.doors}\") my_car.start() # Create a motorcycle my_bike = Motorcycle(\"Harley-Davidson\", \"Sportster\", 2021, has_sidecar=True) print(f\"{my_bike.year} {my_bike.make} {my_bike.model}, Sidecar: {my_bike.has_sidecar}, Doors: {my_bike.doors}\") my_bike.start() In this inheritance example:\nThe Vehicle class provides common attributes and methods for all vehicles. The Car and Motorcycle classes inherit from Vehicle and call the parent constructor using super().__init__(). After calling the parent constructor, each subclass adds its own specialized attributes. Important: When using inheritance, always call the parent class’s constructor using super().__init__() before adding any subclass-specific initialization. This ensures that the parent class’s attributes are properly set up before continuing.","constructor-logic-and-validation#Constructor Logic and Validation":"","constructors-in-multiple-inheritance#Constructors in Multiple Inheritance":"Python supports multiple inheritance, where a class can inherit from multiple parent classes. When a class inherits from multiple parents, the method resolution order (MRO) determines which parent’s method gets called first:\nclass Engine: def __init__(self, horsepower): print(\"Initializing Engine\") self.horsepower = horsepower class ElectricMotor: def __init__(self, kilowatts): print(\"Initializing ElectricMotor\") self.kilowatts = kilowatts class HybridPowerplant(Engine, ElectricMotor): def __init__(self, horsepower, kilowatts, combined_output): print(\"Initializing HybridPowerplant\") Engine.__init__(self, horsepower) ElectricMotor.__init__(self, kilowatts) self.combined_output = combined_output # Create a hybrid powerplant hybrid = HybridPowerplant(150, 75, 210) print(f\"ICE Horsepower: {hybrid.horsepower}\") print(f\"Electric Kilowatts: {hybrid.kilowatts}\") print(f\"Combined Output: {hybrid.combined_output}\") In this example, we explicitly call the constructors of both parent classes. However, when using multiple inheritance, it’s generally better to use super() with no arguments, which follows the class’s method resolution order (MRO):\nclass Engine: def __init__(self, horsepower): print(\"Initializing Engine\") self.horsepower = horsepower class ElectricMotor: def __init__(self, kilowatts): print(\"Initializing ElectricMotor\") self.kilowatts = kilowatts class HybridPowerplant(Engine, ElectricMotor): def __init__(self, horsepower, kilowatts, combined_output): print(\"Initializing HybridPowerplant\") # Use super() with no arguments to follow MRO super().__init__(horsepower) # Calls Engine.__init__ self.kilowatts = kilowatts # We need to set this manually self.combined_output = combined_output # Create a hybrid powerplant hybrid = HybridPowerplant(150, 75, 210) print(f\"ICE Horsepower: {hybrid.horsepower}\") print(f\"Electric Kilowatts: {hybrid.kilowatts}\") print(f\"Combined Output: {hybrid.combined_output}\") Note: When using super() with no arguments in multiple inheritance, only the first parent’s constructor is called automatically (according to MRO). You’ll need to set attributes from other parents manually or use a more complex initialization approach.","default-parameter-values#Default Parameter Values":"","exercises#Exercises":"Exercise 1: Create a Rectangle class with a constructor that takes width and height parameters. Add methods to calculate the area and perimeter of the rectangle. Then create a Square class that inherits from Rectangle and ensures that width and height are always equal.\nExercise 2: Design a Book class with attributes for title, author, ISBN, publication year, and availability status. Include methods to check out and return the book. Then create a Library class that can store multiple books and provides methods to add books, find books by title or author, and display all books.\nExercise 3: Implement a BankAccount class similar to the examples, but add a feature for transferring money between accounts. Then create a specialized SavingsAccount that limits withdrawals to a certain number per month and applies interest monthly.\nHint for Exercise 1: For the Square class, you only need to accept one parameter (the side length) in the constructor, then pass that same value as both width and height to the parent constructor.\n# Exercise 1 solution outline class Rectangle: def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) class Square(Rectangle): def __init__(self, side): # Pass the same value as both width and height super().__init__(side, side) In the next section, we’ll explore attributes and methods in more detail, focusing on different types of methods (instance, class, and static) and more advanced OOP concepts.","instance-attributes-vs-class-attributes#Instance Attributes vs. Class Attributes":"","multiple-constructors-with-class-methods#Multiple Constructors with Class Methods":"","practical-examples#Practical Examples":"Example 1: E-Commerce Product System Let’s create a product system for an e-commerce application:\nclass Product: # Class attribute for tax rate tax_rate = 0.08 def __init__(self, product_id, name, price, stock=0): # Validate inputs if not isinstance(product_id, str): raise TypeError(\"Product ID must be a string\") if price \u003c 0: raise ValueError(\"Price cannot be negative\") if stock \u003c 0: raise ValueError(\"Stock cannot be negative\") # Initialize attributes self.product_id = product_id self.name = name self.price = price self.stock = stock def get_price_with_tax(self): \"\"\"Calculate the price including tax.\"\"\" return self.price * (1 + self.tax_rate) def is_in_stock(self): \"\"\"Check if the product is in stock.\"\"\" return self.stock \u003e 0 def __str__(self): \"\"\"Return a string representation of the product.\"\"\" return f\"{self.name} (ID: {self.product_id}) - ${self.price:.2f}\" class PhysicalProduct(Product): def __init__(self, product_id, name, price, stock=0, weight=0, dimensions=None): # Call parent constructor super().__init__(product_id, name, price, stock) # Initialize PhysicalProduct-specific attributes self.weight = weight # in kg self.dimensions = dimensions or {} # dict with width, height, depth def calculate_shipping_cost(self, base_rate=5.0): \"\"\"Calculate shipping cost based on weight.\"\"\" return base_rate + (self.weight * 2) class DigitalProduct(Product): def __init__(self, product_id, name, price, stock=float('inf'), file_size=0, download_link=\"\"): # Digital products have infinite stock by default super().__init__(product_id, name, price, stock) self.file_size = file_size # in MB self.download_link = download_link def deliver(self, customer_email): \"\"\"Simulate digital product delivery.\"\"\" print(f\"Sending download link for {self.name} to {customer_email}\") return f\"Download link for {self.name}: {self.download_link}\" # Create a physical product laptop = PhysicalProduct( product_id=\"TECH-001\", name=\"Laptop Pro\", price=1299.99, stock=10, weight=2.5, dimensions={\"width\": 35, \"height\": 1.5, \"depth\": 25} ) # Create a digital product ebook = DigitalProduct( product_id=\"BOOK-001\", name=\"Python Programming Guide\", price=19.99, file_size=15.7, download_link=\"https://example.com/downloads/python-guide\" ) # Use the products print(laptop) # Output: Laptop Pro (ID: TECH-001) - $1299.99 print(f\"Laptop in stock: {laptop.is_in_stock()}\") print(f\"Laptop price with tax: ${laptop.get_price_with_tax():.2f}\") print(f\"Laptop shipping cost: ${laptop.calculate_shipping_cost():.2f}\") print(\"\\n\" + \"-\" * 30 + \"\\n\") print(ebook) # Output: Python Programming Guide (ID: BOOK-001) - $19.99 print(f\"E-book in stock: {ebook.is_in_stock()}\") print(f\"E-book price with tax: ${ebook.get_price_with_tax():.2f}\") print(ebook.deliver(\"customer@example.com\")) Example 2: Banking System with Multiple Constructors Let’s create a more complex banking system with alternative constructors:\nfrom datetime import datetime, timedelta import random import string class BankAccount: # Class attributes interest_rate = 0.01 # 1% annual interest rate bank_name = \"Python National Bank\" def __init__(self, account_number, owner_name, balance=0, account_type=\"Checking\"): # Validate inputs if balance \u003c 0: raise ValueError(\"Initial balance cannot be negative\") # Initialize attributes self.account_number = account_number self.owner_name = owner_name self.balance = balance self.account_type = account_type self.creation_date = datetime.now() self.transactions = [] # Record the initial deposit if any if balance \u003e 0: self._add_transaction(\"Initial deposit\", balance) @classmethod def create_account(cls, owner_name, initial_deposit=0, account_type=\"Checking\"): \"\"\"Alternative constructor that auto-generates an account number.\"\"\" # Generate a random 10-digit account number account_number = ''.join(random.choices(string.digits, k=10)) return cls(account_number, owner_name, initial_deposit, account_type) @classmethod def create_savings_account(cls, owner_name, initial_deposit=0): \"\"\"Alternative constructor specifically for savings accounts.\"\"\" account = cls.create_account(owner_name, initial_deposit, \"Savings\") # Savings accounts have a higher interest rate account.interest_rate = 0.025 # 2.5% interest for savings return account def deposit(self, amount): \"\"\"Deposit money into the account.\"\"\" if amount \u003c= 0: raise ValueError(\"Deposit amount must be positive\") self.balance += amount self._add_transaction(\"Deposit\", amount) return self.balance def withdraw(self, amount): \"\"\"Withdraw money from the account.\"\"\" if amount \u003c= 0: raise ValueError(\"Withdrawal amount must be positive\") if amount \u003e self.balance: raise ValueError(\"Insufficient funds\") self.balance -= amount self._add_transaction(\"Withdrawal\", -amount) return self.balance def get_transaction_history(self): \"\"\"Return the account's transaction history.\"\"\" return self.transactions def _add_transaction(self, transaction_type, amount): \"\"\"Add a transaction record (private method).\"\"\" transaction = { \"date\": datetime.now(), \"type\": transaction_type, \"amount\": amount, \"balance\": self.balance } self.transactions.append(transaction) def __str__(self): return f\"{self.account_type} Account #{self.account_number} - Owner: {self.owner_name}, Balance: ${self.balance:.2f}\" # Using the main constructor try: account1 = BankAccount(\"1234567890\", \"John Smith\", 1000, \"Checking\") print(account1) except ValueError as e: print(f\"Error: {e}\") # Using alternative constructors account2 = BankAccount.create_account(\"Jane Doe\", 500) print(account2) savings = BankAccount.create_savings_account(\"Robert Johnson\", 2000) print(savings) print(f\"Savings interest rate: {savings.interest_rate:.1%}\") # Perform some transactions account2.deposit(300) account2.withdraw(200) # Check transaction history print(\"\\nTransaction History:\") for transaction in account2.get_transaction_history(): print(f\"{transaction['date'].strftime('%Y-%m-%d %H:%M:%S')} - {transaction['type']}: ${abs(transaction['amount']):.2f} - Balance: ${transaction['balance']:.2f}\") ","the-__init__-method#The \u003ccode\u003e__init__\u003c/code\u003e Method":"","the-__new__-method#The \u003ccode\u003e__new__\u003c/code\u003e Method":"In Python’s object-oriented programming, a constructor is a special method that is automatically called when you create a new instance (object) of a class. Constructors initialize the newly created object, setting up any attributes and performing any startup operations the object needs.\nThe __init__ Method In Python, the constructor method is named __init__ (pronounced “dunder init” or “init” for short). The double underscores before and after the name indicate that this is a special method with a specific meaning to Python.\nclass Person: def __init__(self, name, age): self.name = name self.age = age # Creating an instance calls the __init__ method automatically person1 = Person(\"Alice\", 30) print(f\"Name: {person1.name}, Age: {person1.age}\") # Output: Name: Alice, Age: 30 In this example:\nWe define a Person class with an __init__ method that takes name and age parameters. When we create a new Person object with Person(\"Alice\", 30), the __init__ method is automatically called. Inside __init__, we set the name and age attributes of the new object. Important: The first parameter of __init__ (and any instance method) is always self, which refers to the instance being created. Python automatically passes this argument, so you don’t include it when creating an object.\nDefault Parameter Values Constructor parameters can have default values, making them optional when creating an object:\nclass Car: def __init__(self, make, model, year, color=\"Black\"): self.make = make self.model = model self.year = year self.color = color self.odometer = 0 # Default value for all cars # Using all parameters car1 = Car(\"Toyota\", \"Camry\", 2022, \"Blue\") print(f\"{car1.color} {car1.year} {car1.make} {car1.model}, Odometer: {car1.odometer}\") # Output: Blue 2022 Toyota Camry, Odometer: 0 # Using default color car2 = Car(\"Honda\", \"Civic\", 2023) print(f\"{car2.color} {car2.year} {car2.make} {car2.model}, Odometer: {car2.odometer}\") # Output: Black 2023 Honda Civic, Odometer: 0 Note that odometer is initialized to 0 without requiring a parameter, providing a default starting value for every car.\nInstance Attributes vs. Class Attributes It’s important to distinguish between instance attributes (defined in __init__) and class attributes (defined in the class but outside any method):\nclass Student: # Class attribute - shared by all instances school_name = \"Python High School\" def __init__(self, name, grade): # Instance attributes - unique to each instance self.name = name self.grade = grade self.courses = [] # Each student gets their own empty list # Creating students student1 = Student(\"Bob\", 10) student2 = Student(\"Charlie\", 11) # Accessing instance attributes print(f\"{student1.name} is in grade {student1.grade}\") # Output: Bob is in grade 10 # Both students share the same class attribute print(f\"{student1.name} attends {student1.school_name}\") print(f\"{student2.name} attends {student2.school_name}\") # Output: # Bob attends Python High School # Charlie attends Python High School # If we change the class attribute for one, it changes for all Student.school_name = \"Python Academy\" print(f\"{student1.name} now attends {student1.school_name}\") print(f\"{student2.name} now attends {student2.school_name}\") # Output: # Bob now attends Python Academy # Charlie now attends Python Academy Note: Class attributes are useful for values that should be shared across all instances, while instance attributes store data that varies between instances.\nConstructor Logic and Validation Constructors can include logic for validating parameters, calculating derived values, or initializing complex attributes:\nclass BankAccount: def __init__(self, account_number, owner_name, balance=0): # Validate account number format if not (isinstance(account_number, str) and len(account_number) == 10): raise ValueError(\"Account number must be a 10-character string\") # Validate initial balance if balance \u003c 0: raise ValueError(\"Initial balance cannot be negative\") self.account_number = account_number self.owner_name = owner_name self.balance = balance self.is_active = True self.creation_date = self._get_current_date() def _get_current_date(self): \"\"\"Helper method to get the current date.\"\"\" from datetime import date return date.today().strftime(\"%Y-%m-%d\") # Valid account creation try: account1 = BankAccount(\"1234567890\", \"David Smith\", 1000) print(f\"Account created for {account1.owner_name} on {account1.creation_date}\") print(f\"Initial balance: ${account1.balance}\") except ValueError as e: print(f\"Error: {e}\") # Invalid account creation try: account2 = BankAccount(\"12345\", \"Jane Doe\", -100) print(\"This code won't execute\") except ValueError as e: print(f\"Error: {e}\") # Output: Error: Account number must be a 10-character string In this example, the constructor validates the account number and initial balance, raises exceptions for invalid data, and automatically sets additional attributes like the creation date.\nMultiple Constructors with Class Methods Python doesn’t have method overloading like some languages, so you can’t have multiple __init__ methods with different parameters. However, you can use class methods with the @classmethod decorator to create alternative constructors:\nclass Date: def __init__(self, year, month, day): self.year = year self.month = month self.day = day @classmethod def from_string(cls, date_string): \"\"\"Alternative constructor that creates a Date from a string.\"\"\" year, month, day = map(int, date_string.split('-')) return cls(year, month, day) @classmethod def today(cls): \"\"\"Alternative constructor that creates a Date for the current date.\"\"\" import datetime today = datetime.date.today() return cls(today.year, today.month, today.day) def __str__(self): return f\"{self.year}-{self.month:02d}-{self.day:02d}\" # Using the primary constructor date1 = Date(2023, 5, 15) print(date1) # Output: 2023-05-15 # Using the string-based alternative constructor date2 = Date.from_string(\"2022-12-25\") print(date2) # Output: 2022-12-25 # Using the today-based alternative constructor date3 = Date.today() print(date3) # Output: current date, e.g., 2023-05-20 In this example:\nThe standard __init__ method creates a Date from year, month, and day values. The from_string class method creates a Date by parsing a date string. The today class method creates a Date for the current date. Important: The cls parameter in class methods refers to the class itself (like Date), allowing you to create new instances within the method. The method returns a new instance of the class.\nThe __new__ Method While __init__ is the constructor that most Python developers are familiar with, there’s actually another method called __new__ that’s called before __init__. The __new__ method is responsible for creating the instance, while __init__ initializes it.\nMost Python classes don’t need to override __new__, but it’s useful for advanced use cases like controlling instance creation, implementing singletons, or inheriting from immutable classes:\nclass Singleton: _instance = None def __new__(cls, *args, **kwargs): if cls._instance is None: cls._instance = super().__new__(cls) return cls._instance def __init__(self, name): self.name = name # Creating \"multiple\" instances singleton1 = Singleton(\"First\") singleton2 = Singleton(\"Second\") # But they're actually the same object print(singleton1.name) # Output: Second print(singleton2.name) # Output: Second print(singleton1 is singleton2) # Output: True In this example, __new__ ensures that only one instance of Singleton is ever created. The __init__ method is still called for each “creation,” which is why name gets overwritten.\nNote: The __new__ method is a static method that takes the class as its first parameter, traditionally named cls. It should return an instance of the class."},"title":"Constructors in Python"},"/python-fundamentals/07-object-oriented-programming/04-inheritance/":{"data":{"":"Inheritance is one of the key principles of object-oriented programming (OOP) that allows a class to inherit attributes and methods from another class. The class that inherits is called a subclass (or derived class), and the class being inherited from is called a superclass (or base class). Inheritance promotes code reuse and establishes a relationship between classes.","abstract-base-classes#Abstract Base Classes":"Abstract base classes (ABCs) are classes that cannot be instantiated and are designed to be subclassed. They may contain abstract methods that must be implemented by their subclasses:\nfrom abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass def describe(self): print(f\"This shape has an area of {self.area()} square units and a perimeter of {self.perimeter()} units.\") # This won't work - can't instantiate an abstract class # my_shape = Shape() # TypeError class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): import math return math.pi * self.radius ** 2 def perimeter(self): import math return 2 * math.pi * self.radius # Create instances of concrete subclasses rect = Rectangle(5, 10) circ = Circle(7) rect.describe() # This shape has an area of 50 square units and a perimeter of 30 units. circ.describe() # This shape has an area of 153.93... square units and a perimeter of 43.98... units. Abstract base classes ensure that derived classes implement specific methods, providing a form of interface enforcement in Python.","advantages-of-inheritance#Advantages of Inheritance":" Code Reuse: Inherit common functionality from parent classes instead of duplicating code Logical Hierarchy: Establish is-a relationships between objects Specialization: Customize behavior through method overriding Polymorphism: Treat objects of different classes uniformly if they share a common parent Maintainability: Changes to the parent class automatically apply to all child classes ","basic-inheritance#Basic Inheritance":"Let’s start with a simple example of inheritance:\n# Base class (superclass) class Animal: def __init__(self, name, species): self.name = name self.species = species def make_sound(self): print(\"Some generic animal sound\") def __str__(self): return f\"{self.name} is a {self.species}\" # Derived class (subclass) class Dog(Animal): def __init__(self, name, breed): # Call the base class's __init__ method super().__init__(name, species=\"Dog\") self.breed = breed def make_sound(self): print(\"Woof!\") def __str__(self): return f\"{self.name} is a {self.breed} dog\" # Creating instances generic_animal = Animal(\"Generic\", \"Unknown\") my_dog = Dog(\"Buddy\", \"Golden Retriever\") # Using methods print(generic_animal) # Generic is a Unknown generic_animal.make_sound() # Some generic animal sound print(my_dog) # Buddy is a Golden Retriever dog my_dog.make_sound() # Woof! In this example, Dog inherits from Animal, which means that a Dog is a specialized version of an Animal. The super() function is used to call methods from the parent class, including the constructor.\nImportant: When creating a subclass, you explicitly specify the parent class in parentheses: class Subclass(ParentClass):. This establishes the inheritance relationship.","best-practices-for-inheritance#Best Practices for Inheritance":" “Is-a” Relationship: Use inheritance only when there’s a true “is-a” relationship (e.g., a Dog is an Animal).\nFavor Composition Over Inheritance: When appropriate, use composition (having objects as attributes) rather than inheritance to build complex classes.\n# Inheritance approach class Car(Vehicle): pass # Composition approach class Car: def __init__(self): self.engine = Engine() self.wheels = [Wheel() for _ in range(4)] Keep Inheritance Hierarchies Shallow: Deep inheritance hierarchies can become difficult to understand and maintain. Try to keep them to a maximum of 2-3 levels.\nUse Abstract Base Classes for Interfaces: When you want to enforce that certain methods are implemented, use abstract base classes.\nDocument the Inheritance Design: Make sure to document the purpose of the inheritance hierarchy and the responsibilities of each class.\nFollow the Liskov Substitution Principle: Subclasses should be substitutable for their base classes without altering the desirable properties of the program.","exercises#Exercises":"Exercise 1: Create a base class Employee with attributes for name, id, and salary. Then create two subclasses: Manager (with an additional attribute for department) and Developer (with an additional attribute for programming language). Include appropriate methods in each class.\nExercise 2: Implement a simple banking system with a base class Account and derived classes SavingsAccount and CheckingAccount. The base class should handle the basic account operations, while the derived classes implement specific features like interest calculation for savings and overdraft protection for checking accounts.\nExercise 3: Create a class hierarchy for shapes as shown in the abstract base class example, but expand it to include more shapes like Triangle, Square, and Ellipse. Each class should properly implement the abstract methods and may include additional specialized methods.\nHint for Exercise 1: Start by defining the Employee class with an __init__ method that takes name, id, and salary parameters. Then create the subclasses and use super().__init__(...) to initialize the common attributes before adding the specialized ones.\n# Exercise 1 solution outline class Employee: def __init__(self, name, emp_id, salary): self.name = name self.emp_id = emp_id self.salary = salary def get_details(self): return f\"Name: {self.name}, ID: {self.emp_id}, Salary: ${self.salary}\" class Manager(Employee): def __init__(self, name, emp_id, salary, department): super().__init__(name, emp_id, salary) self.department = department def get_details(self): base_details = super().get_details() return f\"{base_details}, Department: {self.department}\" In the next section, we’ll explore other object-oriented programming concepts in Python, including polymorphism and encapsulation.","extending-parent-methods#Extending Parent Methods":"Instead of completely replacing a parent method, you can extend it by calling the parent implementation and then adding additional functionality:\nclass Bird(Animal): def __init__(self, name, wingspan): super().__init__(name, species=\"Bird\") self.wingspan = wingspan def make_sound(self): # Call the parent method first super().make_sound() # Then add additional functionality print(\"Chirp!\") def fly(self): print(f\"{self.name} is flying with a wingspan of {self.wingspan} cm\") my_bird = Bird(\"Tweety\", 15) my_bird.make_sound() # Outputs: Some generic animal sound\\nChirp! my_bird.fly() # Tweety is flying with a wingspan of 15 cm By using super().make_sound(), you call the parent’s version of the method before adding your custom behavior.","inheritance-gotchas#Inheritance Gotchas":" Attribute Shadowing: class Parent: x = 10 # Class attribute class Child(Parent): pass class GrandChild(Child): x = 20 # Shadows Parent.x print(Parent.x) # 10 print(Child.x) # 10 (inherited) print(GrandChild.x) # 20 (shadowed) Overriding Built-in Methods: class MyList(list): def append(self, item): # Only append if item is not already in the list if item not in self: super().append(item) unique_list = MyList([1, 2, 3]) unique_list.append(2) # Won't be added (already exists) unique_list.append(4) # Will be added print(unique_list) # [1, 2, 3, 4] super() Calling Order with Multiple Inheritance: class A: def method(self): print(\"A.method called\") class B: def method(self): print(\"B.method called\") class C(A, B): def method(self): print(\"C.method called\") super().method() # Calls A.method() due to MRO class D(B, A): def method(self): print(\"D.method called\") super().method() # Calls B.method() due to MRO c = C() c.method() # Output: # C.method called # A.method called d = D() d.method() # Output: # D.method called # B.method called ","inheriting-from-multiple-classes-multiple-inheritance#Inheriting from Multiple Classes (Multiple Inheritance)":"Python supports multiple inheritance, allowing a class to inherit from more than one parent class:\nclass Flyable: def fly(self): print(\"Flying...\") def land(self): print(\"Landing...\") class Swimmable: def swim(self): print(\"Swimming...\") def dive(self): print(\"Diving...\") class Duck(Animal, Flyable, Swimmable): def __init__(self, name): super().__init__(name, species=\"Duck\") def make_sound(self): print(\"Quack!\") donald = Duck(\"Donald\") donald.make_sound() # Quack! donald.fly() # Flying... donald.swim() # Swimming... donald.land() # Landing... In this example, Duck inherits from three classes: Animal, Flyable, and Swimmable. This allows the Duck class to have the behaviors of all three parent classes.\nNote: Multiple inheritance can lead to complex issues, especially the “diamond problem” where a class inherits from two classes that both inherit from a common base class. Python uses the Method Resolution Order (MRO) to determine which method to call.","instance-checking-and-inheritance#Instance Checking and Inheritance":"The isinstance() function checks if an object is an instance of a class or any of its subclasses:\n# Using our previously defined classes print(isinstance(my_dog, Dog)) # True print(isinstance(my_dog, Animal)) # True print(isinstance(my_cat, Dog)) # False print(isinstance(donald, Flyable)) # True The issubclass() function checks if a class is a subclass of another class:\nprint(issubclass(Dog, Animal)) # True print(issubclass(Duck, Flyable)) # True print(issubclass(Cat, Dog)) # False ","method-overriding#Method Overriding":"Method overriding occurs when a subclass provides a specific implementation for a method already defined in its parent class. In the example above, Dog overrides the make_sound() method to provide dog-specific behavior.\nclass Cat(Animal): def __init__(self, name, color): super().__init__(name, species=\"Cat\") self.color = color def make_sound(self): print(\"Meow!\") def purr(self): print(f\"{self.name} is purring\") my_cat = Cat(\"Whiskers\", \"Orange\") my_cat.make_sound() # Meow! my_cat.purr() # Whiskers is purring The Cat class overrides the make_sound() method from Animal to provide cat-specific behavior.","method-resolution-order-mro#Method Resolution Order (MRO)":"When using multiple inheritance, Python follows a specific order to resolve method calls, known as Method Resolution Order (MRO):\nclass Base: def method(self): print(\"Base method\") class A(Base): def method(self): print(\"A method\") class B(Base): def method(self): print(\"B method\") class C(A, B): pass c = C() c.method() # Outputs: A method # View the MRO print(C.__mro__) # (\u003cclass '__main__.C'\u003e, \u003cclass '__main__.A'\u003e, \u003cclass '__main__.B'\u003e, \u003cclass '__main__.Base'\u003e, \u003cclass 'object'\u003e) To view the MRO of a class, you can use the __mro__ attribute or the mro() method.","practical-example-creating-a-library-management-system#Practical Example: Creating a Library Management System":"Let’s apply inheritance to create a simple library management system:\nclass LibraryItem: def __init__(self, title, item_id): self.title = title self.item_id = item_id self.checked_out = False def check_out(self): if not self.checked_out: self.checked_out = True return True return False def return_item(self): if self.checked_out: self.checked_out = False return True return False def __str__(self): status = \"checked out\" if self.checked_out else \"available\" return f\"{self.title} ({self.item_id}) - {status}\" class Book(LibraryItem): def __init__(self, title, item_id, author, pages): super().__init__(title, item_id) self.author = author self.pages = pages def __str__(self): base_str = super().__str__() return f\"{base_str} - by {self.author}, {self.pages} pages\" class DVD(LibraryItem): def __init__(self, title, item_id, director, runtime): super().__init__(title, item_id) self.director = director self.runtime = runtime def __str__(self): base_str = super().__str__() return f\"{base_str} - directed by {self.director}, {self.runtime} minutes\" class Magazine(LibraryItem): def __init__(self, title, item_id, issue, month): super().__init__(title, item_id) self.issue = issue self.month = month def __str__(self): base_str = super().__str__() return f\"{base_str} - Issue {self.issue}, {self.month}\" class Library: def __init__(self, name): self.name = name self.items = {} def add_item(self, item): self.items[item.item_id] = item def check_out_item(self, item_id): if item_id in self.items: return self.items[item_id].check_out() return False def return_item(self, item_id): if item_id in self.items: return self.items[item_id].return_item() return False def list_items(self): for item in self.items.values(): print(item) # Using the library system my_library = Library(\"Community Library\") # Add items book1 = Book(\"The Great Gatsby\", \"B001\", \"F. Scott Fitzgerald\", 180) book2 = Book(\"To Kill a Mockingbird\", \"B002\", \"Harper Lee\", 281) dvd1 = DVD(\"Inception\", \"D001\", \"Christopher Nolan\", 148) mag1 = Magazine(\"National Geographic\", \"M001\", 37, \"June 2023\") my_library.add_item(book1) my_library.add_item(book2) my_library.add_item(dvd1) my_library.add_item(mag1) # List all items print(\"Library Inventory:\") my_library.list_items() # Check out an item print(\"\\nChecking out The Great Gatsby...\") if my_library.check_out_item(\"B001\"): print(\"Checkout successful!\") else: print(\"Checkout failed!\") # List items again to see the status change print(\"\\nUpdated Library Inventory:\") my_library.list_items() # Return an item print(\"\\nReturning The Great Gatsby...\") if my_library.return_item(\"B001\"): print(\"Return successful!\") else: print(\"Return failed!\") # List items again print(\"\\nFinal Library Inventory:\") my_library.list_items() Expected Output:\nLibrary Inventory: The Great Gatsby (B001) - available - by F. Scott Fitzgerald, 180 pages To Kill a Mockingbird (B002) - available - by Harper Lee, 281 pages Inception (D001) - available - directed by Christopher Nolan, 148 minutes National Geographic (M001) - available - Issue 37, June 2023 Checking out The Great Gatsby... Checkout successful! Updated Library Inventory: The Great Gatsby (B001) - checked out - by F. Scott Fitzgerald, 180 pages To Kill a Mockingbird (B002) - available - by Harper Lee, 281 pages Inception (D001) - available - directed by Christopher Nolan, 148 minutes National Geographic (M001) - available - Issue 37, June 2023 Returning The Great Gatsby... Return successful! Final Library Inventory: The Great Gatsby (B001) - available - by F. Scott Fitzgerald, 180 pages To Kill a Mockingbird (B002) - available - by Harper Lee, 281 pages Inception (D001) - available - directed by Christopher Nolan, 148 minutes National Geographic (M001) - available - Issue 37, June 2023 This example demonstrates how inheritance allows us to create specialized classes (Book, DVD, and Magazine) that inherit common functionality from a base class (LibraryItem), while adding their own unique attributes and behaviors."},"title":"Inheritance"},"/python-fundamentals/07-object-oriented-programming/05-polymorphism/":{"data":{"":"Polymorphism is a core concept in object-oriented programming that allows objects of different classes to be treated as objects of a common superclass. The term comes from Greek words meaning “many forms,” and that’s exactly what polymorphism allows: a single interface to entities of different types.","benefits-of-polymorphism#Benefits of Polymorphism":" Code Reusability: Polymorphism allows you to write methods that can operate on objects of various types, reducing code duplication.\nExtensibility: New classes can be added to the system without modifying existing code, as long as they implement the required interface.\nFlexibility: Systems can be designed to work with objects at a more abstract level, focusing on what operations are performed rather than how they are performed.\nMaintenance: Changes to one class don’t affect other classes, making the code easier to maintain.","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"Pitfall 1: Ignoring the Liskov Substitution Principle The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.\n# Problematic class Bird: def fly(self): print(\"I can fly\") class Penguin(Bird): def fly(self): raise Exception(\"Penguins can't fly!\") # Violates LSP # Better approach class Bird: def move(self): print(\"I can move\") class FlyingBird(Bird): def move(self): print(\"I can fly\") class SwimmingBird(Bird): def move(self): print(\"I can swim\") Best Practice 1: Use Abstract Base Classes for Complex Hierarchies For complex class hierarchies, use the abc module to create abstract base classes that define the required interface.\nfrom abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def draw(self): pass Best Practice 2: Follow the “Tell, Don’t Ask” Principle Instead of checking the type of an object and then calling different methods, let polymorphism handle the variations.\n# Avoid this def process_shape(shape): if isinstance(shape, Circle): shape.draw_circle() elif isinstance(shape, Rectangle): shape.draw_rectangle() # Prefer this def process_shape(shape): shape.draw() # Polymorphic method call Best Practice 3: Use Duck Typing for Flexibility Embrace Python’s duck typing to create flexible code that works with any object that supports the required operations.\ndef process_data(data_source): # As long as data_source has a read() method, this will work content = data_source.read() return process_content(content) # Can be used with files, network streams, StringIO objects, etc. ","exercises#Exercises":"Exercise 1: Create a base class Vehicle with a method move(). Then create subclasses for Car, Boat, and Airplane, each overriding the move() method to describe how that vehicle moves. Then create a function that takes a vehicle and makes it move.\nExercise 2: Implement a simple polymorphic system for different types of employees (regular employees, managers, and executives) with a common method calculate_salary() that works differently for each employee type.\nExercise 3: Create an abstract base class PaymentMethod with an abstract method process_payment(amount). Then implement concrete classes CreditCard, PayPal, and BankTransfer that each implement the payment processing differently. Finally, create a ShoppingCart class that can process a payment using any payment method.\nHint for Exercise 1:\nclass Vehicle: def move(self): pass class Car(Vehicle): def move(self): return \"The car drives on the road\" # Complete the other classes and create a function that demonstrates polymorphism In the next sections of Object-Oriented Programming, we’ll dive deeper into encapsulation and explore advanced concepts like magic methods, properties, and class decorators.","practical-example-building-a-multimedia-player#Practical Example: Building a Multimedia Player":"Let’s look at a more comprehensive example of polymorphism in a multimedia player application:\nfrom abc import ABC, abstractmethod class MediaFile(ABC): def __init__(self, filename): self.filename = filename @abstractmethod def play(self): pass @abstractmethod def display_info(self): pass def get_filename(self): return self.filename class AudioFile(MediaFile): def __init__(self, filename, artist, title, duration): super().__init__(filename) self.artist = artist self.title = title self.duration = duration def play(self): print(f\"Playing audio: {self.title} by {self.artist}\") # Code to actually play the audio would go here def display_info(self): print(f\"Audio: {self.title}\") print(f\"Artist: {self.artist}\") print(f\"Duration: {self.format_duration()}\") print(f\"File: {self.filename}\") def format_duration(self): minutes = self.duration // 60 seconds = self.duration % 60 return f\"{minutes}:{seconds:02d}\" class VideoFile(MediaFile): def __init__(self, filename, title, duration, resolution): super().__init__(filename) self.title = title self.duration = duration self.resolution = resolution def play(self): print(f\"Playing video: {self.title} ({self.resolution})\") # Code to actually play the video would go here def display_info(self): print(f\"Video: {self.title}\") print(f\"Resolution: {self.resolution}\") print(f\"Duration: {self.format_duration()}\") print(f\"File: {self.filename}\") def format_duration(self): minutes = self.duration // 60 seconds = self.duration % 60 return f\"{minutes}:{seconds:02d}\" class ImageFile(MediaFile): def __init__(self, filename, title, resolution): super().__init__(filename) self.title = title self.resolution = resolution def play(self): print(f\"Displaying image: {self.title}\") # Code to display the image would go here def display_info(self): print(f\"Image: {self.title}\") print(f\"Resolution: {self.resolution}\") print(f\"File: {self.filename}\") class MediaPlayer: def __init__(self): self.media_library = [] def add_media(self, media): if isinstance(media, MediaFile): self.media_library.append(media) print(f\"Added {media.get_filename()} to library\") else: print(\"Error: Not a valid media file\") def play_all(self): print(\"\\nPlaying all media:\") for media in self.media_library: media.play() def display_library(self): print(\"\\nMedia Library:\") for i, media in enumerate(self.media_library, 1): print(f\"\\nItem {i}:\") media.display_info() print(\"-\" * 20) # Create media files song = AudioFile(\"song.mp3\", \"The Beatles\", \"Hey Jude\", 243) movie = VideoFile(\"movie.mp4\", \"The Matrix\", 8280, \"1080p\") photo = ImageFile(\"photo.jpg\", \"Vacation\", \"4K\") # Create media player and add files player = MediaPlayer() player.add_media(song) player.add_media(movie) player.add_media(photo) # Use the media player player.display_library() player.play_all() Output:\nAdded song.mp3 to library Added movie.mp4 to library Added photo.jpg to library Media Library: Item 1: Audio: Hey Jude Artist: The Beatles Duration: 4:03 File: song.mp3 -------------------- Item 2: Video: The Matrix Resolution: 1080p Duration: 138:00 File: movie.mp4 -------------------- Item 3: Image: Vacation Resolution: 4K File: photo.jpg -------------------- Playing all media: Playing audio: Hey Jude by The Beatles Playing video: The Matrix (1080p) Displaying image: Vacation In this example:\nThe abstract base class MediaFile defines a common interface with methods like play() and display_info(). Different types of media (audio, video, image) implement these methods in their own way. The MediaPlayer class can work with any type of media as long as it adheres to the MediaFile interface. When we call play_all(), we see polymorphism in action as each media type responds differently to the same method call. ","understanding-polymorphism#Understanding Polymorphism":"In Python, polymorphism allows you to define methods in different classes with the same name, enabling you to call the same method on different objects and get different results. This promotes code reusability and flexibility.\nThere are several ways polymorphism manifests in Python:\n1. Method Overriding Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its parent class. When you call the method on an instance of the subclass, the overridden method in the subclass is executed instead of the parent class method.\nclass Animal: def speak(self): print(\"Animal makes a sound\") class Dog(Animal): def speak(self): print(\"Dog barks\") class Cat(Animal): def speak(self): print(\"Cat meows\") # Create instances animal = Animal() dog = Dog() cat = Cat() # Call the speak method on each object animal.speak() # Output: Animal makes a sound dog.speak() # Output: Dog barks cat.speak() # Output: Cat meows In this example, the speak() method is defined in the Animal class and overridden in both the Dog and Cat subclasses. Each class provides its own implementation of the method, demonstrating polymorphism through method overriding.\n2. Duck Typing Python’s approach to polymorphism is closely tied to the concept of “duck typing,” which follows the principle: “If it walks like a duck and quacks like a duck, then it probably is a duck.” This means Python doesn’t care about the type of an object, only that it implements the methods or attributes being accessed.\nclass Dog: def speak(self): print(\"Woof!\") class Cat: def speak(self): print(\"Meow!\") class Duck: def speak(self): print(\"Quack!\") def make_speak(animal): animal.speak() # Create instances dog = Dog() cat = Cat() duck = Duck() # Use polymorphism through duck typing make_speak(dog) # Output: Woof! make_speak(cat) # Output: Meow! make_speak(duck) # Output: Quack! In this example, the make_speak() function doesn’t care about the type of animal it receives; it only cares that the object has a speak() method. This is duck typing in action: as long as the object implements the expected interface, it will work.\nNote: Unlike statically-typed languages like Java or C++, Python doesn’t require objects to explicitly inherit from a common superclass to use polymorphism. Duck typing provides a more flexible approach.\n3. Method Overloading (Simulated) Method overloading allows a class to have multiple methods with the same name but different parameters. Python doesn’t support traditional method overloading where you define multiple methods with the same name in the same class. However, you can simulate it using default arguments or variable parameters.\nclass Calculator: def add(self, *args): result = 0 for arg in args: result += arg return result # Create a calculator instance calc = Calculator() # Call add with different numbers of arguments print(calc.add(2, 3)) # Output: 5 print(calc.add(2, 3, 4)) # Output: 9 print(calc.add(1, 2, 3, 4)) # Output: 10 This example simulates method overloading by using variable arguments (*args). The add() method can accept any number of arguments, demonstrating polymorphic behavior.\n4. Abstract Base Classes (ABC) Python provides the abc module for working with abstract base classes, which are classes that cannot be instantiated and are designed to be subclassed. Abstract methods defined in an abstract base class must be implemented by its subclasses, providing a formal way to enforce polymorphism.\nfrom abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): import math return math.pi * (self.radius ** 2) def perimeter(self): import math return 2 * math.pi * self.radius # Create instances rectangle = Rectangle(5, 4) circle = Circle(3) # Calculate and display areas print(f\"Rectangle area: {rectangle.area()}\") # Output: Rectangle area: 20 print(f\"Circle area: {circle.area():.2f}\") # Output: Circle area: 28.27 print(f\"Rectangle perimeter: {rectangle.perimeter()}\") # Output: Rectangle perimeter: 18 print(f\"Circle perimeter: {circle.perimeter():.2f}\") # Output: Circle perimeter: 18.85 In this example, the abstract base class Shape defines the interface with abstract methods area() and perimeter(). The concrete subclasses Rectangle and Circle must implement these methods, ensuring a consistent interface but allowing for different implementations.\nImportant: Attempting to instantiate the abstract base class directly would raise a TypeError, as abstract classes cannot be instantiated."},"title":"Polymorphism"},"/python-fundamentals/07-object-oriented-programming/06-encapsulation/":{"data":{"":"Encapsulation is one of the four fundamental principles of object-oriented programming (OOP), alongside inheritance, polymorphism, and abstraction. It refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit (a class), and restricting access to some of the object’s components.","access-modifiers-in-python#Access Modifiers in Python":"Unlike languages like Java or C++, Python doesn’t have strict access modifiers (like private, protected, public). Instead, it follows a convention-based approach:\nPublic Members: Attributes and methods that are accessible from outside the class. They have no special naming convention.\nProtected Members: Attributes and methods that shouldn’t be accessed from outside the class, but can be accessed by subclasses. They are prefixed with a single underscore (_).\nPrivate Members: Attributes and methods that shouldn’t be accessed from outside the class or by subclasses. They are prefixed with a double underscore (__).\nclass Employee: def __init__(self, name, salary, employee_id): self.name = name # Public attribute self._salary = salary # Protected attribute self.__employee_id = employee_id # Private attribute def get_id(self): # Public method return self.__employee_id def _calculate_bonus(self): # Protected method return self._salary * 0.1 def __update_internal_data(self): # Private method # Some internal implementation pass Important: Python’s private attributes are implemented using name mangling. The interpreter changes the name of the attribute to _ClassName__attribute_name. This means private attributes are still accessible if you know the mangled name, but this approach discourages direct access.\nemployee = Employee(\"John Doe\", 50000, \"E12345\") # Accessing attributes print(employee.name) # Works: Public attribute print(employee._salary) # Works, but not recommended: Protected attribute # print(employee.__employee_id) # Error: Private attribute is not directly accessible # Name mangling allows access, but strongly discouraged print(employee._Employee__employee_id) # Works, but very bad practice ","benefits-of-encapsulation#Benefits of Encapsulation":" Data Protection: Prevents accidental or unauthorized changes to important data\nFlexibility: Implementation details can be changed without affecting code that uses the class\nMaintainability: Clean interfaces make code easier to understand and maintain\nData Validation: Ensures that data remains in a valid state\nInformation Hiding: Simplifies the user’s view of the object by hiding complex implementation details","best-practices#Best Practices":" Design for Public Consumption: Think about how your class will be used by others before deciding what to make public or private.\nUse Properties for Attribute Access Control: Properties provide a clean way to maintain encapsulation without cluttering your class with getter/setter methods.\nStart Simple: Begin with simple public attributes. If you later need validation or computed values, you can convert to properties without changing how the class is used.\nReturn Copies of Mutable Objects: When returning a reference to a mutable internal object (like a list), return a copy to prevent external modification.\nclass Customer: def __init__(self, name): self.__name = name self.__orders = [] @property def name(self): return self.__name def add_order(self, order): self.__orders.append(order) @property def orders(self): return list(self.__orders) # Return a copy, not the original list Document Access Levels: Use docstrings to clarify which attributes and methods are part of the public interface and which are internal implementation details. ","common-encapsulation-patterns#Common Encapsulation Patterns":"1. Private Implementation, Public Interface class SortedList: def __init__(self): self.__items = [] # Private implementation # Public interface def add(self, item): self.__items.append(item) self.__items.sort() def get_items(self): return list(self.__items) # Return a copy to prevent modification def __len__(self): return len(self.__items) 2. Computed/Derived Properties class Rectangle: def __init__(self, width, height): self.__width = width self.__height = height @property def width(self): return self.__width @width.setter def width(self, value): if value \u003e 0: self.__width = value else: raise ValueError(\"Width must be positive\") @property def height(self): return self.__height @height.setter def height(self, value): if value \u003e 0: self.__height = value else: raise ValueError(\"Height must be positive\") # Computed property @property def area(self): return self.__width * self.__height @property def perimeter(self): return 2 * (self.__width + self.__height) 3. State Management class TrafficLight: def __init__(self): self.__states = [\"red\", \"yellow\", \"green\"] self.__current_state_index = 0 @property def current_state(self): return self.__states[self.__current_state_index] def change_state(self): self.__current_state_index = (self.__current_state_index + 1) % len(self.__states) return self.current_state ","common-pitfalls-and-best-practices#Common Pitfalls and Best Practices":"","data-encapsulation-with-immutable-objects#Data Encapsulation with Immutable Objects":"Another form of encapsulation in Python is creating immutable objects—objects whose state cannot be modified after creation. This is a strong form of encapsulation because it guarantees that an object’s state remains consistent throughout its lifetime.\nclass ImmutablePoint: def __init__(self, x, y): self.__x = x self.__y = y @property def x(self): return self.__x @property def y(self): return self.__y # Instead of modifying, create a new instance def move(self, dx, dy): return ImmutablePoint(self.__x + dx, self.__y + dy) def __str__(self): return f\"Point({self.__x}, {self.__y})\" In this example, ImmutablePoint provides read-only properties for x and y, and operations like move() return a new instance rather than modifying the existing one.","exercises#Exercises":"Exercise 1: Create a BankAccount class with private attributes for account number, holder name, and balance. Include methods for deposit, withdrawal, and checking the balance. Ensure that the account number can’t be changed after creation, and the balance can only be modified through deposits and withdrawals.\nExercise 2: Enhance the BankAccount class by adding properties for account_number, holder_name, and balance. Make account_number a read-only property, holder_name a property that can be read and modified, and balance a read-only property. Add a method to get the account details as a dictionary.\nExercise 3: Create a ShoppingCart class that encapsulates a collection of items and their quantities. The class should have methods to add items, remove items, update quantities, calculate the total price, and clear the cart. Use appropriate encapsulation techniques to ensure the internal representation of the cart can’t be directly modified.\nHint for Exercise 1:\nclass BankAccount: def __init__(self, account_number, holder_name, initial_balance=0): self.__account_number = account_number self.__holder_name = holder_name self.__balance = initial_balance def deposit(self, amount): if amount \u003e 0: self.__balance += amount return True return False # Implement withdrawal and check_balance methods In the next section, we’ll explore inheritance in Python, which allows you to create a hierarchy of classes and reuse code from parent classes.","getters-and-setters-in-python#Getters and Setters in Python":"Getters and setters are methods that provide controlled access to attributes. They allow you to:\nValidate data before assigning it to an attribute Compute derived attributes on-the-fly Enforce encapsulation rules Change implementation details without affecting the public interface class Person: def __init__(self, name, age): self._name = name self._age = age # Getter for name def get_name(self): return self._name # Setter for name def set_name(self, name): if isinstance(name, str) and name: self._name = name else: raise ValueError(\"Name must be a non-empty string\") # Getter for age def get_age(self): return self._age # Setter for age with validation def set_age(self, age): if isinstance(age, int) and 0 \u003c= age \u003c= 120: self._age = age else: raise ValueError(\"Age must be an integer between 0 and 120\") ","pitfalls#Pitfalls":" Overusing Private Attributes: While encapsulation is important, making everything private can create unnecessary complexity. Use private attributes only when needed.\nExposing Implementation Details: If you expose too many details about how a class works internally, it becomes harder to change the implementation later.\nInconsistent Access Patterns: Mixing direct attribute access, getters/setters, and properties can make code confusing. Try to be consistent.\nForgetting Documentation: Well-encapsulated code still needs good documentation to explain what methods do, especially if the implementation is hidden.","practical-example-library-management-system#Practical Example: Library Management System":"Let’s see encapsulation in action with a more complex example of a library management system:\nclass Book: def __init__(self, title, author, isbn, available=True): self.__title = title self.__author = author self.__isbn = isbn self.__available = available self.__borrower = None @property def title(self): return self.__title @property def author(self): return self.__author @property def isbn(self): return self.__isbn @property def is_available(self): return self.__available @property def borrower(self): return self.__borrower def borrow(self, patron_id): \"\"\"Attempt to borrow this book.\"\"\" if self.__available: self.__available = False self.__borrower = patron_id return True return False def return_book(self): \"\"\"Return this book to the library.\"\"\" self.__available = True self.__borrower = None class Library: def __init__(self, name): self.__name = name self.__books = {} # ISBN -\u003e Book mapping self.__patrons = set() # Set of registered patron IDs @property def name(self): return self.__name @property def book_count(self): return len(self.__books) @property def patron_count(self): return len(self.__patrons) def add_book(self, book): \"\"\"Add a book to the library collection.\"\"\" if not isinstance(book, Book): raise TypeError(\"Can only add Book objects to the library\") self.__books[book.isbn] = book def register_patron(self, patron_id): \"\"\"Register a new patron.\"\"\" self.__patrons.add(patron_id) def borrow_book(self, isbn, patron_id): \"\"\" Process a book borrowing request. Returns: - True if successful - False if book is unavailable - None if book or patron doesn't exist \"\"\" if isbn not in self.__books: return None if patron_id not in self.__patrons: return None return self.__books[isbn].borrow(patron_id) def return_book(self, isbn): \"\"\"Process a book return.\"\"\" if isbn in self.__books: self.__books[isbn].return_book() return True return False def get_available_books(self): \"\"\"Get a list of available books.\"\"\" return [book for book in self.__books.values() if book.is_available] def get_borrowed_books(self): \"\"\"Get a list of borrowed books.\"\"\" return [book for book in self.__books.values() if not book.is_available] # Using the library system def main(): # Create a library central_library = Library(\"Central City Library\") # Add books book1 = Book(\"Python Programming\", \"John Smith\", \"978-1-123456-78-9\") book2 = Book(\"Data Structures\", \"Jane Doe\", \"978-1-234567-89-0\") central_library.add_book(book1) central_library.add_book(book2) # Register patrons central_library.register_patron(\"P001\") central_library.register_patron(\"P002\") # Borrow books success = central_library.borrow_book(\"978-1-123456-78-9\", \"P001\") print(f\"Borrowing result: {success}\") # Check status available_books = central_library.get_available_books() borrowed_books = central_library.get_borrowed_books() print(\"\\nAvailable Books:\") for book in available_books: print(f\"- {book.title} by {book.author}\") print(\"\\nBorrowed Books:\") for book in borrowed_books: print(f\"- {book.title} by {book.author}, borrowed by {book.borrower}\") # Return a book central_library.return_book(\"978-1-123456-78-9\") print(\"\\nAfter return, available books:\") for book in central_library.get_available_books(): print(f\"- {book.title} by {book.author}\") if __name__ == \"__main__\": main() In this example:\nThe Book class encapsulates book details and the borrowing state The Library class encapsulates the collection of books and patron information Both classes use private attributes (with double underscores) to protect their internal state Public methods provide controlled ways to interact with these classes Properties provide read-only access to certain attributes ","properties-in-python#Properties in Python":"Python provides a more elegant way to implement getters and setters using the @property decorator and its corresponding setter, which allows you to access the methods as if they were attributes:\nclass Person: def __init__(self, name, age): self._name = name self._age = age # Property for name @property def name(self): \"\"\"Get the person's name.\"\"\" return self._name @name.setter def name(self, value): \"\"\"Set the person's name with validation.\"\"\" if isinstance(value, str) and value: self._name = value else: raise ValueError(\"Name must be a non-empty string\") # Property for age @property def age(self): \"\"\"Get the person's age.\"\"\" return self._age @age.setter def age(self, value): \"\"\"Set the person's age with validation.\"\"\" if isinstance(value, int) and 0 \u003c= value \u003c= 120: self._age = value else: raise ValueError(\"Age must be an integer between 0 and 120\") # Read-only property (no setter) @property def is_adult(self): \"\"\"Check if the person is an adult.\"\"\" return self._age \u003e= 18 With properties, you can use a more natural syntax while still enforcing encapsulation:\nperson = Person(\"Alice\", 30) # Using properties like attributes (but they're methods) print(person.name) # Uses the @property getter person.name = \"Alicia\" # Uses the @name.setter print(person.age) # Uses the @property getter person.age = 31 # Uses the @age.setter print(person.is_adult) # Uses the @property getter (read-only) # person.is_adult = False # Error: can't set attribute (no setter defined) Note: Properties provide a clean way to implement encapsulation without changing how client code interacts with your classes. They’re especially useful when you start with simple public attributes and later need to add validation or computation.","understanding-encapsulation#Understanding Encapsulation":"At its core, encapsulation serves two main purposes:\nBundling related data and methods together: This creates a coherent, self-contained unit that’s easier to understand and use. Restricting access to certain components: This prevents external code from directly modifying an object’s internal state in potentially harmful ways. Encapsulation can be thought of as creating a protective wrapper around your data to ensure it’s only accessed or modified in controlled ways.\n# Example of a simple encapsulated class class BankAccount: def __init__(self, account_number, balance): self._account_number = account_number # Protected attribute self._balance = balance # Protected attribute # Public methods to access and modify data in controlled ways def get_balance(self): return self._balance def deposit(self, amount): if amount \u003e 0: self._balance += amount return True return False def withdraw(self, amount): if 0 \u003c amount \u003c= self._balance: self._balance -= amount return True return False In this example, the BankAccount class encapsulates data (account number and balance) and provides methods that safely interact with this data. External code can’t directly modify the balance, ensuring that deposits and withdrawals follow the business rules (positive deposits, no overdrafts)."},"title":"Encapsulation in Python"},"/python-fundamentals/08-error-handling/":{"data":{"":"In Python programming, errors are an inevitable part of the development process, ranging from syntax errors to runtime exceptions that occur when your code is executing.\nLearning how to properly handle these errors allows you to create robust programs that can anticipate problems and respond gracefully instead of crashing.\nEffective error handling improves user experience, makes debugging easier, and allows your applications to recover from unexpected situations. Understanding Python’s error handling mechanisms is an essential skill that separates beginner programmers from more experienced developers.\nHere is what Error Handling section covers:\n01. Types of Errors in Python 02. Try-Except Blocks in Python 03. Raising Exceptions in Python 04. Debugging Techniques in Python 05. How to use Python debugger "},"title":"Error Handling"},"/python-fundamentals/08-error-handling/01-types-of-errors/":{"data":{"":"Understanding the different types of errors that can occur in Python is essential for effective debugging and writing robust code. Python errors are generally categorized into three main types: syntax errors, runtime errors (exceptions), and logical errors. Let’s explore each type in detail.","common-error-patterns-and-solutions#Common Error Patterns and Solutions":"Let’s look at some common error patterns and how to solve them:\n1. Forgetting to Initialize Variables # Error scenario def calculate_total(): for price in prices: total += price # NameError: name 'total' is not defined return total # Solution def calculate_total(): total = 0 # Initialize the variable for price in prices: total += price return total 2. Off-by-One Errors in Loops # Error scenario def print_list_items(items): for i in range(1, len(items)): # Starts at index 1, missing the first item print(items[i]) # Solution def print_list_items(items): for i in range(len(items)): # Start at index 0 print(items[i]) # Alternatively, iterate over the items directly for item in items: print(item) 3. Mismatched Types in Operations # Error scenario user_input = input(\"Enter a number: \") result = user_input * 2 # This will concatenate the string, not multiply the number # Solution user_input = input(\"Enter a number: \") result = int(user_input) * 2 # Convert to integer first 4. Forgetting to Return Values from Functions # Error scenario def add(a, b): result = a + b # No return statement; function returns None # Solution def add(a, b): result = a + b return result # Add return statement 5. Using Assignment (=) Instead of Equality Comparison (==) # Error scenario if x = 5: # SyntaxError print(\"x is 5\") # Solution if x == 5: # Use == for comparison print(\"x is 5\") 6. KeyError in Dictionaries # Error scenario user = {\"name\": \"Alice\", \"age\": 30} print(user[\"email\"]) # KeyError: 'email' # Solution user = {\"name\": \"Alice\", \"age\": 30} if \"email\" in user: print(user[\"email\"]) else: print(\"Email not found\") # Alternative solution using .get() with a default value print(user.get(\"email\", \"Email not found\")) 7. Infinite Loops # Error scenario i = 0 while i \u003c 10: print(i) # Forgot to increment i, creating an infinite loop # Solution i = 0 while i \u003c 10: print(i) i += 1 # Increment i to eventually end the loop ","exception-hierarchy#Exception Hierarchy":"Python exceptions form a hierarchy, with more specific exceptions inheriting from more general ones. This is useful when handling exceptions, as catching a base exception will also catch all its derived exceptions.\nHere’s a simplified view of the exception hierarchy:\nBaseException ├── SystemExit ├── KeyboardInterrupt ├── GeneratorExit └── Exception ├── StopIteration ├── ArithmeticError │ ├── FloatingPointError │ ├── OverflowError │ └── ZeroDivisionError ├── AssertionError ├── AttributeError ├── BufferError ├── EOFError ├── ImportError │ └── ModuleNotFoundError ├── LookupError │ ├── IndexError │ └── KeyError ├── MemoryError ├── NameError │ └── UnboundLocalError ├── OSError │ ├── BlockingIOError │ ├── ChildProcessError │ ├── ConnectionError │ ├── FileExistsError │ ├── FileNotFoundError │ ├── InterruptedError │ ├── IsADirectoryError │ ├── NotADirectoryError │ ├── PermissionError │ ├── ProcessLookupError │ └── TimeoutError ├── ReferenceError ├── RuntimeError │ ├── NotImplementedError │ └── RecursionError ├── SyntaxError │ └── IndentationError │ └── TabError ├── SystemError ├── TypeError ├── ValueError │ └── UnicodeError │ ├── UnicodeDecodeError │ ├── UnicodeEncodeError │ └── UnicodeTranslateError └── Warning ├── DeprecationWarning ├── PendingDeprecationWarning ├── RuntimeWarning ├── SyntaxWarning ├── UserWarning ├── FutureWarning ├── ImportWarning ├── UnicodeWarning ├── BytesWarning └── ResourceWarning ","exercises#Exercises":"Exercise 1: Identify and fix the errors in the following code:\ndef greet(name) print(\"Hello, \" + name) print(\"Welcome to Python programming\") greet(\"Alice\" Exercise 2: The following code should calculate the factorial of a number but contains errors. Identify and fix them:\ndef factorial(n): if n = 0: return 1 else: return n * factorial(n-1) print(factorial(-5)) Exercise 3: The following code should find the largest number in a list but has logical errors. Find and fix them:\ndef find_largest(numbers): largest = 0 for num in numbers: if num \u003e largest: largest = num return largest print(find_largest([5, 10, 3, 8, -20])) Hint for Exercise 1: Look for missing syntax elements like colons and parentheses.\nIn the next section, we’ll explore try-except blocks and learn how to handle exceptions gracefully in Python programs.","identifying-and-fixing-errors#Identifying and Fixing Errors":"Identifying Syntax Errors Syntax errors are usually the easiest to fix because the interpreter points out the location and nature of the problem:\nLook at the error message and the line number indicated Check the line and the one above it for missing colons, parentheses, etc. Check indentation, especially in compound statements Verify that all string quotes are properly closed # Original code with syntax error if x == 5 print(\"x equals 5\") # Error message # SyntaxError: invalid syntax # Fixed code if x == 5: print(\"x equals 5\") Identifying Runtime Errors For runtime errors, use the error message and traceback to pinpoint the issue:\nStart by looking at the exception type and the specific error message Examine the line where the exception occurred Check the types of values involved in the operation Verify that all objects and attributes exist # Original code with runtime error numbers = [1, 2, 3] print(numbers[3]) # Error message # IndexError: list index out of range # Fixed code numbers = [1, 2, 3] if len(numbers) \u003e 3: print(numbers[3]) else: print(\"Index out of range\") Identifying Logical Errors Logical errors are more challenging to find and fix:\nTest your code with simple, predictable inputs where you know the expected output Add print statements to show intermediate values and program flow Use a debugger to step through the code Check your algorithm against a manual calculation Review the requirements to ensure your understanding is correct # Original code with logical error def celsius_to_fahrenheit(celsius): # Incorrect formula - addition before multiplication return celsius + 32 * 9/5 # Testing reveals the error print(celsius_to_fahrenheit(0)) # Should be 32, but outputs 32.0 print(celsius_to_fahrenheit(100)) # Should be 212, but outputs 132.0 # Fixed code with correct formula def celsius_to_fahrenheit(celsius): # Correct formula - multiplication before addition return celsius * 9/5 + 32 # Verify the fix print(celsius_to_fahrenheit(0)) # 32.0 print(celsius_to_fahrenheit(100)) # 212.0 ","logical-errors-bugs#Logical Errors (Bugs)":"Logical errors are the most challenging to identify because they don’t produce error messages. The program runs without crashing, but it produces incorrect or unexpected results. These errors occur when the code logic is flawed.\nExamples of logical errors include:\nUsing the wrong variable in a calculation Implementing an algorithm incorrectly Off-by-one errors (iterating one too many or too few times) Incorrect operator precedence Misunderstanding function return values # Logical error: calculating average incorrectly def calculate_average(numbers): total = 0 for num in numbers: total += num return total / len(numbers) + 1 # The + 1 is incorrect numbers = [10, 20, 30, 40] avg = calculate_average(numbers) print(f\"Average: {avg}\") # Outputs 26.0 instead of the correct 25.0 Logical errors require careful debugging because there are no direct indicators of what’s wrong. You need to analyze the code’s behavior and compare it with the expected behavior.","practical-example-debugging-a-program#Practical Example: Debugging a Program":"Let’s examine a program with multiple errors and work through fixing them:\n# Program with various errors def calculate_average(numbers) total = 0 for num in numbers total += num return total / length(numbers) def main(): grades = [85, 90, 78, 92, 88] average = calculate_average(grades) print(\"The average grade is: \" + average) # Find students with grades above average above_average = [] for i in range(1, len(grades)): if grade \u003e average: above_average.append(grade) print(\"Grades above average:\") print(above_average) if __name__ == \"__main__\" main() Let’s identify and fix the errors:\nSyntax Error: Missing colon after function definition\ndef calculate_average(numbers): # Added colon Syntax Error: Missing colon after for loop\nfor num in numbers: # Added colon NameError: length() is not a Python function (should be len())\nreturn total / len(numbers) # Corrected function name TypeError: Cannot concatenate string and number\nprint(\"The average grade is: \" + str(average)) # Convert to string NameError: grade is not defined in the loop (should use grades[i])\nif grades[i] \u003e average: # Use grades[i] to access the element Logic Error: Loop starts at index 1, missing the first grade\nfor i in range(len(grades)): # Start at index 0 Syntax Error: Missing colon after if statement\nif __name__ == \"__main__\": # Added colon Logic Error: We’re appending grades[i] to above_average, not grade\nabove_average.append(grades[i]) # Fixed to match the correct variable Here’s the corrected version of the program:\n# Corrected program def calculate_average(numbers): total = 0 for num in numbers: total += num return total / len(numbers) def main(): grades = [85, 90, 78, 92, 88] average = calculate_average(grades) print(\"The average grade is: \" + str(average)) # Find students with grades above average above_average = [] for i in range(len(grades)): if grades[i] \u003e average: above_average.append(grades[i]) print(\"Grades above average:\") print(above_average) if __name__ == \"__main__\": main() ","runtime-errors-exceptions#Runtime Errors (Exceptions)":"Runtime errors, also known as exceptions, occur during program execution. Unlike syntax errors, code with potential runtime errors can start running, but it will terminate when the error condition is encountered unless the exception is explicitly handled.\nPython has many built-in exception types that indicate specific error conditions. Here are some common ones:\n1. TypeError Occurs when an operation or function is applied to an object of an inappropriate type:\n# Trying to add a string and an integer result = \"Hello\" + 5 # Output: # TypeError: can only concatenate str (not \"int\") to str 2. NameError Occurs when a local or global name is not found:\n# Using a variable that hasn't been defined print(undefined_variable) # Output: # NameError: name 'undefined_variable' is not defined 3. IndexError Occurs when trying to access an index that is outside the bounds of a sequence:\n# Trying to access an index beyond the list length my_list = [1, 2, 3] print(my_list[5]) # Output: # IndexError: list index out of range 4. KeyError Occurs when a dictionary key is not found:\n# Trying to access a key that doesn't exist in a dictionary my_dict = {\"name\": \"Alice\", \"age\": 25} print(my_dict[\"city\"]) # Output: # KeyError: 'city' 5. ValueError Occurs when a function receives an argument of the correct type but an inappropriate value:\n# Converting a non-numeric string to an integer int(\"hello\") # Output: # ValueError: invalid literal for int() with base 10: 'hello' 6. ZeroDivisionError Occurs when dividing by zero:\n# Division by zero result = 10 / 0 # Output: # ZeroDivisionError: division by zero 7. FileNotFoundError Occurs when trying to access a file that doesn’t exist:\n# Opening a file that doesn't exist with open(\"nonexistent_file.txt\", \"r\") as file: content = file.read() # Output: # FileNotFoundError: [Errno 2] No such file or directory: 'nonexistent_file.txt' 8. ImportError or ModuleNotFoundError Occurs when an import statement fails to find or load a module:\n# Importing a module that doesn't exist import nonexistent_module # Output: # ModuleNotFoundError: No module named 'nonexistent_module' 9. AttributeError Occurs when an attribute reference or assignment fails:\n# Accessing a method that doesn't exist \"hello\".nonexistent_method() # Output: # AttributeError: 'str' object has no attribute 'nonexistent_method' 10. IndentationError A specific syntax error that occurs when indentation is incorrect:\ndef function(): print(\"This is not properly indented\") # Output: # IndentationError: expected an indented block Note: All exceptions in Python inherit from the base Exception class. You can see the full hierarchy by running help(BaseException) in a Python interpreter.","syntax-errors#Syntax Errors":"Syntax errors occur when the Python interpreter encounters code that doesn’t follow the language’s syntax rules. These errors are detected during the parsing phase, before the code begins executing. As a result, a program with syntax errors won’t run at all.\nCommon syntax errors include:\nMissing colons after if/for/while statements Missing or mismatched parentheses, brackets, or quotes Incorrect indentation Using invalid variable names Misspelling keywords # Missing colon after if statement if x \u003e 5 print(\"x is greater than 5\") # Output: # File \"\u003cstdin\u003e\", line 1 # if x \u003e 5 # ^ # SyntaxError: invalid syntax # Indentation error if x \u003e 5: print(\"x is greater than 5\") # This line should be indented # Output: # File \"\u003cstdin\u003e\", line 2 # print(\"x is greater than 5\") # ^ # IndentationError: expected an indented block When you encounter a syntax error, Python will show you the line where the error was detected and point to the approximate location with a caret (^) symbol. However, the actual error might be on the previous line or elsewhere, as the error is often detected only after the parser has moved past the problematic code.\nImportant: The Python interpreter stops at the first syntax error it encounters, so fix one error at a time and then check for additional errors.","understanding-error-messages#Understanding Error Messages":"Python error messages provide valuable information for diagnosing and fixing problems. Let’s break down the components of a typical error message:\nTraceback (most recent call last): File \"example.py\", line 5, in \u003cmodule\u003e result = divide(10, 0) File \"example.py\", line 2, in divide return a / b ZeroDivisionError: division by zero Traceback: Shows the sequence of function calls that led to the error, with the most recent call at the bottom. File and Line Information: Indicates the file name and line number where each call occurred. Code Context: Shows the actual line of code that caused the error. Exception Type: Names the specific exception that was raised (e.g., ZeroDivisionError). Error Message: Provides details about what went wrong (e.g., “division by zero”). Reading error messages from bottom to top can help you quickly identify the specific issue while the full traceback helps you understand the context in which the error occurred."},"title":"Types of Errors in Python"},"/python-fundamentals/08-error-handling/02-try-except-blocks/":{"data":{"":"","basic-try-except-structure#Basic Try-Except Structure":"","best-practices-for-exception-handling#Best Practices for Exception Handling":"1. Be Specific About Which Exceptions to Catch # Too broad - might hide bugs try: # Some code except: # Handle any exception # Better - catch specific exceptions try: # Some code except ValueError: # Handle ValueError except ZeroDivisionError: # Handle ZeroDivisionError 2. Keep the Try Block as Small as Possible # Not recommended - try block is too large try: file = open(\"data.txt\", \"r\") content = file.read() numbers = [int(x) for x in content.split()] average = sum(numbers) / len(numbers) print(f\"Average: {average}\") file.close() except: print(\"An error occurred\") # Better - separate try blocks for different operations try: file = open(\"data.txt\", \"r\") except FileNotFoundError: print(\"File not found\") exit() try: content = file.read() finally: file.close() try: numbers = [int(x) for x in content.split()] average = sum(numbers) / len(numbers) print(f\"Average: {average}\") except ValueError: print(\"File contains non-numeric data\") except ZeroDivisionError: print(\"File contains no data\") 3. Avoid Silencing Exceptions Without Good Reason # Bad practice - silently ignoring exceptions try: some_risky_function() except: pass # Ignores all exceptions # Better - handle or log the exception try: some_risky_function() except Exception as e: print(f\"An error occurred: {e}\") # Or log the error for later investigation logging.error(f\"Error in some_risky_function: {e}\") 4. Use Context Managers for Resource Management # Not recommended file = open(\"data.txt\", \"r\") try: content = file.read() finally: file.close() # Better - using a context manager try: with open(\"data.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"File not found\") 5. Clean Up Resources in the finally Block connection = None try: connection = create_database_connection() # Use the connection except ConnectionError: print(\"Failed to connect to the database\") finally: if connection: connection.close() 6. Don’t Use Exceptions for Flow Control # Not recommended - using exceptions for normal flow control try: result = dictionary[key] except KeyError: result = default_value # Better - use a conditional result = dictionary.get(key, default_value) # Not recommended try: value = int(input(\"Enter a number: \")) except ValueError: value = 0 # Better user_input = input(\"Enter a number: \") if user_input.isdigit(): value = int(user_input) else: value = 0 However, there are cases where using exceptions for control flow is the “Pythonic” way, particularly when dealing with the “easier to ask forgiveness than permission” (EAFP) coding style:\n# EAFP style (Pythonic) try: return mapping[key] except KeyError: return default_value # Look before you leap style (less Pythonic in this case) if key in mapping: return mapping[key] else: return default_value 7. Use Logging Instead of Print Statements for Errors import logging # Configure logging logging.basicConfig( level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', filename='app.log' ) try: # Some risky operation result = 10 / 0 except ZeroDivisionError: # Log the error instead of just printing it logging.error(\"Division by zero attempted\") ","catching-multiple-exceptions#Catching Multiple Exceptions":"","catching-specific-exceptions#Catching Specific Exceptions":"","common-exception-handling-patterns#Common Exception Handling Patterns":"Pattern 1: Retry Logic import time import random def make_api_request(endpoint): \"\"\"Simulate an API request that might fail temporarily.\"\"\" if random.random() \u003c 0.7: # 70% chance of failure raise ConnectionError(\"API connection failed\") return {\"status\": \"success\", \"data\": \"Some data\"} def get_api_data(endpoint, max_retries=3, delay=1): \"\"\"Get data from an API with retry logic.\"\"\" retries = 0 while retries \u003c max_retries: try: return make_api_request(endpoint) except ConnectionError as e: retries += 1 if retries == max_retries: print(f\"Failed after {max_retries} attempts. Error: {e}\") return None print(f\"Attempt {retries} failed. Retrying in {delay} seconds...\") time.sleep(delay) delay *= 2 # Exponential backoff # Test the function result = get_api_data(\"/users\") if result: print(f\"API request succeeded: {result}\") Pattern 2: Default Value Pattern def get_config_value(config_dict, key, default=None): \"\"\" Get a configuration value with a default if it doesn't exist or has the wrong type. \"\"\" try: return config_dict[key] except KeyError: return default except TypeError: # This could happen if config_dict is not actually a dictionary return default # Test the function config = {\"port\": 8080, \"host\": \"localhost\"} print(get_config_value(config, \"port\")) # 8080 print(get_config_value(config, \"debug\", False)) # False print(get_config_value(None, \"anything\", \"default\")) # \"default\" Pattern 3: Cleanup Pattern def process_file(filename): \"\"\"Process a file and ensure it gets closed even if errors occur.\"\"\" temp_file = None try: # Open the original file with open(filename, 'r') as file: content = file.read() # Create a temporary file for processing temp_filename = filename + \".tmp\" temp_file = open(temp_filename, 'w') # Process the content and write to temp file processed_content = content.replace('old', 'new') temp_file.write(processed_content) return True except FileNotFoundError: print(f\"The file {filename} was not found.\") return False except IOError as e: print(f\"I/O error occurred: {e}\") return False finally: # Make sure the temp file is closed if temp_file: temp_file.close() Pattern 4: Context Manager Pattern class TempFile: \"\"\"A context manager for temporary files.\"\"\" def __init__(self, filename): self.filename = filename self.file = None def __enter__(self): self.file = open(self.filename, 'w') return self.file def __exit__(self, exc_type, exc_val, exc_tb): if self.file: self.file.close() # If an exception occurred, log it but don't suppress it if exc_type is not None: print(f\"An error occurred: {exc_type.__name__}: {exc_val}\") # Returning False means any exceptions will be propagated return False # Using our custom context manager try: with TempFile(\"temp.txt\") as file: file.write(\"Hello, World!\") # Let's simulate an error if random.random() \u003c 0.5: raise RuntimeError(\"Random error occurred\") except RuntimeError: print(\"Handled the runtime error outside the context manager\") ","complete-structure#Complete Structure":"","creating-custom-exceptions#Creating Custom Exceptions":"","debugging-with-try-except#Debugging with Try-Except":"While try-except blocks are primarily for error handling, they can also help with debugging. Here are some techniques:\nUsing print for Poor Man’s Debugging def complex_function(a, b, c): \"\"\"A function with multiple steps that might fail.\"\"\" try: print(f\"Starting with values: a={a}, b={b}, c={c}\") step1 = a / b print(f\"After step 1: {step1}\") step2 = step1 + c print(f\"After step 2: {step2}\") step3 = step2 ** 2 print(f\"After step 3: {step3}\") return step3 except Exception as e: print(f\"Error occurred: {type(e).__name__}: {e}\") raise # Re-raise the exception after logging it Using the Traceback Module import traceback def function_with_error(): \"\"\"A function that will raise an error.\"\"\" return 1 / 0 try: function_with_error() except Exception as e: print(f\"An error occurred: {e}\") traceback.print_exc() # Print the full traceback ","exercises#Exercises":"Exercise 1: Write a function called safe_division that takes two parameters and returns their division. Your function should handle cases where the second parameter is zero or either parameter is not a number. Return None in case of errors.\nExercise 2: Create a program that reads a CSV file, converts each line into a list of integers, and calculates the sum of each line. Use exception handling to deal with lines that contain non-numeric values or files that don’t exist.\nExercise 3: Write a function called get_element that takes a list, an index, and a default value. It should return the element at the given index or the default value if the index is out of range.\nExercise 4: Create a context manager called Timer that measures and prints the time taken to execute the code inside the with block. Use the time module to measure execution time.\nHint for Exercise 1:\ndef safe_division(a, b): try: return a / b except ZeroDivisionError: print(\"Error: Division by zero.\") return None except TypeError: print(\"Error: Inputs must be numbers.\") return None In the next section, we’ll explore raising exceptions, which allows you to create and raise your own exceptions when specific conditions are met in your code.","getting-exception-information#Getting Exception Information":"","practical-examples#Practical Examples":"Example 1: Basic File Processing def read_file_content(filename): \"\"\"Read and return the content of a file, handling potential errors.\"\"\" try: with open(filename, 'r') as file: content = file.read() return content except FileNotFoundError: print(f\"Error: The file '{filename}' was not found.\") except PermissionError: print(f\"Error: You don't have permission to read '{filename}'.\") except Exception as e: print(f\"An unexpected error occurred: {e}\") # If any exception occurred, return None return None # Test the function content = read_file_content(\"example.txt\") if content: print(f\"File content: {content}\") else: print(\"Could not read the file.\") Example 2: User Input Validation def get_positive_integer(prompt): \"\"\"Get a positive integer from the user with input validation.\"\"\" while True: try: value = int(input(prompt)) if value \u003c= 0: print(\"Please enter a positive number.\") continue return value except ValueError: print(\"Invalid input. Please enter a number.\") # Test the function age = get_positive_integer(\"Enter your age: \") print(f\"Your age is {age}.\") Example 3: Safe Dictionary Access def safe_get(dictionary, key, default=None): \"\"\"Safely get a value from a dictionary with a default if the key doesn't exist.\"\"\" try: return dictionary[key] except KeyError: return default # Test the function user_data = {\"name\": \"John\", \"age\": 30} print(safe_get(user_data, \"name\")) # John print(safe_get(user_data, \"email\")) # None print(safe_get(user_data, \"email\", \"N/A\")) # N/A Example 4: Database Connection with Error Handling import sqlite3 def execute_query(database_path, query, parameters=()): \"\"\"Execute a query on an SQLite database with comprehensive error handling.\"\"\" connection = None try: connection = sqlite3.connect(database_path) cursor = connection.cursor() cursor.execute(query, parameters) connection.commit() return cursor.fetchall() except sqlite3.OperationalError as e: print(f\"Database operation failed: {e}\") except sqlite3.IntegrityError as e: print(f\"Database integrity error: {e}\") except Exception as e: print(f\"Unexpected error: {e}\") finally: if connection: connection.close() return None # Example usage results = execute_query(\"users.db\", \"SELECT * FROM users WHERE age \u003e ?\", (25,)) if results: for row in results: print(row) else: print(\"Query failed or returned no results.\") ","raising-exceptions#Raising Exceptions":"","re-raising-exceptions#Re-raising Exceptions":"","the-assert-statement#The \u003ccode\u003eassert\u003c/code\u003e Statement":"In programming, errors and exceptions are inevitable. Rather than letting them crash your program, Python provides a powerful mechanism called “exception handling” that allows you to catch and respond to errors gracefully. The primary tool for this is the try-except block.\nUnderstanding Exceptions Before diving into try-except blocks, it’s important to understand what exceptions are. An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions. When Python encounters an error, it creates an exception object containing information about the error.\nCommon exceptions include:\nSyntaxError: Occurs when Python can’t parse your code (not catchable with try-except) NameError: Occurs when you try to use a variable that doesn’t exist TypeError: Occurs when an operation is performed on an object of inappropriate type ValueError: Occurs when a function receives an argument of the correct type but inappropriate value IndexError: Occurs when you try to access an index that’s outside the bounds of a sequence KeyError: Occurs when you try to access a dictionary key that doesn’t exist FileNotFoundError: Occurs when you try to open a file that doesn’t exist ZeroDivisionError: Occurs when you try to divide by zero Basic Try-Except Structure The basic syntax of a try-except block is:\ntry: # Code that might raise an exception # This is the \"protected\" block except: # Code that executes if an exception occurs # This is the \"handler\" block Here’s a simple example:\ntry: num = int(input(\"Enter a number: \")) print(f\"You entered: {num}\") except: print(\"That's not a valid number!\") In this example:\nThe code in the try block attempts to convert user input to an integer If the conversion succeeds, it prints the number If the conversion fails (e.g., if the user enters “abc”), Python raises a ValueError The except block catches the exception and displays a friendly error message Important: Using a bare except: clause (without specifying an exception type) catches all exceptions. This is generally not recommended as it can hide unexpected errors and make debugging difficult.\nCatching Specific Exceptions It’s better practice to catch specific exceptions:\ntry: num = int(input(\"Enter a number: \")) result = 10 / num print(f\"10 divided by {num} is {result}\") except ValueError: print(\"That's not a valid number!\") except ZeroDivisionError: print(\"You can't divide by zero!\") This approach allows you to handle different types of errors in different ways. Python checks each except clause in order and executes the first one that matches the raised exception.\nCatching Multiple Exceptions You can also catch multiple exception types in a single except clause:\ntry: num = int(input(\"Enter a number: \")) result = 10 / num print(f\"10 divided by {num} is {result}\") except (ValueError, ZeroDivisionError): print(\"Invalid input: Please enter a non-zero number.\") This is useful when you want to handle different exceptions in the same way.\nGetting Exception Information You can capture the exception object itself using the as keyword:\ntry: with open(\"nonexistent_file.txt\", \"r\") as file: content = file.read() except FileNotFoundError as e: print(f\"Error: {e}\") print(f\"Error type: {type(e).__name__}\") The exception object contains useful information about what went wrong.\nThe else Clause The else clause in a try-except block executes if no exceptions occur:\ntry: num = int(input(\"Enter a number: \")) result = 10 / num except ValueError: print(\"That's not a valid number!\") except ZeroDivisionError: print(\"You can't divide by zero!\") else: print(f\"10 divided by {num} is {result}\") print(\"No exceptions occurred!\") Using else separates the exception-handling code from the code that should run when everything succeeds, making your program easier to understand.\nThe finally Clause The finally clause executes regardless of whether an exception occurred:\ntry: file = open(\"data.txt\", \"r\") content = file.read() except FileNotFoundError: print(\"The file was not found.\") finally: # This executes no matter what try: file.close() except: pass # If file wasn't opened, file.close() would raise an exception print(\"File operation attempted.\") The finally clause is especially useful for cleanup operations that should always occur, like closing files or network connections, regardless of whether an exception happened.\nNote: Using context managers (the with statement) is often a cleaner alternative to finally for resource cleanup:\ntry: with open(\"data.txt\", \"r\") as file: # File automatically closes when block exits content = file.read() except FileNotFoundError: print(\"The file was not found.\") Complete Structure The complete try-except structure can include all of these components:\ntry: # Code that might raise an exception except ExceptionType1: # Handle ExceptionType1 except ExceptionType2: # Handle ExceptionType2 except: # Handle any other exceptions else: # Execute if no exceptions occurred finally: # Always execute this block Raising Exceptions Sometimes, you need to raise exceptions yourself:\ndef divide(a, b): if b == 0: raise ValueError(\"Cannot divide by zero\") return a / b try: result = divide(10, 0) except ValueError as e: print(f\"Error: {e}\") You can raise built-in exceptions or create custom ones by subclassing Exception.\nCreating Custom Exceptions For domain-specific errors, it’s often useful to create custom exceptions:\nclass InsufficientFundsError(Exception): \"\"\"Raised when a withdrawal exceeds the available balance.\"\"\" pass class BankAccount: def __init__(self, balance=0): self.balance = balance def withdraw(self, amount): if amount \u003e self.balance: raise InsufficientFundsError(f\"Cannot withdraw ${amount}. Only ${self.balance} available.\") self.balance -= amount return self.balance # Using the custom exception account = BankAccount(100) try: account.withdraw(150) except InsufficientFundsError as e: print(f\"Transaction failed: {e}\") Custom exceptions make your code more readable and help communicate the specific problem that occurred.\nRe-raising Exceptions Sometimes you want to catch an exception, perform some action, and then re-raise it:\ntry: # Some code that might raise an exception x = 1 / 0 except ZeroDivisionError: print(\"Logging the zero division error\") raise # Re-raises the most recent exception This is useful when you need to perform some cleanup or logging but still want the exception to propagate to the caller.\nThe assert Statement Python’s assert statement provides a simple way to test conditions during development:\ndef calculate_average(numbers): assert len(numbers) \u003e 0, \"Cannot calculate average of empty list\" return sum(numbers) / len(numbers) try: avg = calculate_average([]) except AssertionError as e: print(f\"Error: {e}\") Assertions are primarily used for debugging and should not be used to handle runtime errors in production code.","the-else-clause#The \u003ccode\u003eelse\u003c/code\u003e Clause":"","the-finally-clause#The \u003ccode\u003efinally\u003c/code\u003e Clause":"","understanding-exceptions#Understanding Exceptions":""},"title":"Try-Except Blocks in Python"},"/python-fundamentals/08-error-handling/03-raising-exceptions/":{"data":{"":"","assertions-vs-exceptions#Assertions vs. Exceptions":"Python provides an assert statement, which can also raise exceptions (specifically, AssertionError). However, assertions and exceptions serve different purposes:\ndef calculate_average(numbers): # Assertion: used for conditions that should never happen # and indicate a bug in the program assert isinstance(numbers, list), \"Numbers must be a list\" assert numbers, \"List cannot be empty\" # Exception: used for expected error conditions # that can happen during normal operation if not all(isinstance(x, (int, float)) for x in numbers): raise TypeError(\"All elements must be numbers\") return sum(numbers) / len(numbers) Important:\nUse assertions for programmer errors that should never happen in production Use exceptions for expected error conditions that might happen in normal operation Assertions can be disabled globally in production by running Python with the -O optimization flag ","built-in-exception-types#Built-in Exception Types":"Python provides many built-in exception types to handle various error situations:\nException Description Exception Base class for all exceptions ArithmeticError Base class for arithmetic errors AssertionError Raised when an assert statement fails AttributeError Raised when attribute reference/assignment fails EOFError Raised when input() hits end-of-file condition FileNotFoundError Raised when a file or directory is requested but doesn’t exist ImportError Raised when the imported module is not found IndexError Raised when index of a sequence is out of range KeyError Raised when a key is not found in a dictionary KeyboardInterrupt Raised when the user hits interrupt key (Ctrl+C) NameError Raised when a local or global name is not found NotImplementedError Raised by abstract methods OSError Raised when system operation causes system error OverflowError Raised when the result of an arithmetic operation is too large RuntimeError Raised when an error does not fall under any other category StopIteration Raised by next() to indicate there are no further items SyntaxError Raised by parser when syntax error is encountered TypeError Raised when a function or operation is applied to an object of incorrect type ValueError Raised when a function gets an argument of correct type but improper value ZeroDivisionError Raised when division or modulo by zero occurs Choose the most appropriate exception type based on the error situation to make your code more clear and maintainable.","common-patterns-for-raising-exceptions#Common Patterns for Raising Exceptions":"1. Validate Inputs Early Check function inputs immediately and raise exceptions before doing any work:\ndef process_user_data(user_id, data): if not isinstance(user_id, int) or user_id \u003c= 0: raise ValueError(f\"Invalid user ID: {user_id}. Must be a positive integer.\") if not isinstance(data, dict): raise TypeError(f\"Data must be a dictionary, got {type(data).__name__}\") required_fields = ['name', 'email', 'age'] for field in required_fields: if field not in data: raise ValueError(f\"Missing required field: {field}\") # Now we can safely proceed with processing # ... 2. Use a Factory Function to Handle Multiple Error Cases For complex validation logic:\ndef create_user(user_data): try: validate_name(user_data.get('name')) validate_email(user_data.get('email')) validate_age(user_data.get('age')) validate_address(user_data.get('address')) return User(**user_data) except ValueError as e: # Re-package multiple validation errors into one user-friendly message raise ValueError(f\"Invalid user data: {e}\") from e 3. Explicit Error Messages with Contextual Information Include relevant context in error messages:\ndef withdraw(account, amount): if amount \u003c= 0: raise ValueError(f\"Withdrawal amount must be positive, got {amount}\") if amount \u003e account.balance: raise InsufficientFundsError( balance=account.balance, amount=amount, message=f\"Account {account.id} has insufficient funds\" ) # Process withdrawal # ... 4. Error Hierarchies for API Design Create an exception hierarchy for cleaner API design:\n# Base exception for your module class DatabaseError(Exception): \"\"\"Base class for all database exceptions.\"\"\" pass # More specific exceptions class ConnectionError(DatabaseError): \"\"\"Raised when connection to the database fails.\"\"\" pass class QueryError(DatabaseError): \"\"\"Raised when a query is invalid.\"\"\" pass class RecordNotFoundError(QueryError): \"\"\"Raised when a requested record doesn't exist.\"\"\" pass # Usage in code def get_user(user_id): try: connect_to_db() except IOError as e: raise ConnectionError(\"Failed to connect to database\") from e try: result = execute_query(f\"SELECT * FROM users WHERE id = {user_id}\") if not result: raise RecordNotFoundError(f\"User with ID {user_id} does not exist\") return result except SyntaxError as e: raise QueryError(f\"Invalid query syntax: {e}\") from e ","creating-custom-exceptions#Creating Custom Exceptions":"For specialized error handling, you can create your own exception classes by inheriting from the built-in Exception class or a more specific exception class:\nclass InsufficientFundsError(Exception): \"\"\"Exception raised when a withdrawal exceeds the available balance.\"\"\" def __init__(self, balance, amount, message=\"Insufficient funds\"): self.balance = balance self.amount = amount self.message = f\"{message}: available balance ${balance}, attempted withdrawal ${amount}\" super().__init__(self.message) class BankAccount: def __init__(self, owner, balance=0): self.owner = owner self.balance = balance def withdraw(self, amount): if amount \u003e self.balance: raise InsufficientFundsError(self.balance, amount) self.balance -= amount return self.balance try: account = BankAccount(\"John Doe\", 100) account.withdraw(150) except InsufficientFundsError as e: print(f\"Transaction failed: {e}\") # Output: Transaction failed: Insufficient funds: available balance $100, attempted withdrawal $150 Custom exceptions:\nMake error handling more specific and readable Allow storing of additional context relevant to the exception Create a hierarchy of exception types for your application domain Note: Name your custom exceptions with the suffix “Error” to follow Python convention and make the code more readable.","exercises#Exercises":"Exercise 1: Write a function called divide_numbers that takes two parameters and returns their division. The function should raise appropriate exceptions for different error cases, such as non-numeric inputs or division by zero.\nExercise 2: Create a Person class with attributes for name, age, and email. Implement validation in the __init__ method to raise appropriate exceptions if:\nName is not a string or is empty Age is not a number or is negative Email doesn’t contain an ‘@’ character Exercise 3: Implement a custom exception hierarchy for a banking system. Create a base BankException class and at least three specific exception types that inherit from it (like InsufficientFundsError, AccountNotFoundError, etc.). Then write a transfer_money function that uses these exceptions.\nExercise 4: Write a function that reads a JSON configuration file and raises appropriate exceptions with helpful error messages for different failure modes (file not found, invalid JSON, missing required fields, etc.).\nHint for Exercise 1: Consider using isinstance() to check the types of the input parameters, and use specific exceptions like TypeError for wrong types and ZeroDivisionError for division by zero.\n# Exercise 1 solution outline def divide_numbers(a, b): if not isinstance(a, (int, float)) or not isinstance(b, (int, float)): raise TypeError(\"Both inputs must be numbers\") if b == 0: raise ZeroDivisionError(\"Cannot divide by zero\") return a / b In the next section, we’ll explore debugging techniques and tools in Python to help you find and fix errors in your code more efficiently.","practical-example-file-processing-with-exception-handling#Practical Example: File Processing with Exception Handling":"Let’s look at a practical example that demonstrates raising and handling exceptions:\ndef process_data_file(filename): \"\"\" Process data from a file with comprehensive error handling. Args: filename (str): The name of the file to process Returns: list: Processed data from the file Raises: ValueError: If the file format is invalid FileNotFoundError: If the file doesn't exist PermissionError: If we don't have permission to read the file \"\"\" try: with open(filename, 'r') as file: lines = file.readlines() if not lines: raise ValueError(f\"File '{filename}' is empty\") processed_data = [] for line_num, line in enumerate(lines, 1): line = line.strip() if not line: continue # Skip empty lines try: # Assume each line should contain comma-separated numbers values = [float(val) for val in line.split(',')] if not values: raise ValueError(f\"Line {line_num} doesn't contain any values\") processed_data.append(values) except ValueError as e: # Re-raise with more context raise ValueError(f\"Error in line {line_num}: {line} - {str(e)}\") from e return processed_data except FileNotFoundError: raise FileNotFoundError(f\"File '{filename}' does not exist\") except PermissionError: raise PermissionError(f\"No permission to read '{filename}'\") except Exception as e: # Catch-all for unexpected errors raise RuntimeError(f\"Unexpected error processing '{filename}'\") from e # Usage try: data = process_data_file(\"measurements.csv\") print(f\"Successfully processed {len(data)} data points\") except ValueError as e: print(f\"Data format error: {e}\") except FileNotFoundError as e: print(f\"File error: {e}\") except PermissionError as e: print(f\"Permission error: {e}\") except Exception as e: print(f\"Unexpected error: {e}\") # In a real application, you might log the full traceback here This example demonstrates:\nRaising specific exceptions for different error conditions Adding context to exceptions Re-raising exceptions with additional information Using exception hierarchy for organized error handling ","raising-from-exception-handlers#Raising from Exception Handlers":"You can also use exception handlers to transform lower-level exceptions into higher-level ones that make more sense in your application’s context:\ndef get_user_data(user_id): try: # Database operations that might raise various exceptions return database.find_user(user_id) except database.ConnectionError: raise ServiceUnavailableError(\"Database connection failed\") except database.QueryError: raise InvalidRequestError(f\"Invalid user ID format: {user_id}\") except database.TimeoutError: raise ServiceUnavailableError(\"Database query timed out\") This pattern helps in creating a clear separation between the internal implementation details and the external API of your module.","re-raising-exceptions#Re-raising Exceptions":"Sometimes you want to catch an exception, perform some operations, and then re-raise the exception to be handled further up the call stack:\ndef process_data(data): try: result = complex_calculation(data) return result except ValueError as e: print(f\"Logging error: {e}\") # Clean up resources, log the error, etc. raise # Re-raise the caught exception You can also raise a different exception while preserving the original exception as the cause using the from keyword:\ndef read_configuration(): try: with open(\"config.json\", \"r\") as file: import json return json.load(file) except json.JSONDecodeError as e: # Transform the exception to a more application-specific one raise ConfigurationError(\"Invalid configuration format\") from e except FileNotFoundError as e: raise ConfigurationError(\"Configuration file not found\") from e The from clause maintains the traceback of the original exception, which helps with debugging.","the-raise-statement#The \u003ccode\u003eraise\u003c/code\u003e Statement":"While handling exceptions is important, there are situations where you’ll want to deliberately raise exceptions in your code. Raising exceptions allows you to signal errors or exceptional conditions that occur during program execution, making your code more robust and communicative.\nThe raise Statement Python provides the raise statement to explicitly trigger exceptions. The basic syntax is:\nraise ExceptionType(\"Error message\") Here’s a simple example:\ndef divide(a, b): if b == 0: raise ZeroDivisionError(\"Cannot divide by zero\") return a / b try: result = divide(10, 0) except ZeroDivisionError as e: print(f\"Error: {e}\") # Output: Error: Cannot divide by zero In this example, rather than letting Python raise the exception, we explicitly raise it with our own custom message.","the-zen-of-exception-handling#The Zen of Exception Handling":"For effective exception handling and raising:\nBe specific: Raise the most specific exception type for the error\n# Good if not os.path.exists(filename): raise FileNotFoundError(f\"File {filename} not found\") # Less good if not os.path.exists(filename): raise Exception(f\"File {filename} not found\") # Too generic Provide context: Include specific information in exception messages\n# Good raise ValueError(f\"Invalid age: {age}. Age must be between 0 and 120\") # Less good raise ValueError(\"Invalid input\") # Too vague Catch only what you can handle: Don’t catch exceptions you don’t plan to handle properly\n# Good try: process_data(user_input) except ValueError as e: print(f\"Invalid input: {e}\") # Dangerous try: process_data(user_input) except Exception: # Catches everything, including programming errors print(\"An error occurred\") Don’t suppress exceptions: Avoid empty except blocks\n# Bad practice try: process_data(user_input) except: pass # Silently ignores all errors Clean up resources: Use finally or context managers to ensure resources are released\n# Good try: file = open(\"data.txt\", \"r\") process_file(file) except Exception as e: handle_error(e) finally: file.close() # Always executed # Better with open(\"data.txt\", \"r\") as file: # Context manager handles closing process_file(file) ","when-to-raise-exceptions#When to Raise Exceptions":"You should raise exceptions in the following situations:\nInput validation: When function parameters don’t meet expected requirements Impossible state: When the program reaches a state that shouldn’t be possible API contracts: When your code interface contract is violated Resource unavailability: When required resources aren’t accessible Business rules: When business logic constraints are violated Here’s an example of input validation:\ndef calculate_square_root(number): if not isinstance(number, (int, float)): raise TypeError(\"Input must be a number\") if number \u003c 0: raise ValueError(\"Cannot calculate square root of a negative number\") return number ** 0.5 try: result = calculate_square_root(-5) except ValueError as e: print(f\"Error: {e}\") # Output: Error: Cannot calculate square root of a negative number Important: Raising exceptions is not just about preventing errors but also about making your code communicate issues clearly. A well-crafted exception explains what went wrong and why."},"title":"Raising Exceptions in Python"},"/python-fundamentals/08-error-handling/04-debugging-techniques/":{"data":{"error-handling-and-debugging#Error Handling and Debugging":"Debugging Techniques Debugging is a critical skill for every programmer. Even the most experienced developers write code with bugs, but what sets them apart is their ability to efficiently identify and fix these issues. In this section, we’ll explore various debugging techniques and tools available in Python.\nUnderstanding Common Error Types Before diving into debugging techniques, it’s helpful to understand the common types of errors you might encounter:\nSyntax Errors: Occur when the Python parser is unable to understand your code due to violations of the language’s syntax rules. Runtime Errors (Exceptions): Occur during the execution of a program, even if the syntax is correct. Logical Errors: The code runs without raising exceptions, but produces incorrect results due to flaws in the logic. Print Debugging The simplest debugging technique is to add print() statements to your code to inspect variable values and program flow:\ndef calculate_average(numbers): print(f\"Input: {numbers}\") # Debug print total = 0 for num in numbers: total += num print(f\"Added {num}, total is now {total}\") # Debug print average = total / len(numbers) print(f\"Calculated average: {average}\") # Debug print return average # Test the function result = calculate_average([10, 20, 30, 40, 50]) print(f\"Final result: {result}\") Advantages of Print Debugging:\nSimple and requires no special tools Works in any environment Easy to understand Disadvantages of Print Debugging:\nCan clutter the code and output Must be manually added and removed Not interactive Inefficient for complex issues Best Practices for Print Debugging:\nUse descriptive messages: print(f\"User data after processing: {user_data}\") Format output for readability: print(f\"Status: {'Success' if status else 'Failure'}\") Use temporary variables for complex expressions: result = complex_calculation(x, y, z) print(f\"Result of calculation: {result}\") Using the logging Module A more sophisticated alternative to print() statements is the built-in logging module:\nimport logging # Configure logging logging.basicConfig( level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s', filename='debug.log' # Optional: log to a file instead of console ) def calculate_average(numbers): logging.debug(f\"Input: {numbers}\") if not numbers: logging.error(\"Empty list provided\") raise ValueError(\"Cannot calculate average of empty list\") total = 0 for num in numbers: total += num logging.debug(f\"Added {num}, total is now {total}\") average = total / len(numbers) logging.info(f\"Calculated average: {average}\") return average # Test the function try: result = calculate_average([10, 20, 30, 40, 50]) print(f\"Final result: {result}\") except Exception as e: logging.exception(\"An error occurred\") print(f\"Error: {e}\") Advantages of Logging:\nDifferent log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL) Can be enabled/disabled without code changes Can log to files, network, email, etc. Includes timestamps and other metadata Can stay in production code Note: The logging levels help categorize the importance of log messages:\nDEBUG: Detailed information, typically for diagnosing problems INFO: Confirmation that things are working as expected WARNING: An indication that something unexpected happened, but the program is still working ERROR: Due to a more serious problem, the software has not been able to perform some function CRITICAL: A serious error, indicating that the program itself may be unable to continue running Using a Debugger Python comes with a built-in debugger called pdb (Python Debugger) that allows you to interactively debug your code:\nimport pdb def complex_function(x, y): result = x * 2 pdb.set_trace() # Start the debugger at this point result = result + y return result * 2 # Test the function output = complex_function(5, 10) print(output) When the debugger is activated, you’ll be presented with a command prompt. Here are some common commands:\nCommand Description n (next) Execute the current line and move to the next one s (step) Step into a function call c (continue) Continue execution until the next breakpoint q (quit) Quit the debugger l (list) Show the current location in the code p expression Print the value of an expression pp expression Pretty-print the value of an expression w (where) Show the current call stack b line_number Set a breakpoint at a specific line h (help) Show help on debugger commands Important: In Python 3.7 and later, you can use the built-in breakpoint() function instead of importing pdb and calling pdb.set_trace():\ndef complex_function(x, y): result = x * 2 breakpoint() # Start the debugger at this point result = result + y return result * 2 Debugging in IDE: Visual Studio Code Most modern IDEs include powerful debugging tools. Let’s look at how debugging works in Visual Studio Code:\nSet a Breakpoint: Click in the gutter (the space to the left of the line numbers) to set a breakpoint.\nStart Debugging: Press F5 or click the “Run and Debug” button in the sidebar.\nUse the Debug Controls:\nContinue (F5): Resume execution until the next breakpoint Step Over (F10): Execute the current line and move to the next one Step Into (F11): Step into a function call Step Out (Shift+F11): Execute the rest of the current function and return to the caller Restart (Ctrl+Shift+F5): Restart the debugging session Stop (Shift+F5): End the debugging session Inspect Variables: View and modify variable values in the “Variables” panel.\nWatch Expressions: Add expressions to the “Watch” panel to monitor their values.\nView the Call Stack: See the sequence of function calls that led to the current point.\nNote: Similar debugging features are available in other IDEs like PyCharm, Jupyter Notebooks, and Spyder.\nDebugging with assert Statements Assert statements provide a simple way to check that conditions are as expected:\ndef calculate_rectangle_area(length, width): assert length \u003e 0, \"Length must be positive\" assert width \u003e 0, \"Width must be positive\" area = length * width assert area \u003e 0, \"Area calculation error\" return area # Test the function try: result = calculate_rectangle_area(5, -2) print(f\"Area: {result}\") except AssertionError as e: print(f\"Error: {e}\") # Output: Error: Width must be positive assert statements are particularly useful for:\nValidating function inputs and outputs Checking invariants (conditions that should always be true) Verifying that your code’s assumptions are correct Important: Assert statements can be completely removed when Python is run with the -O (optimize) flag, so don’t use them for input validation in production code. Use proper exception handling instead.\nException Handling for Debugging While exceptions are primarily for handling runtime errors, they can also be useful for debugging:\ndef process_data(data): try: result = data['value'] * 2 return result except KeyError: # Print debugging information print(f\"KeyError in process_data. Available keys: {data.keys()}\") # Re-raise the exception with more information raise KeyError(f\"Missing 'value' key in data: {data}\") except TypeError as e: print(f\"TypeError in process_data: {e}\") print(f\"Data type: {type(data)}, Value type: {type(data.get('value', None))}\") raise # Re-raise the original exception # Test the function try: result = process_data({'other_key': 10}) print(result) except Exception as e: print(f\"Error caught: {e}\") This approach helps diagnose issues by:\nProviding context about what was happening when the error occurred Logging relevant variable values Adding more specific error messages Debugging with Tracebacks When an exception occurs, Python provides a traceback that shows the sequence of function calls leading to the error:\nTraceback (most recent call last): File \"example.py\", line 20, in \u003cmodule\u003e result = process_data({'other_key': 10}) File \"example.py\", line 4, in process_data result = data['value'] * 2 KeyError: 'value' To get the traceback as a string for logging or analysis:\nimport traceback try: # Code that might raise an exception result = 10 / 0 except Exception: # Get the traceback as a string trace = traceback.format_exc() print(f\"An error occurred:\\n{trace}\") # Log the traceback for future reference with open(\"error_log.txt\", \"a\") as f: f.write(f\"\\n--- New Error ---\\n{trace}\\n\") Debugging Complex Data Structures For complex data structures, Python’s pretty-printing module (pprint) can be invaluable:\nfrom pprint import pprint complex_data = { 'users': [ {'name': 'Alice', 'age': 30, 'roles': ['admin', 'user'], 'metadata': {'joined': '2020-01-15', 'last_login': '2023-05-20'}}, {'name': 'Bob', 'age': 25, 'roles': ['user'], 'metadata': {'joined': '2021-03-10', 'last_login': '2023-05-18'}} ], 'settings': { 'theme': 'dark', 'notifications': {'email': True, 'sms': False, 'push': True}, 'permissions': ['read', 'write', 'delete'] } } # Standard print print(\"Using print():\") print(complex_data) # Pretty print print(\"\\nUsing pprint():\") pprint(complex_data, width=40, depth=2) # Control the formatting # You can also use pprint with a depth limit for nested structures print(\"\\nWith depth limit:\") pprint(complex_data, depth=1) # Only show the first level Rubber Duck Debugging A surprisingly effective technique is “rubber duck debugging”:\nGet a rubber duck (or any object/imaginary person) Explain your code to the duck, line by line Often, the act of explaining the problem helps you find the solution This technique works because it forces you to:\nArticulate what each part of your code is supposed to do Compare your expectations with what’s actually happening Consider aspects of the problem you might have overlooked Time-Travel Debugging Techniques Sometimes, bugs are intermittent or hard to reproduce. In these cases, “time-travel” debugging techniques can help:\nLogging with Timestamps:\nimport time def process_transaction(transaction): start_time = time.time() log_entry = f\"[{time.strftime('%H:%M:%S')}] Processing transaction {transaction['id']}\\n\" # Various processing steps... time.sleep(0.5) # Simulate processing time log_entry += f\"[{time.strftime('%H:%M:%S')}] Transaction processed in {time.time() - start_time:.2f} seconds\\n\" with open(\"transaction_log.txt\", \"a\") as f: f.write(log_entry) Record and Replay: Save inputs and intermediate states to reproduce issues later.\nDebugging a Real Example Let’s walk through debugging a flawed function that calculates the median of a list of numbers:\ndef calculate_median(numbers): # Sort the numbers sorted_numbers = sorted(numbers) # Find the middle position n = len(sorted_numbers) middle = n / 2 # Return the median if n % 2 == 1: # Odd number of elements return sorted_numbers[middle] else: # Even number of elements return (sorted_numbers[middle - 1] + sorted_numbers[middle]) / 2 # Test with odd number of elements print(calculate_median([7, 2, 5, 1, 9])) # Should be 5 # Test with even number of elements print(calculate_median([7, 2, 5, 1, 9, 8])) # Should be 6 When we run this code, we get:\nTraceback (most recent call last): File \"median.py\", line 16, in \u003cmodule\u003e print(calculate_median([7, 2, 5, 1, 9])) File \"median.py\", line 10, in calculate_median return sorted_numbers[middle] TypeError: list indices must be integers or slices, not float Let’s debug this step by step:\nIdentify the Error: The error message tells us that we’re trying to use a float as a list index, which isn’t allowed.\nLocate the Problem: The error is on line 10, where we’re using middle as an index.\nAdd Debug Prints:\ndef calculate_median(numbers): print(f\"Input: {numbers}\") # Sort the numbers sorted_numbers = sorted(numbers) print(f\"Sorted: {sorted_numbers}\") # Find the middle position n = len(sorted_numbers) middle = n / 2 print(f\"n: {n}, middle: {middle}, type(middle): {type(middle)}\") # ... rest of the function Fix the Issue: Now we can see that middle is a float (5/2 = 2.5), but list indices must be integers. We need to convert middle to an integer:\n# For odd number of elements if n % 2 == 1: return sorted_numbers[int(middle)] Test and Verify: After making this change, we should test both cases again to ensure they work correctly.\nFully corrected function:\ndef calculate_median(numbers): # Sort the numbers sorted_numbers = sorted(numbers) # Find the middle position n = len(sorted_numbers) middle = n // 2 # Use integer division # Return the median if n % 2 == 1: # Odd number of elements return sorted_numbers[middle] else: # Even number of elements return (sorted_numbers[middle - 1] + sorted_numbers[middle]) / 2 # Test with odd number of elements print(calculate_median([7, 2, 5, 1, 9])) # 5 # Test with even number of elements print(calculate_median([7, 2, 5, 1, 9, 8])) # 6.0 Unit Testing as a Debugging Tool Unit tests can be a powerful debugging tool by verifying that specific parts of your code work as expected:\nimport unittest def calculate_rectangle_area(length, width): return length * width class TestCalculateArea(unittest.TestCase): def test_positive_values(self): self.assertEqual(calculate_rectangle_area(5, 4), 20) def test_zero_values(self): self.assertEqual(calculate_rectangle_area(0, 5), 0) self.assertEqual(calculate_rectangle_area(5, 0), 0) def test_negative_values(self): # Should area be negative or should we raise an error? with self.assertRaises(ValueError): calculate_rectangle_area(-5, 4) # Run the tests if __name__ == \"__main__\": unittest.main() This helps us:\nVerify that fixes actually solve the problem Prevent regression (reintroducing bugs) Document expected behavior Debugging Checklist When faced with a bug, follow this systematic approach:\nReproduce the Bug:\nCreate a minimal test case that consistently triggers the bug. Understand the Error Message:\nRead the error message carefully, noting the exception type and line number. Examine the traceback to understand the sequence of function calls. Inspect Variable Values:\nAdd print statements or use a debugger to check variable values. Verify that inputs and outputs match your expectations. Check Assumptions:\nAre you assuming something about the data that’s not true? Are function arguments in the correct order? Are you using the right data type? Isolate the Problem:\nComment out sections of code to pinpoint where the issue lies. Simplify complex expressions into multiple steps. Fix the Bug:\nMake one change at a time. Test after each change to verify that it fixes the issue. Add Tests:\nCreate a test that would have caught this bug. Run the test to confirm your fix works. Document the Issue and Solution:\nAdd comments explaining the bug and how you fixed it. Update documentation if necessary. Exercises Exercise 1: The following function is supposed to count the frequency of each character in a string. However, it has a bug. Use print debugging to find and fix the issue:\ndef count_characters(text): counter = {} for char in text: if char in counter: counter[char] += 1 else: counter[char] = 1 return counter result = count_characters(\"hello world\") print(result) # Expected: {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} Exercise 2: The following function attempts to find the largest number in a list that is divisible by a given divisor. However, it has multiple bugs. Use the pdb debugger to find and fix them:\ndef largest_divisible(numbers, divisor): largest = 0 for num in numbers: if num % divisor == 0: if num \u003e largest: largest = num return largest numbers = [12, 30, 21, 8, 25, 15, 22] result = largest_divisible(numbers, 5) print(result) # Expected: 30 Exercise 3: Create a function called analyze_student_scores that takes a list of student score dictionaries and returns statistics about the scores (min, max, average). Include error handling and debugging features like assertions and logging. Test your function with valid and invalid inputs.\n# Example input: scores = [ {'name': 'Alice', 'score': 85}, {'name': 'Bob', 'score': 92}, {'name': 'Charlie', 'score': 78}, # ...possibly more students ] # Your function should handle cases like: # - Empty list # - Missing 'score' key # - Non-numeric scores Hint for Exercise 1: Add print statements to display the value of char and counter during each iteration of the loop.\nIn the next section, we’ll explore using the Python debugger in more detail, learning how to set breakpoints, step through code, and inspect variables to find bugs efficiently.","python-programming-for-beginners#Python Programming for Beginners":"Python Programming for Beginners"},"title":"Debugging Techniques in Python"},"/python-fundamentals/08-error-handling/05-using-python-debugger/":{"data":{"":"Debugging is an essential skill for all programmers. No matter how careful you are, you’ll inevitably encounter bugs in your code. The Python debugger (pdb) provides powerful tools to help you find and fix these issues efficiently.","advanced-debugging-techniques#Advanced Debugging Techniques":"Using pdb.run() You can execute a string of Python code under the debugger:\nimport pdb pdb.run('calculate_average([1, 2, 3, 4, 0])') Debugging Multi-Threaded Programs Standard pdb can be challenging for multi-threaded programs. Consider specialized tools:\n# Example using threading-specific debugging import threading import multiprocessing import pdb # For thread debugging, you might need to use thread-specific tools # or synchronization mechanisms Remote Debugging For debugging applications running on a remote server or in a different process:\n# On the server side from remote_pdb import RemotePdb RemotePdb('0.0.0.0', 4444).set_trace() # Connect from your local machine using telnet # $ telnet server_ip 4444 ","automated-debugging-tools#Automated Debugging Tools":"Besides manual debugging, Python offers automated tools to help identify issues:\nUsing the logging Module Logging is a non-intrusive way to track program execution:\nimport logging # Configure logging logging.basicConfig( level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' ) def calculate_average(numbers): logging.debug(f\"Starting with numbers: {numbers}\") if not numbers: logging.warning(\"Empty list provided!\") return 0 total = sum(numbers) logging.debug(f\"Sum calculated: {total}\") average = total / len(numbers) logging.debug(f\"Average calculated: {average}\") return average # Test the function result = calculate_average([1, 2, 3, 4, 5]) print(f\"The average is {result}\") Code Profiling When debugging performance issues, profiling tools can help:\nimport cProfile def slow_function(): result = 0 for i in range(1000000): result += i return result # Profile the function cProfile.run('slow_function()') Memory Profiling For memory-related issues, you can use memory profilers:\n# First install: pip install memory_profiler from memory_profiler import profile @profile def memory_heavy_function(): big_list = [i for i in range(10000000)] return len(big_list) memory_heavy_function() ","basic-debugging-commands#Basic Debugging Commands":"Once the debugger is running, you can use various commands to control execution and examine the program state:\nCommand Description h or help Show list of available commands q or quit Exit the debugger c or continue Continue execution until next breakpoint n or next Execute the current line and move to the next line (doesn’t enter functions) s or step Step into a function call r or return Continue execution until the current function returns l or list Show the current position in the code p expression Print the value of an expression pp expression Pretty-print the value of an expression w or where Show the current call stack b or break Set a breakpoint clear Clear breakpoints u or up Move up one level in the call stack d or down Move down one level in the call stack Here’s a sample debugging session:\n\u003e my_script.py(7)calculate_average() -\u003e average = total / len(numbers) (Pdb) p total 15 (Pdb) p len(numbers) 5 (Pdb) p numbers [1, 2, 3, 4, 5] (Pdb) n \u003e my_script.py(8)calculate_average() -\u003e return average (Pdb) p average 3.0 (Pdb) c The average is 3.0 ","common-debugging-patterns-and-challenges#Common Debugging Patterns and Challenges":"Pattern: “It works on my machine” This often indicates environmental differences:\nimport sys import platform import os def debug_environment(): \"\"\"Print information about the execution environment.\"\"\" print(f\"Python version: {sys.version}\") print(f\"Platform: {platform.platform()}\") print(f\"Current working directory: {os.getcwd()}\") print(f\"Environment variables: {dict(os.environ)}\") # Call at the beginning of scripts that might be environment-sensitive debug_environment() Pattern: “It sometimes fails” Random failures often indicate race conditions or undefined behavior:\nimport random import time def occasionally_fails(): \"\"\"Function that randomly fails.\"\"\" if random.random() \u003c 0.3: # 30% chance of failure raise ValueError(\"Random failure!\") return \"Success\" # Debug by forcing reproducibility random.seed(42) # Set a fixed seed for reproducible randomness Challenge: Debugging Long-Running Processes For processes that take hours to reach the bug:\ndef long_running_process(iterations): state = {\"count\": 0, \"checkpoints\": []} try: for i in range(iterations): # Save checkpoint every 1000 iterations if i % 1000 == 0: state[\"count\"] = i state[\"checkpoints\"].append(f\"Checkpoint at {i}\") # Save checkpoint to disk import json with open(\"checkpoint.json\", \"w\") as f: json.dump(state, f) # Actual processing here process_item(i) except Exception as e: print(f\"Error at iteration {i}: {e}\") # Analyze the last saved checkpoint with open(\"checkpoint.json\", \"r\") as f: last_state = json.load(f) print(f\"Last successful state: {last_state}\") raise ","debugging-best-practices#Debugging Best Practices":" Isolate the Problem: Try to narrow down where the issue is occurring.\n# Divide and conquer approach def complex_function(): part1 = step1() print(\"Step 1 completed successfully\") part2 = step2() print(\"Step 2 completed successfully\") return combine(part1, part2) Use Assertions: Add assertions to verify your assumptions.\ndef calculate_discount(price, discount_percentage): assert 0 \u003c= discount_percentage \u003c= 100, f\"Invalid discount: {discount_percentage}\" discount = price * (discount_percentage / 100) final_price = price - discount assert final_price \u003c= price, f\"Discounted price {final_price} higher than original {price}\" return final_price Add Strategic Print Statements: When a debugger isn’t practical.\ndef process_data(data): print(f\"Starting with data: {data[:5]}... (length: {len(data)})\") processed = [] for i, item in enumerate(data): if i % 1000 == 0: print(f\"Processing item {i}/{len(data)}\") processed.append(transform(item)) print(f\"Finished processing. Result length: {len(processed)}\") return processed Keep a Debugging Log: Document what you’ve tried and what you’ve learned.\nUse Version Control: Make small, testable changes and commit them.\nWrite Tests: Automated tests can prevent bugs and help debug them.\nimport unittest class TestMedianFunction(unittest.TestCase): def test_odd_length_list(self): result = find_median([5, 2, 9, 1, 7]) self.assertEqual(result, 5) def test_even_length_list(self): result = find_median([5, 2, 9, 1, 7, 6]) self.assertEqual(result, 5.5) def test_empty_list(self): with self.assertRaises(ValueError): find_median([]) if __name__ == \"__main__\": unittest.main() ","debugging-workflow-a-practical-example#Debugging Workflow: A Practical Example":"Let’s walk through debugging a function that’s supposed to find the median of a list:\ndef find_median(numbers): # Sort the list sorted_numbers = numbers.sort() # Find the middle position n = len(sorted_numbers) middle = n // 2 # Return the median if n % 2 == 0: # Even number of elements return (sorted_numbers[middle - 1] + sorted_numbers[middle]) / 2 else: # Odd number of elements return sorted_numbers[middle] # Test the function test_list = [5, 2, 9, 1, 7] median = find_median(test_list) print(f\"The median is: {median}\") Running this will produce an error. Let’s debug it:\nimport pdb def find_median(numbers): # Add a breakpoint pdb.set_trace() # Sort the list sorted_numbers = numbers.sort() # Find the middle position n = len(sorted_numbers) middle = n // 2 # Return the median if n % 2 == 0: # Even number of elements return (sorted_numbers[middle - 1] + sorted_numbers[middle]) / 2 else: # Odd number of elements return sorted_numbers[middle] # Test the function test_list = [5, 2, 9, 1, 7] median = find_median(test_list) print(f\"The median is: {median}\") Debugging session:\n\u003e script.py(6)find_median() -\u003e sorted_numbers = numbers.sort() (Pdb) p numbers [5, 2, 9, 1, 7] (Pdb) n \u003e script.py(9)find_median() -\u003e n = len(sorted_numbers) (Pdb) p sorted_numbers None We’ve found the first issue! list.sort() sorts the list in-place and returns None. Let’s fix this:\n(Pdb) numbers.sort() (Pdb) p numbers [1, 2, 5, 7, 9] (Pdb) sorted_numbers = numbers (Pdb) c We’ll still get an error. Let’s restart with the fixed code:\ndef find_median(numbers): # Make a copy to avoid modifying the original numbers_copy = numbers.copy() # Sort the list numbers_copy.sort() # sorts in-place # Find the middle position n = len(numbers_copy) middle = n // 2 # Return the median if n % 2 == 0: # Even number of elements return (numbers_copy[middle - 1] + numbers_copy[middle]) / 2 else: # Odd number of elements return numbers_copy[middle] # Test with odd number of elements test_list_odd = [5, 2, 9, 1, 7] median_odd = find_median(test_list_odd) print(f\"Median of {test_list_odd}: {median_odd}\") # Should be 5 # Test with even number of elements test_list_even = [5, 2, 9, 1, 7, 6] median_even = find_median(test_list_even) print(f\"Median of {test_list_even}: {median_even}\") # Should be 5.5 ","exercises#Exercises":"Exercise 1: The following function is supposed to count the frequency of each character in a string, but it has a bug. Use the debugger to find and fix the issue:\ndef count_characters(text): frequencies = {} for char in text: if char in frequencies: frequencies[char] += 1 else: frequencies[char] = 1 return frequencies # Test the function result = count_characters(\"hello world\") print(result) # Expected: {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} Exercise 2: The following recursive function is supposed to calculate the sum of digits in a number, but it has a bug that causes it to enter an infinite recursion. Use the debugger to find and fix the issue:\ndef sum_of_digits(n): if n \u003c 10: return n else: last_digit = n % 10 remaining_digits = n / 10 # Bug is here return last_digit + sum_of_digits(remaining_digits) # Test the function print(sum_of_digits(123)) # Expected: 6 (1+2+3) Exercise 3: Create a function that finds the two numbers in a list that add up to a target value. The function should use the debugger to step through the process and validate its logic:\ndef find_two_sum(numbers, target): # Add debugging to this function import pdb; pdb.set_trace() # Your solution here for i in range(len(numbers)): for j in range(i+1, len(numbers)): if numbers[i] + numbers[j] == target: return (numbers[i], numbers[j]) return None # Test the function print(find_two_sum([2, 7, 11, 15], 9)) # Expected: (2, 7) Hint for Exercise 1: The function logic seems correct. Use the debugger to step through the execution with a test case and examine the frequencies dictionary at each step.\nIn the next section, we’ll explore how to work with files in Python, including reading from and writing to different file formats.","introduction-to-the-python-debugger-pdb#Introduction to the Python Debugger (pdb)":"Python comes with a built-in debugger module called pdb (Python Debugger). This interactive debugger allows you to:\nPause program execution at specific points (breakpoints) Step through your code line by line Inspect variable values at any point Evaluate expressions in the current context Modify variables during runtime ","practical-debugging-techniques#Practical Debugging Techniques":"Setting Conditional Breakpoints You can set breakpoints that only trigger when certain conditions are met:\nimport pdb def process_items(items): results = [] for i, item in enumerate(items): processed = item * 2 if i == 3: pdb.set_trace() # Only break at the 4th item (index 3) results.append(processed) return results process_items([5, 10, 15, 20, 25, 30]) Alternatively, using the debugger console:\n(Pdb) b my_script.py:7, i \u003e 10 Breakpoint 1 at my_script.py:7 (Pdb) c # Continue until the condition is met Examining Variables and Call Stack When your program behaves unexpectedly, it’s often because variables don’t contain what you think they do. The debugger lets you examine them:\n(Pdb) p locals() # Print all local variables {'items': [5, 10, 15, 20, 25, 30], 'results': [10, 20, 30], 'i': 3, 'item': 20, 'processed': 40} (Pdb) pp locals() # Pretty-print for better formatting {'i': 3, 'item': 20, 'items': [5, 10, 15, 20, 25, 30], 'processed': 40, 'results': [10, 20, 30]} To see how you got to the current point, examine the call stack:\n(Pdb) w my_script.py(11)\u003cmodule\u003e() -\u003e process_items([5, 10, 15, 20, 25, 30]) \u003e my_script.py(7)process_items() -\u003e pdb.set_trace() Modifying Variables During Debugging One powerful feature of the debugger is the ability to modify variables on the fly:\n(Pdb) p item 20 (Pdb) item = 100 (Pdb) p processed 40 (Pdb) processed = 200 (Pdb) c # Continue execution with modified values This allows you to test fixes without restarting the program.","starting-the-debugger#Starting the Debugger":"There are several ways to start the Python debugger:\n1. Using pdb.set_trace() The simplest way to use the debugger is to insert pdb.set_trace() at the point where you want to start debugging:\nimport pdb def calculate_average(numbers): total = 0 for num in numbers: total += num pdb.set_trace() # Debugger will start here average = total / len(numbers) return average result = calculate_average([1, 2, 3, 4, 5]) print(f\"The average is {result}\") When this code runs, the program will pause at the pdb.set_trace() line and drop you into the debugger console.\nNote: In Python 3.7+, you can use the built-in breakpoint() function instead of importing pdb:\ndef calculate_average(numbers): total = 0 for num in numbers: total += num breakpoint() # Equivalent to pdb.set_trace() average = total / len(numbers) return average 2. Running a Script with pdb You can run an entire script under the debugger from the command line:\npython -m pdb my_script.py This starts the debugger at the beginning of the script. The program will pause before the first line executes.\n3. Post-Mortem Debugging You can also start the debugger after an exception has occurred:\nimport pdb try: # Some code that might raise an exception result = 10 / 0 except: pdb.post_mortem() # Start the debugger at the point of the exception ","using-python-debugger-in-different-environments#Using Python Debugger in Different Environments":"Debugging in Interactive Mode (REPL) You can use the debugger in the Python interactive shell:\n\u003e\u003e\u003e import pdb \u003e\u003e\u003e def buggy_function(): ... x = 1 ... y = 0 ... pdb.set_trace() ... return x / y ... \u003e\u003e\u003e buggy_function() \u003e \u003cstdin\u003e(5)buggy_function() -\u003e return x / y (Pdb) Debugging in Jupyter Notebooks For Jupyter notebooks, you can use %debug magic command after an exception occurs:\n# Run this cell first def divide(a, b): return a / b # Then run this cell result = divide(10, 0) # This will raise a ZeroDivisionError # Now run this cell to debug %debug Or use %pdb on to automatically start the debugger on any exception:\n%pdb on result = divide(10, 0) # Will automatically drop into debugger IDE Debugging Support Most Python IDEs offer integrated debugging with graphical interfaces, including:\nPyCharm: Offers visual debugging with breakpoints, variable inspection, and a graphical call stack Visual Studio Code: Provides debugging through the Python extension Spyder: Includes debugging features similar to MATLAB’s debugger "},"title":"How to use Python debugger"},"/python-fundamentals/09-practice-projects/01-command-line-tool/":{"data":{"":"In this project, we’ll build a command-line tool that creates new files and directories. The tool will check if a file already exists before creating it, create any missing parent directories if needed, and handle errors appropriately by sending messages to STDERR.","conclusion#Conclusion":"We’ve built a robust command-line tool for file creation that:\nCreates files and directories as needed Handles existing files with options to overwrite, append, or skip Supports adding content from command-line arguments or interactive input Provides clear error messages with appropriate exit codes Includes comprehensive testing Offers different verbosity levels for user feedback This project demonstrates many important Python concepts:\nCommand-line argument parsing File and directory operations Error handling and custom exceptions User interaction Testing and validation The tool serves as a practical example of how Python can be used to create useful utilities that interact with the file system in a safe and user-friendly way.","exercises#Exercises":"Exercise 1: Add a --recursive option that creates recursively missing directories from the file path. For example, filecreate.py --recursive dir/dir_1/file.txt would create file in the missing dir_1 directory\nExercise 2: Implement a feature that allows specifying content from a file using a syntax like --content-file=input.txt.\nExercise 3: Add support for file templates with variable substitution. For example, a template might contain placeholders like {{name}} that get replaced with values provided by the user.\nHint for Exercise 1: You’ll need to use the glob module to find directories that are missing.","extending-the-tool#Extending the Tool":"Here are some ways you could extend this tool for more advanced use cases:\n1. Template Support Add support for file templates:\n# Example implementation def load_template(template_name): \"\"\"Load a template from a templates directory.\"\"\" template_dir = os.path.join(os.path.dirname(__file__), \"templates\") template_path = os.path.join(template_dir, template_name) if not os.path.exists(template_path): raise FileCreationError(f\"Template '{template_name}' not found\") with open(template_path, 'r') as f: return f.read() # Add a command-line option elif opt in (\"-t\", \"--template\"): try: content = load_template(arg) except FileCreationError as e: sys.stderr.write(f\"Error: {e}\\n\") return 1 2. File Permissions Add support for setting file permissions:\n# Add a command-line option elif opt in (\"--chmod\"): try: chmod_mode = int(arg, 8) # Parse octal number except ValueError: sys.stderr.write(f\"Error: Invalid chmod mode '{arg}'\\n\") return 1 # Add to the create_file function if 'chmod_mode' in locals(): try: os.chmod(filepath, chmod_mode) if verbose \u003e 1: print(f\"Changed permissions of '{filepath}' to {oct(chmod_mode)[2:]}\") except OSError as e: raise FileCreationError(f\"Cannot change permissions of '{filepath}': {e}\") 3. Batch Processing from a File List Add support for reading file paths from a list file:\n# Add a command-line option elif opt in (\"--file-list\"): try: with open(arg, 'r') as f: file_list = [line.strip() for line in f if line.strip()] args.extend(file_list) except IOError as e: sys.stderr.write(f\"Error reading file list '{arg}': {e}\\n\") return 1 4. Backup Existing Files Add support for backing up existing files before overwriting them:\n# Add a command-line option elif opt in (\"--backup\"): backup = True # Add to the create_file function if os.path.exists(filepath) and 'backup' in locals() and backup: backup_path = filepath + \".bak\" try: shutil.copy2(filepath, backup_path) if verbose \u003e 0: print(f\"Created backup: {backup_path}\") except IOError as e: raise FileCreationError(f\"Cannot create backup of '{filepath}': {e}\") ","how-to-use-the-file-creation-tool#How to Use the File Creation Tool":"Here are some examples of how to use our file creation tool:\n1. Basic Usage: Create a Single File python filecreate.py myfile.txt This creates myfile.txt in the current directory if it doesn’t already exist.\n2. Create Multiple Files python filecreate.py file1.txt file2.txt file3.txt This creates three files: file1.txt, file2.txt, and file3.txt.\n3. Create a File with Content python filecreate.py --content=\"Hello, World!\" greeting.txt This creates greeting.txt with the content “Hello, World!”.\n4. Create a File in a New Directory python filecreate.py new_directory/myfile.txt This creates the directory new_directory if it doesn’t exist and then creates myfile.txt inside it.\n5. Overwrite an Existing File python filecreate.py --force --content=\"New content\" existing_file.txt This overwrites existing_file.txt with “New content” even if the file already exists.\n6. Append to an Existing File python filecreate.py --append --content=\"Additional content\" existing_file.txt This adds “Additional content” to the end of existing_file.txt if it exists.\n7. Interactive Mode: Enter Content Manually python filecreate.py --interactive myfile.txt This prompts you to enter content for myfile.txt. Press Ctrl+D (Unix/Linux) or Ctrl+Z followed by Enter (Windows) when you’re done entering content.\n8. Increase Verbosity for More Details python filecreate.py --verbose new_directory/myfile.txt This shows more details about the file creation process.\n9. Quiet Mode: Minimal Output python filecreate.py --quiet myfile.txt This creates myfile.txt with minimal output, showing only errors if they occur.","project-overview#Project Overview":"Our file creation tool will:\nAccept file paths as command-line arguments Create parent directories if they don’t exist Create the specified file if it doesn’t exist Output error messages to STDERR if the file already exists Provide options for handling existing files (overwrite, append, etc.) Include helpful usage information This project demonstrates several important Python concepts:\nCommand-line argument parsing File and directory operations Error handling Standard output and error streams Creating a reusable command-line tool Step 1: Setting Up the Basic Structure First, let’s create a basic script that can accept command-line arguments:\n#!/usr/bin/env python3 \"\"\" File Creation Tool - A utility to create files and directories. Usage: filecreate.py \u003cfilepath\u003e [\u003cfilepath\u003e ...] filecreate.py -h | --help \"\"\" import sys import os def main(): \"\"\"Main function to process command-line arguments and create files.\"\"\" # Skip the script name (first argument) args = sys.argv[1:] if not args or \"-h\" in args or \"--help\" in args: print(__doc__) return 0 # Process each file path for filepath in args: create_file(filepath) return 0 def create_file(filepath): \"\"\"Create a file at the specified path.\"\"\" print(f\"Creating file: {filepath}\") # Actual file creation will be implemented here if __name__ == \"__main__\": sys.exit(main()) This code sets up a basic command-line interface that accepts file paths as arguments and provides help information when requested.\nStep 2: Implementing File Creation Logic Now, let’s implement the file creation logic, including directory creation if needed:\ndef create_file(filepath): \"\"\" Create a file at the specified path. Args: filepath (str): Path to the file to create Returns: bool: True if successful, False otherwise \"\"\" try: # Check if the file already exists if os.path.exists(filepath): sys.stderr.write(f\"Error: File '{filepath}' already exists.\\n\") return False # Get the directory part of the path directory = os.path.dirname(filepath) # Create the directory if it doesn't exist if directory and not os.path.exists(directory): print(f\"Creating directory: {directory}\") os.makedirs(directory) # Create the file (by opening it in write mode and then closing it) with open(filepath, 'w') as f: pass print(f\"Successfully created file: {filepath}\") return True except OSError as e: sys.stderr.write(f\"Error creating file '{filepath}': {e}\\n\") return False This function:\nChecks if the file already exists and outputs an error message to STDERR if it does Gets the directory part of the path Creates any missing directories using os.makedirs() Creates the file by opening it in write mode and immediately closing it Handles any OS errors that might occur during the process Step 3: Adding Options for Handling Existing Files Let’s enhance our tool to handle existing files according to user preferences:\n#!/usr/bin/env python3 \"\"\" File Creation Tool - A utility to create files and directories. Usage: filecreate.py [options] \u003cfilepath\u003e [\u003cfilepath\u003e ...] filecreate.py -h | --help Options: -f, --force Overwrite existing files -a, --append Append to existing files -s, --skip Skip existing files (default) -h, --help Show this help message \"\"\" import sys import os import getopt def main(): \"\"\"Main function to process command-line arguments and create files.\"\"\" # Default options force = False append = False try: # Parse command-line options opts, args = getopt.getopt(sys.argv[1:], \"hfas\", [\"help\", \"force\", \"append\", \"skip\"]) except getopt.GetoptError as e: sys.stderr.write(f\"Error: {e}\\n\") print(__doc__) return 1 # Process options for opt, _ in opts: if opt in (\"-h\", \"--help\"): print(__doc__) return 0 elif opt in (\"-f\", \"--force\"): force = True append = False elif opt in (\"-a\", \"--append\"): append = True force = False # Check if there are file paths provided if not args: sys.stderr.write(\"Error: No file paths provided.\\n\") print(__doc__) return 1 # Process each file path success_count = 0 for filepath in args: if create_file(filepath, force=force, append=append): success_count += 1 # Report results total = len(args) print(f\"\\nSummary: {success_count} of {total} files processed successfully.\") return 0 if success_count == total else 1 def create_file(filepath, force=False, append=False): \"\"\" Create a file at the specified path. Args: filepath (str): Path to the file to create force (bool): Whether to overwrite an existing file append (bool): Whether to append to an existing file Returns: bool: True if successful, False otherwise \"\"\" try: # Check if the file already exists if os.path.exists(filepath): if force: mode = 'w' print(f\"Overwriting file: {filepath}\") elif append: mode = 'a' print(f\"Appending to file: {filepath}\") else: sys.stderr.write(f\"Error: File '{filepath}' already exists. Use -f to overwrite or -a to append.\\n\") return False else: mode = 'w' # Get the directory part of the path directory = os.path.dirname(filepath) # Create the directory if it doesn't exist if directory and not os.path.exists(directory): print(f\"Creating directory: {directory}\") os.makedirs(directory) # Create or modify the file with open(filepath, mode) as f: pass if not os.path.exists(filepath): print(f\"Successfully created file: {filepath}\") else: if force: print(f\"Successfully overwrote file: {filepath}\") elif append: print(f\"Successfully appended to file: {filepath}\") return True except OSError as e: sys.stderr.write(f\"Error processing file '{filepath}': {e}\\n\") return False if __name__ == \"__main__\": sys.exit(main()) We’ve added:\nCommand-line options using getopt Options for different behaviors when a file already exists: -f/--force: Overwrite existing files -a/--append: Append to existing files -s/--skip: Skip existing files (default) A summary of the results after processing all files Step 4: Adding Content to Created Files Let’s enhance our tool to allow users to specify content for the files:\n#!/usr/bin/env python3 \"\"\" File Creation Tool - A utility to create files and directories. Usage: filecreate.py [options] \u003cfilepath\u003e [\u003cfilepath\u003e ...] filecreate.py -h | --help Options: -f, --force Overwrite existing files -a, --append Append to existing files -s, --skip Skip existing files (default) -c, --content=TEXT Add specified text to the file -i, --interactive Prompt for content interactively -h, --help Show this help message \"\"\" import sys import os import getopt def main(): \"\"\"Main function to process command-line arguments and create files.\"\"\" # Default options force = False append = False content = None interactive = False try: # Parse command-line options opts, args = getopt.getopt( sys.argv[1:], \"hfasc:i\", [\"help\", \"force\", \"append\", \"skip\", \"content=\", \"interactive\"] ) except getopt.GetoptError as e: sys.stderr.write(f\"Error: {e}\\n\") print(__doc__) return 1 # Process options for opt, arg in opts: if opt in (\"-h\", \"--help\"): print(__doc__) return 0 elif opt in (\"-f\", \"--force\"): force = True append = False elif opt in (\"-a\", \"--append\"): append = True force = False elif opt in (\"-c\", \"--content\"): content = arg elif opt in (\"-i\", \"--interactive\"): interactive = True # Check if there are file paths provided if not args: sys.stderr.write(\"Error: No file paths provided.\\n\") print(__doc__) return 1 # If interactive mode is enabled, prompt for content if interactive and content is None: print(\"Enter content (press Ctrl+D on Unix/Linux or Ctrl+Z on Windows when finished):\") content_lines = [] try: while True: line = input() content_lines.append(line) except EOFError: # End of input content = \"\\n\".join(content_lines) print(\"\\nContent captured.\") # Process each file path success_count = 0 for filepath in args: if create_file(filepath, force=force, append=append, content=content): success_count += 1 # Report results total = len(args) print(f\"\\nSummary: {success_count} of {total} files processed successfully.\") return 0 if success_count == total else 1 def create_file(filepath, force=False, append=False, content=None): \"\"\" Create a file at the specified path. Args: filepath (str): Path to the file to create force (bool): Whether to overwrite an existing file append (bool): Whether to append to an existing file content (str): Optional content to write to the file Returns: bool: True if successful, False otherwise \"\"\" try: # Check if the file already exists if os.path.exists(filepath): if force: mode = 'w' print(f\"Overwriting file: {filepath}\") elif append: mode = 'a' print(f\"Appending to file: {filepath}\") else: sys.stderr.write(f\"Error: File '{filepath}' already exists. Use -f to overwrite or -a to append.\\n\") return False else: mode = 'w' # Get the directory part of the path directory = os.path.dirname(filepath) # Create the directory if it doesn't exist if directory and not os.path.exists(directory): print(f\"Creating directory: {directory}\") os.makedirs(directory) # Create or modify the file with open(filepath, mode) as f: if content is not None: f.write(content) if not content.endswith('\\n'): f.write('\\n') if not os.path.exists(filepath): print(f\"Successfully created file: {filepath}\") else: if force: print(f\"Successfully overwrote file: {filepath}\") elif append: print(f\"Successfully appended to file: {filepath}\") return True except OSError as e: sys.stderr.write(f\"Error processing file '{filepath}': {e}\\n\") return False if __name__ == \"__main__\": sys.exit(main()) We’ve added:\nThe -c/--content option to specify content directly The -i/--interactive option to enter content interactively Logic to write the specified content to the file Step 5: Implementing Advanced Error Handling Let’s enhance our error handling to be more robust and informative:\nimport os import sys import getopt import errno class FileCreationError(Exception): \"\"\"Custom exception for file creation errors.\"\"\" pass def create_file(filepath, force=False, append=False, content=None): \"\"\" Create a file at the specified path. Args: filepath (str): Path to the file to create force (bool): Whether to overwrite an existing file append (bool): Whether to append to an existing file content (str): Optional content to write to the file Returns: bool: True if successful, False otherwise Raises: FileCreationError: If the file cannot be created for any reason \"\"\" try: # Check if the file already exists if os.path.exists(filepath): if os.path.isdir(filepath): raise FileCreationError(f\"Path '{filepath}' is a directory, not a file\") if force: mode = 'w' action = \"Overwriting\" elif append: mode = 'a' action = \"Appending to\" else: raise FileCreationError(f\"File '{filepath}' already exists. Use -f to overwrite or -a to append.\") else: mode = 'w' action = \"Creating\" # Get the directory part of the path directory = os.path.dirname(filepath) # Create the directory if it doesn't exist if directory and not os.path.exists(directory): try: print(f\"Creating directory: {directory}\") os.makedirs(directory) except OSError as e: if e.errno == errno.EACCES: raise FileCreationError(f\"Permission denied to create directory '{directory}'\") else: raise FileCreationError(f\"Cannot create directory '{directory}': {e}\") try: # Create or modify the file with open(filepath, mode) as f: if content is not None: f.write(content) if not content.endswith('\\n'): f.write('\\n') except IOError as e: if e.errno == errno.EACCES: raise FileCreationError(f\"Permission denied to write to '{filepath}'\") else: raise FileCreationError(f\"Cannot write to '{filepath}': {e}\") print(f\"{action} file: {filepath}\") return True except FileCreationError as e: sys.stderr.write(f\"Error: {e}\\n\") return False except Exception as e: sys.stderr.write(f\"Unexpected error processing '{filepath}': {e}\\n\") return False We’ve improved the error handling by:\nCreating a custom exception class for file creation errors Checking if the path is a directory before trying to create a file Providing more specific error messages for common issues like permission denied Using the errno module to check for specific error types Step 6: Completing the Tool with Verbosity Levels Let’s add verbosity levels to make the tool more user-friendly:\n#!/usr/bin/env python3 \"\"\" File Creation Tool - A utility to create files and directories. Usage: filecreate.py [options] \u003cfilepath\u003e [\u003cfilepath\u003e ...] filecreate.py -h | --help Options: -f, --force Overwrite existing files -a, --append Append to existing files -s, --skip Skip existing files (default) -c, --content=TEXT Add specified text to the file -i, --interactive Prompt for content interactively -v, --verbose Increase output verbosity -q, --quiet Suppress output except for errors -h, --help Show this help message \"\"\" import os import sys import getopt import errno class FileCreationError(Exception): \"\"\"Custom exception for file creation errors.\"\"\" pass def main(): \"\"\"Main function to process command-line arguments and create files.\"\"\" # Default options force = False append = False content = None interactive = False verbose = 1 # Default verbosity level (0=quiet, 1=normal, 2=verbose) try: # Parse command-line options opts, args = getopt.getopt( sys.argv[1:], \"hfasc:ivq\", [\"help\", \"force\", \"append\", \"skip\", \"content=\", \"interactive\", \"verbose\", \"quiet\"] ) except getopt.GetoptError as e: sys.stderr.write(f\"Error: {e}\\n\") print(__doc__) return 1 # Process options for opt, arg in opts: if opt in (\"-h\", \"--help\"): print(__doc__) return 0 elif opt in (\"-f\", \"--force\"): force = True append = False elif opt in (\"-a\", \"--append\"): append = True force = False elif opt in (\"-c\", \"--content\"): content = arg elif opt in (\"-i\", \"--interactive\"): interactive = True elif opt in (\"-v\", \"--verbose\"): verbose = 2 elif opt in (\"-q\", \"--quiet\"): verbose = 0 # Check if there are file paths provided if not args: sys.stderr.write(\"Error: No file paths provided.\\n\") print(__doc__) return 1 # If interactive mode is enabled, prompt for content if interactive and content is None: print(\"Enter content (press Ctrl+D on Unix/Linux or Ctrl+Z on Windows when finished):\") content_lines = [] try: while True: line = input() content_lines.append(line) except EOFError: # End of input content = \"\\n\".join(content_lines) if verbose \u003e 0: print(\"\\nContent captured.\") # Process each file path success_count = 0 for filepath in args: if create_file(filepath, force=force, append=append, content=content, verbose=verbose): success_count += 1 # Report results total = len(args) if verbose \u003e 0: print(f\"\\nSummary: {success_count} of {total} files processed successfully.\") return 0 if success_count == total else 1 def create_file(filepath, force=False, append=False, content=None, verbose=1): \"\"\" Create a file at the specified path. Args: filepath (str): Path to the file to create force (bool): Whether to overwrite an existing file append (bool): Whether to append to an existing file content (str): Optional content to write to the file verbose (int): Verbosity level (0=quiet, 1=normal, 2=verbose) Returns: bool: True if successful, False otherwise \"\"\" try: # Normalize and expand the file path filepath = os.path.abspath(os.path.expanduser(filepath)) if verbose \u003e 1: print(f\"Processing file: {filepath}\") # Check if the file already exists if os.path.exists(filepath): if os.path.isdir(filepath): raise FileCreationError(f\"Path '{filepath}' is a directory, not a file\") if force: mode = 'w' action = \"Overwriting\" elif append: mode = 'a' action = \"Appending to\" else: raise FileCreationError(f\"File '{filepath}' already exists. Use -f to overwrite or -a to append.\") else: mode = 'w' action = \"Creating\" # Get the directory part of the path directory = os.path.dirname(filepath) # Create the directory if it doesn't exist if directory and not os.path.exists(directory): try: if verbose \u003e 0: print(f\"Creating directory: {directory}\") os.makedirs(directory) except OSError as e: if e.errno == errno.EACCES: raise FileCreationError(f\"Permission denied to create directory '{directory}'\") else: raise FileCreationError(f\"Cannot create directory '{directory}': {e}\") try: # Create or modify the file with open(filepath, mode) as f: if content is not None: if verbose \u003e 1: content_preview = content[:50] + \"...\" if len(content) \u003e 50 else content print(f\"Writing content: {content_preview}\") f.write(content) if not content.endswith('\\n'): f.write('\\n') except IOError as e: if e.errno == errno.EACCES: raise FileCreationError(f\"Permission denied to write to '{filepath}'\") else: raise FileCreationError(f\"Cannot write to '{filepath}': {e}\") if verbose \u003e 0: print(f\"{action} file: {filepath}\") return True except FileCreationError as e: sys.stderr.write(f\"Error: {e}\\n\") return False except Exception as e: sys.stderr.write(f\"Unexpected error processing '{filepath}': {e}\\n\") if verbose \u003e 1: import traceback traceback.print_exc(file=sys.stderr) return False if __name__ == \"__main__\": sys.exit(main()) Now our tool has:\nVerbosity levels with -v/--verbose and -q/--quiet options Path normalization and expansion using os.path.abspath and os.path.expanduser Detailed error messages in verbose mode, including stack traces for unexpected errors Step 7: Testing the Tool Let’s create a comprehensive test function to verify our tool’s functionality:\ndef test_file_creation(): \"\"\"Test the file creation functionality.\"\"\" import tempfile import shutil # Create a temporary directory for testing test_dir = tempfile.mkdtemp() print(f\"Created test directory: {test_dir}\") try: # Test case 1: Create a simple file test_file1 = os.path.join(test_dir, \"test1.txt\") print(\"\\nTest 1: Creating a new file\") result = create_file(test_file1, content=\"Test content\", verbose=2) assert result is True assert os.path.exists(test_file1) # Test case 2: Attempt to create the same file (should fail) print(\"\\nTest 2: Creating a file that already exists (should fail)\") result = create_file(test_file1, content=\"Different content\", verbose=2) assert result is False # Test case 3: Force overwrite an existing file print(\"\\nTest 3: Force overwriting an existing file\") result = create_file(test_file1, force=True, content=\"Overwritten content\", verbose=2) assert result is True with open(test_file1, 'r') as f: content = f.read().strip() assert content == \"Overwritten content\" # Test case 4: Append to an existing file print(\"\\nTest 4: Appending to an existing file\") result = create_file(test_file1, append=True, content=\"Additional content\", verbose=2) assert result is True with open(test_file1, 'r') as f: content = f.read().strip() assert content == \"Overwritten content\\nAdditional content\" # Test case 5: Create a file in a non-existent directory print(\"\\nTest 5: Creating a file in a new directory\") nested_dir = os.path.join(test_dir, \"nested\", \"path\") test_file2 = os.path.join(nested_dir, \"test2.txt\") result = create_file(test_file2, content=\"Nested file content\", verbose=2) assert result is True assert os.path.exists(test_file2) # Test case 6: Try to create a file that's actually a directory print(\"\\nTest 6: Trying to create a file with the same name as a directory (should fail)\") result = create_file(nested_dir, content=\"This should fail\", verbose=2) assert result is False print(\"\\nAll tests passed!\") return True except AssertionError as e: print(f\"Test failed: {e}\") return False finally: # Clean up the temporary directory print(f\"\\nCleaning up test directory: {test_dir}\") shutil.rmtree(test_dir) # Add this at the end of the main() function to run tests if \"--test\" in sys.argv: test_file_creation() return 0 This test function:\nCreates a temporary directory for testing Tests various scenarios like creating, overwriting, and appending to files Verifies that directories are created when needed Checks error conditions like trying to create a file with the same name as a directory Cleans up after itself by removing the temporary directory Final Complete Code Here’s the complete code for our file creation tool:\n#!/usr/bin/env python3 \"\"\" File Creation Tool - A utility to create files and directories. Usage: filecreate.py [options] \u003cfilepath\u003e [\u003cfilepath\u003e ...] filecreate.py --test filecreate.py -h | --help Options: -f, --force Overwrite existing files -a, --append Append to existing files -s, --skip Skip existing files (default) -c, --content=TEXT Add specified text to the file -i, --interactive Prompt for content interactively -v, --verbose Increase output verbosity -q, --quiet Suppress output except for errors --test Run self-test -h, --help Show this help message \"\"\" import os import sys import getopt import errno import tempfile import shutil class FileCreationError(Exception): \"\"\"Custom exception for file creation errors.\"\"\" pass def main(): \"\"\"Main function to process command-line arguments and create files.\"\"\" # Default options force = False append = False content = None interactive = False verbose = 1 # Default verbosity level (0=quiet, 1=normal, 2=verbose) # Run self-test if requested if \"--test\" in sys.argv: return 0 if test_file_creation() else 1 try: # Parse command-line options opts, args = getopt.getopt( sys.argv[1:], \"hfasc:ivq\", [\"help\", \"force\", \"append\", \"skip\", \"content=\", \"interactive\", \"verbose\", \"quiet\", \"test\"] ) except getopt.GetoptError as e: sys.stderr.write(f\"Error: {e}\\n\") print(__doc__) return 1 # Process options for opt, arg in opts: if opt in (\"-h\", \"--help\"): print(__doc__) return 0 elif opt in (\"-f\", \"--force\"): force = True append = False elif opt in (\"-a\", \"--append\"): append = True force = False elif opt in (\"-c\", \"--content\"): content = arg elif opt in (\"-i\", \"--interactive\"): interactive = True elif opt in (\"-v\", \"--verbose\"): verbose = 2 elif opt in (\"-q\", \"--quiet\"): verbose = 0 # Check if there are file paths provided if not args: sys.stderr.write(\"Error: No file paths provided.\\n\") print(__doc__) return 1 # If interactive mode is enabled, prompt for content if interactive and content is None: print(\"Enter content (press Ctrl+D on Unix/Linux or Ctrl+Z on Windows when finished):\") content_lines = [] try: while True: line = input() content_lines.append(line) except EOFError: # End of input content = \"\\n\".join(content_lines) if verbose \u003e 0: print(\"\\nContent captured.\") # Process each file path success_count = 0 for filepath in args: if create_file(filepath, force=force, append=append, content=content, verbose=verbose): success_count += 1 # Report results total = len(args) if verbose \u003e 0: print(f\"\\nSummary: {success_count} of {total} files processed successfully.\") return 0 if success_count == total else 1 def create_file(filepath, force=False, append=False, content=None, verbose=1): \"\"\" Create a file at the specified path. Args: filepath (str): Path to the file to create force (bool): Whether to overwrite an existing file append (bool): Whether to append to an existing file content (str): Optional content to write to the file verbose (int): Verbosity level (0=quiet, 1=normal, 2=verbose) Returns: bool: True if successful, False otherwise \"\"\" try: # Normalize and expand the file path filepath = os.path.abspath(os.path.expanduser(filepath)) if verbose \u003e 1: print(f\"Processing file: {filepath}\") # Check if the file already exists if os.path.exists(filepath): if os.path.isdir(filepath): raise FileCreationError(f\"Path '{filepath}' is a directory, not a file\") if force: mode = 'w' action = \"Overwriting\" elif append: mode = 'a' action = \"Appending to\" else: raise FileCreationError(f\"File '{filepath}' already exists. Use -f to overwrite or -a to append.\") else: mode = 'w' action = \"Creating\" # Get the directory part of the path directory = os.path.dirname(filepath) # Create the directory if it doesn't exist if directory and not os.path.exists(directory): try: if verbose \u003e 0: print(f\"Creating directory: {directory}\") os.makedirs(directory) except OSError as e: if e.errno == errno.EACCES: raise FileCreationError(f\"Permission denied to create directory '{directory}'\") else: raise FileCreationError(f\"Cannot create directory '{directory}': {e}\") try: # Create or modify the file with open(filepath, mode) as f: if content is not None: if verbose \u003e 1: content_preview = content[:50] + \"...\" if len(content) \u003e 50 else content print(f\"Writing content: {content_preview}\") f.write(content) if not content.endswith('\\n'): f.write('\\n') except IOError as e: if e.errno == errno.EACCES: raise FileCreationError(f\"Permission denied to write to '{filepath}'\") else: raise FileCreationError(f\"Cannot write to '{filepath}': {e}\") if verbose \u003e 0: print(f\"{action} file: {filepath}\") return True except FileCreationError as e: sys.stderr.write(f\"Error: {e}\\n\") return False except Exception as e: sys.stderr.write(f\"Unexpected error processing '{filepath}': {e}\\n\") if verbose \u003e 1: import traceback traceback.print_exc(file=sys.stderr) return False def test_file_creation(): \"\"\"Test the file creation functionality.\"\"\" # Create a temporary directory for testing test_dir = tempfile.mkdtemp() print(f\"Created test directory: {test_dir}\") try: # Test case 1: Create a simple file test_file1 = os.path.join(test_dir, \"test1.txt\") print(\"\\nTest 1: Creating a new file\") result = create_file(test_file1, content=\"Test content\", verbose=2) assert result is True assert os.path.exists(test_file1) # Test case 2: Attempt to create the same file (should fail) print(\"\\nTest 2: Creating a file that already exists (should fail)\") result = create_file(test_file1, content=\"Different content\", verbose=2) assert result is False # Test case 3: Force overwrite an existing file print(\"\\nTest 3: Force overwriting an existing file\") result = create_file(test_file1, force=True, content=\"Overwritten content\", verbose=2) assert result is True with open(test_file1, 'r') as f: content = f.read().strip() assert content == \"Overwritten content\" # Test case 4: Append to an existing file print(\"\\nTest 4: Appending to an existing file\") result = create_file(test_file1, append=True, content=\"Additional content\", verbose=2) assert result is True with open(test_file1, 'r') as f: content = f.read().strip() assert content == \"Overwritten content\\nAdditional content\" # Test case 5: Create a file in a non-existent directory print(\"\\nTest 5: Creating a file in a new directory\") nested_dir = os.path.join(test_dir, \"nested\", \"path\") test_file2 = os.path.join(nested_dir, \"test2.txt\") result = create_file(test_file2, content=\"Nested file content\", verbose=2) assert result is True assert os.path.exists(test_file2) # Test case 6: Try to create a file that's actually a directory print(\"\\nTest 6: Trying to create a file with the same name as a directory (should fail)\") result = create_file(nested_dir, content=\"This should fail\", verbose=2) assert result is False print(\"\\nAll tests passed!\") return True except AssertionError as e: print(f\"Test failed: {e}\") return False finally: # Clean up the temporary directory print(f\"\\nCleaning up test directory: {test_dir}\") shutil.rmtree(test_dir) if __name__ == \"__main__\": sys.exit(main()) ","run-self-tests#Run Self-Tests":" python filecreate.py --test This runs the self-tests to verify that the tool is working correctly.","understanding-the-implementation#Understanding the Implementation":"Let’s break down the key components of our file creation tool:\n1. Command-Line Argument Parsing We use the getopt module to parse command-line arguments. This allows users to specify options and file paths when running the tool.\nopts, args = getopt.getopt( sys.argv[1:], \"hfasc:ivq\", [\"help\", \"force\", \"append\", \"skip\", \"content=\", \"interactive\", \"verbose\", \"quiet\", \"test\"] ) The short options (like -f) and long options (like --force) provide flexibility for users.\n2. File Creation Logic The core functionality is in the create_file() function, which:\nNormalizes and expands file paths Checks if the file already exists Creates directories if needed Handles different modes (create, overwrite, append) Writes content to the file The function returns True if successful and False otherwise, which allows the calling code to track successes and failures.\n3. Error Handling We use a custom exception class FileCreationError to represent specific file creation errors. This allows us to distinguish between expected errors (like a file already existing) and unexpected errors.\nclass FileCreationError(Exception): \"\"\"Custom exception for file creation errors.\"\"\" pass We catch and handle errors at multiple levels:\nPermission errors when creating directories or writing files Path validation errors (like trying to create a file with the same name as a directory) Unexpected errors with traceback information in verbose mode 4. Verbosity Levels We implement three verbosity levels to control the amount of output:\nQuiet (0): Only show errors Normal (1): Show important actions and summaries Verbose (2): Show detailed information and previews of content This allows users to choose the level of detail that suits their needs.\n5. Testing The test_file_creation() function verifies that the tool behaves as expected in various scenarios. It uses a temporary directory for testing and cleans up afterward, ensuring that tests don’t leave files on the user’s system."},"title":"Command-line Interface Tool: File Creation tool"},"/python-fundamentals/09-practice-projects/02-data-analysis-script/":{"data":{"":"Data analysis is one of Python’s most powerful applications. In this section, we’ll create a comprehensive data analysis script that demonstrates how to load, clean, analyze, and visualize data using Python libraries. This practical project will consolidate many of the concepts we’ve learned throughout the tutorial.","1-loading-the-data#1. Loading the Data":"First, let’s load the data from our CSV file:\ndef load_data(file_path): \"\"\" Load data from a CSV file into a pandas DataFrame. Args: file_path (str): Path to the CSV file Returns: pd.DataFrame: The loaded data \"\"\" try: # Read the CSV file df = pd.read_csv(file_path) # Print basic information print(f\"Data loaded successfully from {file_path}\") print(f\"Shape: {df.shape} (rows, columns)\") print(\"\\nFirst 5 rows:\") print(df.head()) return df except FileNotFoundError: print(f\"Error: File '{file_path}' not found.\") return None except Exception as e: print(f\"Error loading data: {e}\") return None ","2-data-cleaning-and-preprocessing#2. Data Cleaning and Preprocessing":"Now, let’s clean and preprocess the data:\ndef clean_data(df): \"\"\" Clean and preprocess the data. Args: df (pd.DataFrame): The raw data Returns: pd.DataFrame: The cleaned data \"\"\" if df is None: return None # Make a copy to avoid modifying the original df_clean = df.copy() print(\"\\n===== Data Cleaning =====\") # Check for missing values missing_values = df_clean.isnull().sum() print(\"\\nMissing values per column:\") print(missing_values) # Handle missing values # For numeric columns, fill with median numeric_cols = df_clean.select_dtypes(include=['number']).columns for col in numeric_cols: if df_clean[col].isnull().sum() \u003e 0: median_value = df_clean[col].median() df_clean[col].fillna(median_value, inplace=True) print(f\"Filled missing values in '{col}' with median: {median_value}\") # For categorical columns, fill with mode categorical_cols = df_clean.select_dtypes(include=['object']).columns for col in categorical_cols: if df_clean[col].isnull().sum() \u003e 0: mode_value = df_clean[col].mode()[0] df_clean[col].fillna(mode_value, inplace=True) print(f\"Filled missing values in '{col}' with mode: {mode_value}\") # Convert Date column to datetime if 'Date' in df_clean.columns: df_clean['Date'] = pd.to_datetime(df_clean['Date']) print(\"Converted 'Date' column to datetime\") # Create derived columns if 'Date' in df_clean.columns: df_clean['Month'] = df_clean['Date'].dt.month df_clean['Day'] = df_clean['Date'].dt.day df_clean['DayOfWeek'] = df_clean['Date'].dt.dayofweek # 0=Monday, 6=Sunday print(\"Created date-related columns: Month, Day, DayOfWeek\") # Calculate total sales if 'Price' in df_clean.columns and 'Quantity' in df_clean.columns: df_clean['Total_Sales'] = df_clean['Price'] * df_clean['Quantity'] print(\"Created 'Total_Sales' column\") # Check for duplicates duplicates = df_clean.duplicated().sum() print(f\"\\nDuplicate rows: {duplicates}\") if duplicates \u003e 0: df_clean = df_clean.drop_duplicates() print(f\"Removed {duplicates} duplicate rows\") print(f\"\\nShape after cleaning: {df_clean.shape} (rows, columns)\") return df_clean ","3-exploratory-data-analysis#3. Exploratory Data Analysis":"Now that our data is cleaned, let’s explore it:\ndef exploratory_analysis(df): \"\"\" Perform exploratory data analysis on the dataset. Args: df (pd.DataFrame): The cleaned data Returns: dict: A dictionary containing analysis results \"\"\" if df is None: return None print(\"\\n===== Exploratory Data Analysis =====\") results = {} # Basic statistics print(\"\\nBasic Statistics:\") numeric_stats = df.describe() print(numeric_stats) results['numeric_stats'] = numeric_stats # Category distribution if 'Category' in df.columns: category_counts = df['Category'].value_counts() print(\"\\nProduct Category Distribution:\") print(category_counts) results['category_counts'] = category_counts # Region distribution if 'Region' in df.columns: region_counts = df['Region'].value_counts() print(\"\\nRegional Distribution:\") print(region_counts) results['region_counts'] = region_counts # Sales analysis if 'Total_Sales' in df.columns: print(\"\\nSales Summary:\") sales_stats = df['Total_Sales'].describe() print(sales_stats) results['sales_stats'] = sales_stats # Top 5 products by sales if 'Product_ID' in df.columns: top_products = df.groupby('Product_ID')['Total_Sales'].sum().sort_values(ascending=False).head(5) print(\"\\nTop 5 Products by Sales:\") print(top_products) results['top_products'] = top_products # Top 5 customers by sales if 'Customer_ID' in df.columns: top_customers = df.groupby('Customer_ID')['Total_Sales'].sum().sort_values(ascending=False).head(5) print(\"\\nTop 5 Customers by Sales:\") print(top_customers) results['top_customers'] = top_customers # Sales by category if 'Category' in df.columns: category_sales = df.groupby('Category')['Total_Sales'].sum().sort_values(ascending=False) print(\"\\nSales by Category:\") print(category_sales) results['category_sales'] = category_sales # Sales by region if 'Region' in df.columns: region_sales = df.groupby('Region')['Total_Sales'].sum().sort_values(ascending=False) print(\"\\nSales by Region:\") print(region_sales) results['region_sales'] = region_sales # Time-based analysis if 'Date' in df.columns and 'Total_Sales' in df.columns: # Monthly sales monthly_sales = df.groupby(df['Date'].dt.strftime('%Y-%m'))['Total_Sales'].sum() print(\"\\nMonthly Sales:\") print(monthly_sales) results['monthly_sales'] = monthly_sales # Day of week analysis if 'DayOfWeek' in df.columns: day_mapping = { 0: 'Monday', 1: 'Tuesday', 2: 'Wednesday', 3: 'Thursday', 4: 'Friday', 5: 'Saturday', 6: 'Sunday' } df_copy = df.copy() df_copy['DayName'] = df_copy['DayOfWeek'].map(day_mapping) day_sales = df_copy.groupby('DayName')['Total_Sales'].sum() # Reorder to start with Monday day_sales = day_sales.reindex(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']) print(\"\\nSales by Day of Week:\") print(day_sales) results['day_sales'] = day_sales return results ","4-data-visualization#4. Data Visualization":"Now, let’s create visualizations to better understand our data:\ndef create_visualizations(df, results, output_dir='visualizations'): \"\"\" Create visualizations from the data and analysis results. Args: df (pd.DataFrame): The cleaned data results (dict): Results from exploratory analysis output_dir (str): Directory to save visualizations \"\"\" if df is None or results is None: return print(\"\\n===== Creating Visualizations =====\") # Create output directory if it doesn't exist if not os.path.exists(output_dir): os.makedirs(output_dir) print(f\"Created directory: {output_dir}\") # Set figure size for all plots plt.figure(figsize=(12, 6)) # 1. Category Sales Bar Chart if 'category_sales' in results: plt.figure(figsize=(12, 6)) ax = results['category_sales'].plot(kind='bar', color='skyblue') plt.title('Total Sales by Product Category', fontsize=16) plt.xlabel('Category', fontsize=14) plt.ylabel('Total Sales ($)', fontsize=14) plt.xticks(rotation=45) plt.grid(axis='y', linestyle='--', alpha=0.7) # Add value labels on top of each bar for i, v in enumerate(results['category_sales']): ax.text(i, v + 0.1, f'${v:,.2f}', ha='center', fontsize=10) plt.tight_layout() plt.savefig(f'{output_dir}/category_sales.png') plt.close() print(f\"Saved: {output_dir}/category_sales.png\") # 2. Regional Sales Pie Chart if 'region_sales' in results: plt.figure(figsize=(10, 8)) explode = [0.1 if i == 0 else 0 for i in range(len(results['region_sales']))] # Explode the largest slice plt.pie(results['region_sales'], labels=results['region_sales'].index, autopct='%1.1f%%', startangle=90, shadow=True, explode=explode, colors=sns.color_palette('pastel')) plt.title('Sales Distribution by Region', fontsize=16) plt.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle plt.tight_layout() plt.savefig(f'{output_dir}/region_sales_pie.png') plt.close() print(f\"Saved: {output_dir}/region_sales_pie.png\") # 3. Monthly Sales Trend if 'monthly_sales' in results: plt.figure(figsize=(14, 6)) ax = results['monthly_sales'].plot(kind='line', marker='o', color='darkblue', linewidth=2) plt.title('Monthly Sales Trend', fontsize=16) plt.xlabel('Month', fontsize=14) plt.ylabel('Total Sales ($)', fontsize=14) plt.grid(True, linestyle='--', alpha=0.7) plt.xticks(rotation=45) # Add value labels above each point for i, v in enumerate(results['monthly_sales']): ax.text(i, v + 0.1, f'${v:,.2f}', ha='center', fontsize=9, rotation=45) plt.tight_layout() plt.savefig(f'{output_dir}/monthly_sales_trend.png') plt.close() print(f\"Saved: {output_dir}/monthly_sales_trend.png\") # 4. Day of Week Sales if 'day_sales' in results: plt.figure(figsize=(12, 6)) ax = results['day_sales'].plot(kind='bar', color='lightgreen') plt.title('Sales by Day of Week', fontsize=16) plt.xlabel('Day', fontsize=14) plt.ylabel('Total Sales ($)', fontsize=14) plt.grid(axis='y', linestyle='--', alpha=0.7) # Add value labels on top of each bar for i, v in enumerate(results['day_sales']): ax.text(i, v + 0.1, f'${v:,.2f}', ha='center', fontsize=10) plt.tight_layout() plt.savefig(f'{output_dir}/day_of_week_sales.png') plt.close() print(f\"Saved: {output_dir}/day_of_week_sales.png\") # 5. Sales Distribution Histogram if 'Total_Sales' in df.columns: plt.figure(figsize=(12, 6)) sns.histplot(df['Total_Sales'], bins=30, kde=True, color='purple') plt.title('Distribution of Sales Amounts', fontsize=16) plt.xlabel('Sale Amount ($)', fontsize=14) plt.ylabel('Frequency', fontsize=14) plt.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() plt.savefig(f'{output_dir}/sales_distribution.png') plt.close() print(f\"Saved: {output_dir}/sales_distribution.png\") # 6. Scatter plot of Price vs. Quantity if 'Price' in df.columns and 'Quantity' in df.columns: plt.figure(figsize=(10, 8)) if 'Category' in df.columns: # Scatter plot colored by category sns.scatterplot(data=df, x='Price', y='Quantity', hue='Category', size='Total_Sales', sizes=(20, 200), alpha=0.7) plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left') else: sns.scatterplot(data=df, x='Price', y='Quantity', size='Total_Sales', sizes=(20, 200), alpha=0.7) plt.title('Price vs. Quantity Relationship', fontsize=16) plt.xlabel('Price ($)', fontsize=14) plt.ylabel('Quantity', fontsize=14) plt.grid(True, linestyle='--', alpha=0.7) plt.tight_layout() plt.savefig(f'{output_dir}/price_quantity_scatter.png') plt.close() print(f\"Saved: {output_dir}/price_quantity_scatter.png\") # 7. Heatmap of correlations numeric_df = df.select_dtypes(include=['number']) if len(numeric_df.columns) \u003e 1: # Need at least 2 numeric columns for correlation plt.figure(figsize=(10, 8)) corr = numeric_df.corr() mask = np.triu(np.ones_like(corr, dtype=bool)) # Mask for the upper triangle sns.heatmap(corr, mask=mask, annot=True, cmap='coolwarm', vmin=-1, vmax=1, fmt=\".2f\", linewidths=0.5, cbar_kws={\"shrink\": .8}) plt.title('Correlation Between Numeric Variables', fontsize=16) plt.tight_layout() plt.savefig(f'{output_dir}/correlation_heatmap.png') plt.close() print(f\"Saved: {output_dir}/correlation_heatmap.png\") print(f\"\\nAll visualizations have been saved to the '{output_dir}' directory\") ","5-generate-report#5. Generate Report":"Let’s create a function to generate a simple text report with our findings:\ndef generate_report(df, results, output_file='sales_analysis_report.txt'): \"\"\" Generate a text report of the analysis findings. Args: df (pd.DataFrame): The cleaned data results (dict): Results from exploratory analysis output_file (str): File to save the report \"\"\" if df is None or results is None: return print(\"\\n===== Generating Report =====\") with open(output_file, 'w') as f: # Header f.write(\"=\" * 80 + \"\\n\") f.write(\" \" * 30 + \"SALES DATA ANALYSIS REPORT\\n\") f.write(\" \" * 30 + datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") + \"\\n\") f.write(\"=\" * 80 + \"\\n\\n\") # Dataset Overview f.write(\"DATASET OVERVIEW\\n\") f.write(\"-\" * 80 + \"\\n\") f.write(f\"Total Records: {df.shape[0]}\\n\") f.write(f\"Time Period: {df['Date'].min().strftime('%Y-%m-%d')} to {df['Date'].max().strftime('%Y-%m-%d')}\\n\") # Key Metrics if 'sales_stats' in results: f.write(\"\\nKEY SALES METRICS\\n\") f.write(\"-\" * 80 + \"\\n\") f.write(f\"Total Sales: ${df['Total_Sales'].sum():,.2f}\\n\") f.write(f\"Average Sale: ${results['sales_stats']['mean']:,.2f}\\n\") f.write(f\"Median Sale: ${results['sales_stats']['50%']:,.2f}\\n\") f.write(f\"Highest Sale: ${results['sales_stats']['max']:,.2f}\\n\") f.write(f\"Lowest Sale: ${results['sales_stats']['min']:,.2f}\\n\") # Category Analysis if 'category_sales' in results: f.write(\"\\nCATEGORY ANALYSIS\\n\") f.write(\"-\" * 80 + \"\\n\") for category, sales in results['category_sales'].items(): f.write(f\"{category}: ${sales:,.2f} ({sales/df['Total_Sales'].sum()*100:.1f}%)\\n\") # Best performing category best_category = results['category_sales'].idxmax() f.write(f\"\\nBest Performing Category: {best_category} (${results['category_sales'].max():,.2f})\\n\") # Regional Analysis if 'region_sales' in results: f.write(\"\\nREGIONAL ANALYSIS\\n\") f.write(\"-\" * 80 + \"\\n\") for region, sales in results['region_sales'].items(): f.write(f\"{region}: ${sales:,.2f} ({sales/df['Total_Sales'].sum()*100:.1f}%)\\n\") # Best performing region best_region = results['region_sales'].idxmax() f.write(f\"\\nBest Performing Region: {best_region} (${results['region_sales'].max():,.2f})\\n\") # Temporal Analysis if 'monthly_sales' in results: f.write(\"\\nMONTHLY SALES ANALYSIS\\n\") f.write(\"-\" * 80 + \"\\n\") for month, sales in results['monthly_sales'].items(): f.write(f\"{month}: ${sales:,.2f}\\n\") # Best and worst months best_month = results['monthly_sales'].idxmax() worst_month = results['monthly_sales'].idxmin() f.write(f\"\\nBest Month: {best_month} (${results['monthly_sales'].max():,.2f})\\n\") f.write(f\"Worst Month: {worst_month} (${results['monthly_sales'].min():,.2f})\\n\") # Day of Week Analysis if 'day_sales' in results: f.write(\"\\nDAY OF WEEK ANALYSIS\\n\") f.write(\"-\" * 80 + \"\\n\") for day, sales in results['day_sales'].items(): f.write(f\"{day}: ${sales:,.2f}\\n\") # Best and worst days best_day = results['day_sales'].idxmax() worst_day = results['day_sales'].idxmin() f.write(f\"\\nBest Day: {best_day} (${results['day_sales'].max():,.2f})\\n\") f.write(f\"Worst Day: {worst_day} (${results['day_sales'].min():,.2f})\\n\") # Top Performers f.write(\"\\nTOP PERFORMERS\\n\") f.write(\"-\" * 80 + \"\\n\") if 'top_products' in results: f.write(\"Top 5 Products:\\n\") for product, sales in results['top_products'].items(): f.write(f\" {product}: ${sales:,.2f}\\n\") if 'top_customers' in results: f.write(\"\\nTop 5 Customers:\\n\") for customer, sales in results['top_customers'].items(): f.write(f\" {customer}: ${sales:,.2f}\\n\") # Recommendations (placeholder - in a real report, you'd customize these) f.write(\"\\nRECOMMENDATIONS\\n\") f.write(\"-\" * 80 + \"\\n\") f.write(\"1. Focus marketing efforts on the best-performing category and region\\n\") f.write(\"2. Investigate why certain days of the week perform better than others\\n\") f.write(\"3. Create special promotions for the lowest-performing months\\n\") f.write(\"4. Implement a loyalty program targeting the top customers\\n\") f.write(\"5. Consider product bundling for complementary items\\n\") # Footer f.write(\"\\n\" + \"=\" * 80 + \"\\n\") f.write(\"END OF REPORT\\n\") print(f\"Report saved to {output_file}\") ","6-main-function#6. Main Function":"Now, let’s put everything together in a main function:\ndef main(): \"\"\"Main function to run the complete data analysis pipeline.\"\"\" print(\"===== SALES DATA ANALYSIS =====\\n\") # Create sample data if needed create_sample_data() # Load the data file_path = 'sales_data.csv' df = load_data(file_path) if df is not None: # Clean and preprocess the data df_clean = clean_data(df) if df_clean is not None: # Perform exploratory analysis results = exploratory_analysis(df_clean) if results is not None: # Create visualizations create_visualizations(df_clean, results) # Generate report generate_report(df_clean, results) print(\"\\nAnalysis completed successfully!\") else: print(\"Analysis could not be completed due to data loading issues.\") if __name__ == \"__main__\": main() ","exercises#Exercises":"Exercise 1: Modify the script to analyze sales by day of the month. Does the beginning, middle, or end of the month perform better?\nExercise 2: Add a function to identify anomalies in the sales data (e.g., unusually high or low sales days).\nExercise 3: Extend the visualization function to create a heatmap showing sales by category and region.\nExercise 4: Create a function to perform a basic forecast of next month’s sales based on historical data.\nHint for Exercise 1: Group the data by the ‘Day’ column you created during preprocessing, then calculate the sum of sales for each day of the month. Visualize the results with a line chart.\n# Exercise 1 outline def analyze_day_of_month(df): if 'Day' in df.columns and 'Total_Sales' in df.columns: day_sales = df.groupby('Day')['Total_Sales'].sum().reset_index() plt.figure(figsize=(12, 6)) plt.plot(day_sales['Day'], day_sales['Total_Sales'], marker='o') plt.title('Sales by Day of Month') plt.xlabel('Day of Month') plt.ylabel('Total Sales ($)') plt.grid(True) plt.tight_layout() plt.savefig('visualizations/day_of_month_sales.png') plt.close() In the next section, we’ll explore another practical Python project to further enhance your skills.","extending-the-project#Extending the Project":"You can extend this project in several ways:\nAdvanced Analysis:\nImplement time series forecasting to predict future sales Perform customer segmentation using clustering algorithms Identify correlations and potential causative factors for sales patterns Interactive Dashboard:\nConvert the script to a Jupyter Notebook for interactive analysis Create a web-based dashboard using Dash or Streamlit Add interactive filters to explore different subsets of the data Automation:\nSchedule the script to run automatically at regular intervals Send the report as an email attachment to stakeholders Set up alerts for unusual patterns or significant changes in sales ","key-concepts-demonstrated#Key Concepts Demonstrated":"This data analysis script demonstrates several important concepts:\nData Loading: Using pandas to read CSV files Data Cleaning: Handling missing values, converting data types, and creating derived columns Exploratory Analysis: Calculating statistics and aggregations using pandas Data Visualization: Creating charts and graphs with matplotlib and seaborn Report Generation: Formatting and writing analysis findings to a file Error Handling: Using try-except blocks to handle potential issues Code Organization: Structuring the code into functions with clear responsibilities ","project-overview#Project Overview":"We will build a data analysis script that:\nLoads data from a CSV file Cleans and preprocesses the data Performs exploratory data analysis Creates visualizations to communicate insights Saves the results to files ","required-libraries#Required Libraries":"For this project, we’ll use several popular Python libraries for data analysis:\n# Core libraries import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns from datetime import datetime import os # Configure visualizations plt.style.use('seaborn-v0_8-whitegrid') sns.set(font_scale=1.2) To install these libraries, you can use pip:\npip install pandas numpy matplotlib seaborn ","running-the-script#Running the Script":"To run this data analysis script, save all the functions in a Python file (e.g., sales_analysis.py) and execute it:\npython sales_analysis.py ","sample-dataset#Sample Dataset":"For this tutorial, we’ll use a sample sales dataset. You can create this sample data file or use your own CSV file:\ndef create_sample_data(): \"\"\"Create a sample sales dataset if one doesn't exist.\"\"\" if not os.path.exists('sales_data.csv'): # Create some sample data np.random.seed(42) # For reproducibility # Date range dates = pd.date_range(start='2022-01-01', end='2022-12-31', freq='D') # Product categories categories = ['Electronics', 'Clothing', 'Home \u0026 Kitchen', 'Books', 'Toys'] # Create a DataFrame n_records = 1000 data = { 'Date': np.random.choice(dates, n_records), 'Product_ID': ['P' + str(i).zfill(4) for i in np.random.randint(1, 101, n_records)], 'Category': np.random.choice(categories, n_records), 'Price': np.round(np.random.uniform(10, 1000, n_records), 2), 'Quantity': np.random.randint(1, 10, n_records), 'Customer_ID': ['C' + str(i).zfill(4) for i in np.random.randint(1, 201, n_records)], 'Region': np.random.choice(['North', 'South', 'East', 'West', 'Central'], n_records) } # Add some missing values for col in ['Price', 'Quantity', 'Region']: mask = np.random.random(n_records) \u003c 0.05 # 5% missing values data[col] = np.where(mask, np.nan, data[col]) # Create DataFrame and save to CSV df = pd.DataFrame(data) df.to_csv('sales_data.csv', index=False) print(\"Sample data created and saved to 'sales_data.csv'\") else: print(\"Using existing 'sales_data.csv' file\") ","understanding-the-results#Understanding the Results":"After running the script, you’ll have:\nA cleaned dataset Detailed exploratory analysis in the console output Data visualizations saved in the ‘visualizations’ directory A comprehensive report in ‘sales_analysis_report.txt’ "},"title":"Data analysis script"},"/python-fundamentals/09-practice-projects/03-web-scraping-basics/":{"data":{"":"Web scraping is the process of extracting data from websites automatically. It allows you to collect specific information from web pages and use it for analysis, research, or other purposes. Python is one of the most popular languages for web scraping due to its simplicity and the availability of powerful libraries.","basic-web-scraping-with-requests-and-beautiful-soup#Basic Web Scraping with Requests and Beautiful Soup":"First, let’s import the necessary libraries:\nimport requests from bs4 import BeautifulSoup import pandas as pd import time import random Now, let’s see a basic example of scraping a webpage:\ndef basic_scrape(url): \"\"\" Basic function to scrape a webpage and print its title and links. Args: url (str): The URL of the webpage to scrape \"\"\" # Send a GET request to the URL response = requests.get(url, headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }) # Check if the request was successful if response.status_code == 200: # Parse the HTML content soup = BeautifulSoup(response.text, 'html.parser') # Extract and print the title title = soup.title.text print(f\"Title: {title}\") # Extract and print all links links = soup.find_all('a') print(f\"\\nFound {len(links)} links:\") for i, link in enumerate(links[:5], 1): # Print only first 5 links href = link.get('href', 'No link') text = link.text.strip() or 'No text' print(f\"{i}. {text}: {href}\") if len(links) \u003e 5: print(\"...\") else: print(f\"Failed to retrieve the webpage. Status code: {response.status_code}\") # Example usage url = \"https://www.example.com\" basic_scrape(url) This basic example fetches a webpage, parses its HTML, and extracts the title and links. Let’s break down what each part does:\nThe requests.get() function sends an HTTP GET request to the specified URL. We include a user agent header to identify our scraper. We check if the request was successful by examining the status code (200 means success). We use Beautiful Soup to parse the HTML content. We extract and print the page title and the first few links. Note: Always include a user agent in your requests to identify your scraper. Some websites block requests without a user agent or with the default Python user agent.","best-practices-for-web-scraping#Best Practices for Web Scraping":" Respect robots.txt:\nimport requests from urllib.robotparser import RobotFileParser def is_scraping_allowed(url, user_agent=\"*\"): \"\"\"Check if scraping is allowed for the given URL and user agent.\"\"\" parsed_url = requests.utils.urlparse(url) robots_url = f\"{parsed_url.scheme}://{parsed_url.netloc}/robots.txt\" parser = RobotFileParser() parser.set_url(robots_url) parser.read() return parser.can_fetch(user_agent, url) # Example usage url = \"https://www.example.com/products\" if is_scraping_allowed(url): print(\"Scraping is allowed!\") else: print(\"Scraping is not allowed by robots.txt\") Add delays between requests:\nimport time import random # Add a random delay between 1 and 3 seconds delay = random.uniform(1, 3) time.sleep(delay) Use proper headers:\nheaders = { 'User-Agent': 'YourScrapingProject/1.0 (your@email.com)', 'Accept': 'text/html,application/xhtml+xml,application/xml', 'Accept-Language': 'en-US,en;q=0.9' } response = requests.get(url, headers=headers) Handle errors gracefully:\ntry: response = requests.get(url, timeout=10) response.raise_for_status() # Raise an exception for 4XX/5XX status codes except requests.exceptions.HTTPError as e: print(f\"HTTP Error: {e}\") except requests.exceptions.ConnectionError as e: print(f\"Connection Error: {e}\") except requests.exceptions.Timeout as e: print(f\"Timeout Error: {e}\") except requests.exceptions.RequestException as e: print(f\"Error: {e}\") Use proxies if needed:\nproxies = { 'http': 'http://proxy.example.com:8080', 'https': 'https://proxy.example.com:8080' } response = requests.get(url, proxies=proxies) Store scraped data properly:\nimport json # Save as JSON with open('data.json', 'w', encoding='utf-8') as f: json.dump(data, f, ensure_ascii=False, indent=4) # Save as CSV df = pd.DataFrame(data) df.to_csv('data.csv', index=False, encoding='utf-8') # Save as Excel df.to_excel('data.xlsx', index=False) ","complete-example-news-article-scraper#Complete Example: News Article Scraper":"Let’s put everything together in a complete example that scrapes news articles from a fictional news website:\nimport requests from bs4 import BeautifulSoup import pandas as pd import time import random import os from datetime import datetime from urllib.robotparser import RobotFileParser class NewsArticleScraper: def __init__(self, base_url): \"\"\" Initialize the news article scraper. Args: base_url (str): The base URL of the news website \"\"\" self.base_url = base_url self.headers = { 'User-Agent': 'NewsArticleScraper/1.0 (educational-project)', 'Accept': 'text/html,application/xhtml+xml,application/xml', 'Accept-Language': 'en-US,en;q=0.9' } # Check if scraping is allowed if not self._is_scraping_allowed(): print(f\"WARNING: Scraping may not be allowed for {base_url} according to robots.txt\") def _is_scraping_allowed(self): \"\"\"Check if scraping is allowed according to robots.txt.\"\"\" try: robots_url = f\"{self.base_url}/robots.txt\" parser = RobotFileParser() parser.set_url(robots_url) parser.read() return parser.can_fetch(self.headers['User-Agent'], self.base_url) except Exception as e: print(f\"Error checking robots.txt: {e}\") return False def _get_page(self, url): \"\"\"Send a GET request to the URL and return the BeautifulSoup object.\"\"\" try: response = requests.get(url, headers=self.headers, timeout=10) response.raise_for_status() return BeautifulSoup(response.text, 'html.parser') except requests.exceptions.RequestException as e: print(f\"Error retrieving {url}: {e}\") return None def scrape_article_page(self, article_url): \"\"\" Scrape data from a single article page. Args: article_url (str): The URL of the article Returns: dict: Article data or None if scraping failed \"\"\" soup = self._get_page(article_url) if not soup: return None try: # Extract article content (adjust selectors based on the actual website) title = soup.find('h1', class_='article-title').get_text().strip() date_elem = soup.find('span', class_='article-date') date = date_elem.get_text().strip() if date_elem else \"N/A\" author_elem = soup.find('span', class_='article-author') author = author_elem.get_text().strip() if author_elem else \"N/A\" content_elem = soup.find('div', class_='article-content') content = content_elem.get_text().strip() if content_elem else \"N/A\" # Extract categories categories = [] category_elems = soup.find_all('a', class_='article-category') for cat in category_elems: categories.append(cat.get_text().strip()) return { 'title': title, 'date': date, 'author': author, 'content': content, 'categories': ', '.join(categories), 'url': article_url } except Exception as e: print(f\"Error extracting article data from {article_url}: {e}\") return None def scrape_category_page(self, category, max_pages=2): \"\"\" Scrape articles from a category page. Args: category (str): The category to scrape max_pages (int): Maximum number of pages to scrape Returns: list: List of article URLs \"\"\" article_urls = [] for page in range(1, max_pages + 1): if page == 1: url = f\"{self.base_url}/category/{category}\" else: url = f\"{self.base_url}/category/{category}/page/{page}\" print(f\"Scraping category page: {url}\") soup = self._get_page(url) if not soup: break # Find article links (adjust selectors based on the actual website) article_elements = soup.find_all('div', class_='article-preview') if not article_elements: print(f\"No article previews found on page {page}. Stopping pagination.\") break for article in article_elements: link = article.find('a', class_='article-link') if link and link.get('href'): article_url = link.get('href') # Handle relative URLs if not article_url.startswith('http'): article_url = self.base_url + article_url article_urls.append(article_url) print(f\"Found {len(article_elements)} articles on page {page}\") # Check if there's a next page link next_page = soup.find('a', class_='next-page') if not next_page: print(\"No next page link found. Stopping pagination.\") break # Be respectful: add a delay between requests delay = random.uniform(2, 4) print(f\"Waiting {delay:.2f} seconds before next request...\") time.sleep(delay) return article_urls def scrape_articles(self, categories, max_pages_per_category=2, max_articles=20): \"\"\" Scrape articles from multiple categories. Args: categories (list): List of categories to scrape max_pages_per_category (int): Maximum number of pages to scrape per category max_articles (int): Maximum number of articles to scrape in total Returns: pandas.DataFrame: DataFrame containing article data \"\"\" all_articles = [] total_articles = 0 for category in categories: print(f\"\\nScraping category: {category}\") # Get article URLs for this category article_urls = self.scrape_category_page(category, max_pages_per_category) # Limit the number of articles to scrape remaining_articles = max_articles - total_articles if remaining_articles \u003c= 0: break article_urls = article_urls[:remaining_articles] # Scrape each article for article_url in article_urls: print(f\"Scraping article: {article_url}\") article_data = self.scrape_article_page(article_url) if article_data: article_data['category'] = category all_articles.append(article_data) total_articles += 1 # Be respectful: add a delay between requests delay = random.uniform(2, 4) print(f\"Waiting {delay:.2f} seconds before next request...\") time.sleep(delay) if total_articles \u003e= max_articles: print(f\"Reached maximum number of articles ({max_articles}). Stopping.\") break # Convert to DataFrame if all_articles: df = pd.DataFrame(all_articles) return df else: print(\"No articles were scraped.\") return pd.DataFrame() def save_to_csv(self, dataframe, filename=None): \"\"\" Save the scraped articles to a CSV file. Args: dataframe (pandas.DataFrame): The DataFrame to save filename (str, optional): The filename to use. If None, generates a filename with the current date. \"\"\" if dataframe.empty: print(\"No data to save.\") return if filename is None: current_date = datetime.now().strftime(\"%Y%m%d\") filename = f\"news_articles_{current_date}.csv\" dataframe.to_csv(filename, index=False, encoding='utf-8') print(f\"Saved {len(dataframe)} articles to {filename}\") def save_to_json(self, dataframe, filename=None): \"\"\" Save the scraped articles to a JSON file. Args: dataframe (pandas.DataFrame): The DataFrame to save filename (str, optional): The filename to use. If None, generates a filename with the current date. \"\"\" if dataframe.empty: print(\"No data to save.\") return if filename is None: current_date = datetime.now().strftime(\"%Y%m%d\") filename = f\"news_articles_{current_date}.json\" # Convert DataFrame to a list of dictionaries articles_list = dataframe.to_dict(orient='records') with open(filename, 'w', encoding='utf-8') as f: import json json.dump(articles_list, f, ensure_ascii=False, indent=4) print(f\"Saved {len(dataframe)} articles to {filename}\") def main(): # Base URL of the fictional news website base_url = \"https://www.fictional-news-site.com\" # Categories to scrape categories = [\"technology\", \"business\", \"science\"] # Create the scraper scraper = NewsArticleScraper(base_url) # Scrape articles articles_df = scraper.scrape_articles( categories=categories, max_pages_per_category=2, max_articles=15 ) # Display a summary if not articles_df.empty: print(\"\\nSummary of scraped articles:\") print(f\"Total articles: {len(articles_df)}\") print(\"\\nArticles per category:\") print(articles_df['category'].value_counts()) print(\"\\nFirst few articles:\") # Display a preview (title and author only) preview_df = articles_df[['title', 'author', 'date', 'category']] print(preview_df.head()) # Save the results scraper.save_to_csv(articles_df) scraper.save_to_json(articles_df) print(\"\\nWeb scraping completed.\") if __name__ == \"__main__\": main() ","conclusion#Conclusion":"Web scraping is a powerful skill that allows you to collect data from various websites. In this tutorial, we’ve covered:\nBasic web scraping with Requests and Beautiful Soup Handling different types of content (tables, images, pagination) Dealing with dynamic content using Selenium Best practices for ethical and responsible scraping A complete project for scraping news articles Extensions for analyzing and visualizing the scraped data While web scraping opens up many possibilities, remember to:\nOnly scrape publicly available data Respect websites’ terms of service and robots.txt Implement rate limiting to avoid overwhelming servers Use the data ethically and responsibly With these skills and principles in mind, you’re now ready to scrape data from websites and use it for your Python projects!","ethical-considerations-and-challenges#Ethical Considerations and Challenges":"When scraping websites, you might encounter various challenges:\n1. CAPTCHA and Anti-Scraping Mechanisms Many websites employ mechanisms to prevent scraping:\nCAPTCHA: These are tests designed to determine if the user is human. IP Blocking: Websites may block IPs that send too many requests. User-Agent Checking: Some sites block requests with bot-like user agents. Strategies to handle these challenges:\n# Rotate user agents user_agents = [ 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0' ] headers = { 'User-Agent': random.choice(user_agents) } # Use proxy rotation proxies = [ {'http': 'http://proxy1.example.com:8080', 'https': 'https://proxy1.example.com:8080'}, {'http': 'http://proxy2.example.com:8080', 'https': 'https://proxy2.example.com:8080'} ] proxy = random.choice(proxies) response = requests.get(url, headers=headers, proxies=proxy) 2. Terms of Service Violations Always review a website’s Terms of Service before scraping:\nSome explicitly forbid scraping Others have specific requirements for automated access Some limit the rate or volume of requests 3. Legal Issues Web scraping exists in a legal gray area:\nThe Computer Fraud and Abuse Act (CFAA) in the US has been used in cases against scrapers The EU’s GDPR may apply if you’re collecting personal data Copyright laws may restrict how you can use the scraped content Important: This tutorial is for educational purposes only. Always ensure your web scraping activities comply with relevant laws, regulations, and website terms of service.","exercises#Exercises":"Exercise 1: Create a simple web scraper that extracts the title, URL, and post date of the 10 most recent posts from a blog of your choice. Save the data to a CSV file.\nExercise 2: Build a web scraper that extracts product information (name, price, rating) from an e-commerce website’s search results page. Implement pagination to get results from multiple pages.\nExercise 3: Develop a weather data scraper that collects the forecast for the next 5 days for a specific city from a weather website. Use the data to create a simple visualization.\nHint for Exercise 1: First inspect the HTML structure of the blog to find the appropriate CSS selectors for post titles, URLs, and dates. Use Beautiful Soup’s find_all() method to locate all post elements, then extract the required information from each. Remember to handle relative URLs properly.\n# Exercise 1 solution outline import requests from bs4 import BeautifulSoup import pandas as pd # URL of the blog blog_url = \"https://example-blog.com\" # Send request and get the page response = requests.get(blog_url) soup = BeautifulSoup(response.text, 'html.parser') # Find all post elements (adjust selector based on the actual blog) posts = soup.find_all('article', class_='post')[:10] # Get first 10 posts # Extract data from each post data = [] for post in posts: # Extract title, URL and date (adjust selectors) title = post.find('h2').get_text().strip() url = post.find('a', class_='post-link')['href'] date = post.find('span', class_='post-date').get_text().strip() # Handle relative URLs if not url.startswith('http'): url = blog_url + url data.append({ 'title': title, 'url': url, 'date': date }) # Save to CSV df = pd.DataFrame(data) df.to_csv('blog_posts.csv', index=False) print(\"Data saved to blog_posts.csv\") ","extending-the-web-scraper#Extending the Web Scraper":"The basic web scraper we’ve built is already powerful, but there are many ways to extend it:\n1. Adding Advanced Analytics You can analyze the scraped data to extract insights:\ndef analyze_articles(df): \"\"\" Perform basic analysis on the scraped articles. Args: df (pandas.DataFrame): DataFrame containing article data \"\"\" if df.empty: print(\"No data to analyze.\") return # Count articles by category category_counts = df['category'].value_counts() print(\"\\nArticles by Category:\") print(category_counts) # Count articles by author author_counts = df['author'].value_counts().head(10) print(\"\\nTop 10 Authors:\") print(author_counts) # Analyze publish dates if 'date' in df.columns: try: # Convert to datetime if possible df['date_parsed'] = pd.to_datetime(df['date']) # Count articles by month month_counts = df['date_parsed'].dt.to_period('M').value_counts().sort_index() print(\"\\nArticles by Month:\") print(month_counts) except Exception as e: print(f\"Error parsing dates: {e}\") # Analyze content length if 'content' in df.columns: df['content_length'] = df['content'].str.len() avg_length = df['content_length'].mean() print(f\"\\nAverage Article Length: {avg_length:.0f} characters\") # Longest and shortest articles print(\"\\nLongest Article:\") longest_idx = df['content_length'].idxmax() print(f\"Title: {df.loc[longest_idx, 'title']}\") print(f\"Length: {df.loc[longest_idx, 'content_length']} characters\") print(\"\\nShortest Article:\") shortest_idx = df['content_length'].idxmin() print(f\"Title: {df.loc[shortest_idx, 'title']}\") print(f\"Length: {df.loc[shortest_idx, 'content_length']} characters\") # Simple word frequency analysis if 'content' in df.columns: from collections import Counter import re # Combine all content all_text = ' '.join(df['content'].tolist()) # Remove punctuation and convert to lowercase all_text = re.sub(r'[^\\w\\s]', '', all_text.lower()) # Split into words words = all_text.split() # Count word frequency word_counts = Counter(words) # Remove common stop words (this is a very basic list) stop_words = {'the', 'a', 'an', 'in', 'to', 'for', 'of', 'and', 'is', 'are', 'on', 'that', 'with', 'this', 'it'} for word in stop_words: if word in word_counts: del word_counts[word] # Print top 20 words print(\"\\nTop 20 Words:\") for word, count in word_counts.most_common(20): print(f\"{word}: {count}\") 2. Creating Visualizations You can visualize the scraped data:\ndef visualize_data(df): \"\"\" Create visualizations of the scraped data. Args: df (pandas.DataFrame): DataFrame containing article data \"\"\" try: import matplotlib.pyplot as plt import seaborn as sns # Set the style sns.set(style=\"whitegrid\") if df.empty: print(\"No data to visualize.\") return # Create a directory for visualizations os.makedirs('visualizations', exist_ok=True) # 1. Articles by Category plt.figure(figsize=(10, 6)) category_counts = df['category'].value_counts() sns.barplot(x=category_counts.index, y=category_counts.values) plt.title('Number of Articles by Category') plt.xlabel('Category') plt.ylabel('Count') plt.xticks(rotation=45) plt.tight_layout() plt.savefig('visualizations/articles_by_category.png') plt.close() # 2. Articles by Author (top 10) plt.figure(figsize=(12, 6)) author_counts = df['author'].value_counts().head(10) sns.barplot(x=author_counts.values, y=author_counts.index) plt.title('Top 10 Authors by Number of Articles') plt.xlabel('Count') plt.ylabel('Author') plt.tight_layout() plt.savefig('visualizations/top_authors.png') plt.close() # 3. Content Length Distribution if 'content' in df.columns: df['content_length'] = df['content'].str.len() plt.figure(figsize=(10, 6)) sns.histplot(df['content_length'], bins=30, kde=True) plt.title('Distribution of Article Lengths') plt.xlabel('Length (characters)') plt.ylabel('Count') plt.tight_layout() plt.savefig('visualizations/content_length_distribution.png') plt.close() # 4. Content Length by Category plt.figure(figsize=(12, 6)) sns.boxplot(x='category', y='content_length', data=df) plt.title('Article Length by Category') plt.xlabel('Category') plt.ylabel('Length (characters)') plt.xticks(rotation=45) plt.tight_layout() plt.savefig('visualizations/content_length_by_category.png') plt.close() # 5. Articles Over Time (if date is available) if 'date' in df.columns: try: # Convert to datetime if possible df['date_parsed'] = pd.to_datetime(df['date']) # Group by month articles_by_month = df.groupby(df['date_parsed'].dt.to_period('M')).size() plt.figure(figsize=(12, 6)) articles_by_month.plot(kind='line', marker='o') plt.title('Number of Articles Published Over Time') plt.xlabel('Month') plt.ylabel('Count') plt.tight_layout() plt.savefig('visualizations/articles_over_time.png') plt.close() except Exception as e: print(f\"Error creating time-based visualization: {e}\") print(\"Visualizations saved to the 'visualizations' directory.\") except ImportError: print(\"Matplotlib and/or seaborn not installed. Install with:\") print(\"pip install matplotlib seaborn\") 3. Sentiment Analysis on Articles You can analyze the sentiment of article content:\ndef analyze_sentiment(df): \"\"\" Perform sentiment analysis on article content. Args: df (pandas.DataFrame): DataFrame containing article data Returns: pandas.DataFrame: The input DataFrame with sentiment columns added \"\"\" try: from textblob import TextBlob if df.empty or 'content' not in df.columns: print(\"No content to analyze.\") return df # Create a copy to avoid modifying the original result_df = df.copy() # Add sentiment columns result_df['polarity'] = 0.0 result_df['subjectivity'] = 0.0 result_df['sentiment'] = 'neutral' for idx, row in result_df.iterrows(): if pd.isna(row['content']) or row['content'] == \"N/A\": continue # Analyze sentiment with TextBlob blob = TextBlob(row['content']) polarity = blob.sentiment.polarity subjectivity = blob.sentiment.subjectivity # Store results result_df.at[idx, 'polarity'] = polarity result_df.at[idx, 'subjectivity'] = subjectivity # Categorize sentiment if polarity \u003e 0.1: result_df.at[idx, 'sentiment'] = 'positive' elif polarity \u003c -0.1: result_df.at[idx, 'sentiment'] = 'negative' else: result_df.at[idx, 'sentiment'] = 'neutral' # Print summary sentiment_counts = result_df['sentiment'].value_counts() print(\"\\nSentiment Analysis:\") print(sentiment_counts) print(\"\\nAverage Polarity:\", result_df['polarity'].mean()) print(\"Average Subjectivity:\", result_df['subjectivity'].mean()) # Sentiment by category print(\"\\nSentiment by Category:\") sentiment_by_category = pd.crosstab(result_df['category'], result_df['sentiment']) print(sentiment_by_category) return result_df except ImportError: print(\"TextBlob not installed. Install with:\") print(\"pip install textblob\") print(\"Then run: python -m textblob.download_corpora\") return df ","handling-different-types-of-content#Handling Different Types of Content":"Websites contain various types of content. Here’s how to handle some common scenarios:\n1. Extracting Tables Many websites present data in HTML tables. Beautiful Soup makes it easy to extract this information:\ndef extract_table(url, table_index=0): \"\"\" Extract a table from a webpage. Args: url (str): The URL of the webpage table_index (int): The index of the table to extract (if multiple tables exist) Returns: pandas.DataFrame: A DataFrame containing the table data \"\"\" response = requests.get(url, headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }) if response.status_code == 200: soup = BeautifulSoup(response.text, 'html.parser') # Find all tables in the document tables = soup.find_all('table') if not tables: print(\"No tables found on the page\") return None if table_index \u003e= len(tables): print(f\"Table index {table_index} is out of range. Only {len(tables)} tables found.\") return None # Select the desired table table = tables[table_index] # Extract headers headers = [] header_row = table.find('thead') if header_row: headers = [th.get_text().strip() for th in header_row.find_all('th')] # If no header row found, try the first row if not headers: first_row = table.find('tr') if first_row: headers = [th.get_text().strip() for th in first_row.find_all(['th', 'td'])] # Extract rows rows = [] for row in table.find_all('tr')[1:] if headers else table.find_all('tr'): cells = [td.get_text().strip() for td in row.find_all(['td', 'th'])] if cells: rows.append(cells) # Create DataFrame if headers and rows: # Ensure all rows have the same length as headers rows = [row for row in rows if len(row) == len(headers)] df = pd.DataFrame(rows, columns=headers) return df elif rows: df = pd.DataFrame(rows) return df else: print(\"No data found in the table\") return None else: print(f\"Failed to retrieve the webpage. Status code: {response.status_code}\") return None 2. Extracting Images You can also scrape image URLs:\ndef extract_images(url, limit=10): \"\"\" Extract image URLs from a webpage. Args: url (str): The URL of the webpage limit (int): Maximum number of images to extract Returns: list: A list of image URLs \"\"\" response = requests.get(url, headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }) image_urls = [] if response.status_code == 200: soup = BeautifulSoup(response.text, 'html.parser') # Find all img tags img_tags = soup.find_all('img') for img in img_tags[:limit]: # Try different attributes where image URL might be stored img_url = img.get('src') or img.get('data-src') or img.get('data-lazy-src') if img_url: # Handle relative URLs if img_url.startswith('/'): # Extract domain from the original URL from urllib.parse import urlparse parsed_url = urlparse(url) domain = f\"{parsed_url.scheme}://{parsed_url.netloc}\" img_url = domain + img_url image_urls.append(img_url) print(f\"Extracted {len(image_urls)} image URLs\") else: print(f\"Failed to retrieve the webpage. Status code: {response.status_code}\") return image_urls 3. Handling Pagination Many websites split their content across multiple pages. Here’s a simple approach to handle pagination:\ndef scrape_with_pagination(base_url, max_pages=5): \"\"\" Scrape content across multiple pages. Args: base_url (str): The base URL of the website max_pages (int): Maximum number of pages to scrape Returns: list: Combined data from all pages \"\"\" all_data = [] current_page = 1 while current_page \u003c= max_pages: # Construct the URL for the current page if current_page == 1: url = base_url else: url = f\"{base_url}/page/{current_page}\" print(f\"Scraping page {current_page}: {url}\") # Send a GET request response = requests.get(url, headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }) if response.status_code == 200: soup = BeautifulSoup(response.text, 'html.parser') # Find data elements (adjust selectors based on the actual website) data_elements = soup.find_all('div', class_='data-item') if not data_elements: print(f\"No data found on page {current_page}. Stopping pagination.\") break # Extract data from each element for element in data_elements: title = element.find('h2').get_text().strip() if element.find('h2') else \"N/A\" description = element.find('p').get_text().strip() if element.find('p') else \"N/A\" all_data.append({ 'title': title, 'description': description, 'page': current_page }) print(f\"Scraped {len(data_elements)} items from page {current_page}\") # Check if there's a next page link next_page = soup.find('a', class_='next-page') if not next_page: print(\"No next page link found. Stopping pagination.\") break # Be respectful: add a delay between requests delay = random.uniform(1, 3) print(f\"Waiting {delay:.2f} seconds before next request...\") time.sleep(delay) current_page += 1 else: print(f\"Failed to retrieve page {current_page}. Status code: {response.status_code}\") break return all_data ","handling-dynamic-content-with-selenium#Handling Dynamic Content with Selenium":"Some websites load content dynamically using JavaScript. Beautiful Soup and requests alone can’t handle this. For such websites, we need Selenium, a tool that automates browsers.\nFirst, install Selenium:\npip install selenium You’ll also need a WebDriver for your browser. For Chrome, download the ChromeDriver matching your Chrome version from ChromeDriver downloads.\nHere’s a simple example using Selenium:\nfrom selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.common.by import By from selenium.webdriver.chrome.options import Options from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC import pandas as pd import time def scrape_dynamic_content(url, driver_path): \"\"\" Scrape content from a dynamic website using Selenium. Args: url (str): The URL of the webpage driver_path (str): Path to the ChromeDriver executable Returns: list: Scraped data \"\"\" # Set up Chrome options chrome_options = Options() chrome_options.add_argument(\"--headless\") # Run in headless mode (no browser window) chrome_options.add_argument(\"--disable-gpu\") chrome_options.add_argument(\"--window-size=1920,1080\") # Set up the driver service = Service(driver_path) driver = webdriver.Chrome(service=service, options=chrome_options) results = [] try: # Navigate to the page driver.get(url) # Wait for the dynamic content to load wait = WebDriverWait(driver, 10) wait.until(EC.presence_of_element_located((By.CLASS_NAME, \"dynamic-item\"))) # Additional wait to ensure all content is loaded time.sleep(2) # Find all items items = driver.find_elements(By.CLASS_NAME, \"dynamic-item\") for item in items: # Extract data title = item.find_element(By.CLASS_NAME, \"title\").text description = item.find_element(By.CLASS_NAME, \"description\").text results.append({ \"title\": title, \"description\": description }) print(f\"Scraped {len(results)} items\") except Exception as e: print(f\"Error during scraping: {e}\") finally: # Always close the driver driver.quit() return results # Example usage url = \"https://www.example-dynamic-site.com\" driver_path = \"/path/to/chromedriver\" # Update with your actual path data = scrape_dynamic_content(url, driver_path) # Convert to DataFrame df = pd.DataFrame(data) print(df.head()) Important: Selenium interacts with a real browser, which makes it more powerful but also slower than requests. Use it only when necessary, typically when dealing with websites that load content dynamically with JavaScript.","introduction-to-web-scraping#Introduction to Web Scraping":"Web scraping involves several steps:\nSending a request to a website to retrieve the HTML content Parsing the HTML to extract the relevant information Processing and storing the extracted data Before starting any web scraping project, it’s important to understand some key concepts and ethical considerations.\nLegal and Ethical Considerations Web scraping operates in a legal gray area in many jurisdictions. Here are some important guidelines to follow:\nCheck the robots.txt file: Most websites have a robots.txt file (e.g., www.example.com/robots.txt) that specifies which parts of the site should not be accessed by automated tools.\nReview the website’s terms of service: Some websites explicitly prohibit scraping in their terms of service.\nBe respectful of the server: Don’t overload websites with too many requests in a short time period. Implement delays between requests.\nIdentify your scraper: Use custom user agents that identify your scraper and possibly include contact information.\nOnly collect publicly available data: Avoid scraping personal information or data behind login pages.\nImportant: Web scraping should be used responsibly. Improper scraping can lead to IP bans, legal issues, or damage to the website’s servers. Always use web scraping ethically and respect website owners’ rights.","practical-project-scraping-a-products-catalog#Practical Project: Scraping a Products Catalog":"Let’s create a more comprehensive example: scraping product information from an e-commerce website. For this example, we’ll use a fictional structure, but the principles apply to real websites:\nimport requests from bs4 import BeautifulSoup import pandas as pd import time import random def scrape_products(base_url, num_pages=1): \"\"\" Scrape product information from multiple pages of a fictional e-commerce website. Args: base_url (str): The base URL of the website num_pages (int): Number of pages to scrape Returns: pandas.DataFrame: A DataFrame containing the scraped product information \"\"\" all_products = [] for page in range(1, num_pages + 1): # Construct the URL for the current page url = f\"{base_url}/products?page={page}\" print(f\"Scraping page {page}...\") # Send a GET request to the URL response = requests.get(url, headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }) if response.status_code == 200: # Parse the HTML content soup = BeautifulSoup(response.text, 'html.parser') # Find all product containers product_containers = soup.find_all('div', class_='product-item') for container in product_containers: try: # Extract product name name = container.find('h2', class_='product-name').get_text().strip() # Extract product price price_elem = container.find('span', class_='price') price = price_elem.get_text().strip() if price_elem else \"N/A\" # Extract product rating rating_elem = container.find('div', class_='rating') rating = rating_elem.get('data-rating') if rating_elem else \"N/A\" # Extract product availability availability_elem = container.find('span', class_='availability') availability = availability_elem.get_text().strip() if availability_elem else \"N/A\" # Add to our products list all_products.append({ 'name': name, 'price': price, 'rating': rating, 'availability': availability, 'page': page }) except Exception as e: print(f\"Error extracting product information: {e}\") print(f\"Scraped {len(product_containers)} products from page {page}\") # Be respectful: add a random delay between requests if page \u003c num_pages: delay = random.uniform(1, 3) print(f\"Waiting {delay:.2f} seconds before next request...\") time.sleep(delay) else: print(f\"Failed to retrieve page {page}. Status code: {response.status_code}\") # Convert the list of dictionaries to a DataFrame df = pd.DataFrame(all_products) return df def save_to_csv(dataframe, filename): \"\"\" Save the DataFrame to a CSV file. Args: dataframe (pandas.DataFrame): The DataFrame to save filename (str): The name of the CSV file \"\"\" dataframe.to_csv(filename, index=False) print(f\"Data saved to {filename}\") def main(): # Base URL of the fictional e-commerce website base_url = \"https://www.fictional-ecommerce.com\" # Number of pages to scrape num_pages = 3 # Scrape the products products_df = scrape_products(base_url, num_pages) # Display the first few rows print(\"\\nSample of scraped data:\") print(products_df.head()) # Save to CSV save_to_csv(products_df, \"products_data.csv\") if __name__ == \"__main__\": main() Note: This example is based on a fictional website structure. When adapting it for a real website, you’ll need to:\nInspect the actual HTML to find the correct CSS selectors Handle any site-specific challenges (like pagination or dynamic content) Respect the website’s robots.txt file and terms of service ","required-libraries#Required Libraries":"For our web scraping project, we’ll use the following libraries:\nRequests: For sending HTTP requests to websites Beautiful Soup: For parsing HTML and extracting data Pandas: For organizing and exporting the scraped data Let’s install these libraries:\npip install requests beautifulsoup4 pandas ","understanding-html-structure-for-scraping#Understanding HTML Structure for Scraping":"To effectively scrape a website, you need to understand its HTML structure. Most modern browsers have developer tools that let you inspect the elements of a webpage:\nRight-click on the element you want to scrape and select “Inspect” or “Inspect Element” The developer tools will show you the HTML structure Look for patterns, classes, IDs, or other attributes that can help you target specific elements Beautiful Soup provides several methods to navigate and search HTML:\nMethod Description find() Finds the first matching element find_all() Finds all matching elements select() Uses CSS selectors to find elements get_text() Extracts text from an element Here’s an example of targeting specific elements:\ndef scrape_quotes(url): \"\"\" Scrape quotes from a quotes website. Args: url (str): The URL of the quotes webpage Returns: list: A list of dictionaries containing quotes and authors \"\"\" # Send a GET request to the URL response = requests.get(url, headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }) quotes_data = [] if response.status_code == 200: # Parse the HTML content soup = BeautifulSoup(response.text, 'html.parser') # Find all quote containers # Note: This is an example. The actual structure would depend on the website. quote_containers = soup.find_all('div', class_='quote') for container in quote_containers: # Extract the quote text quote_text = container.find('span', class_='text').get_text() # Extract the author author = container.find('small', class_='author').get_text() # Add to our data list quotes_data.append({ 'quote': quote_text, 'author': author }) print(f\"Scraped {len(quotes_data)} quotes\") else: print(f\"Failed to retrieve the webpage. Status code: {response.status_code}\") return quotes_data # This is a hypothetical example. The actual HTML structure would vary. This example assumes a specific HTML structure where quotes are in elements with the class “quote”, the text is in a span with class “text”, and the author is in a small element with class “author”. You would need to adjust these selectors based on the actual website you’re scraping."},"title":"Web scraping basics"},"/python-fundamentals/09-practice-projects/04-next-steps/":{"data":{"":"Congratulations on learning the basics of Python! Now that you understand the core concepts of Python programming, you’re ready to deepen your knowledge and expand your skills. This section will guide you through the next steps in your Python learning journey.","best-practices-and-professional-skills#Best Practices and Professional Skills":"As you advance, focus on writing better, more maintainable code:\n1. Code Quality and Style Follow Python conventions:\nPEP 8: Python’s style guide Linting Tools: Use tools like flake8, pylint, or black Type Hints: Add static typing with annotations # Example with type hints def calculate_average(numbers: list[float]) -\u003e float: \"\"\" Calculate the average of a list of numbers. Args: numbers: A list of numbers Returns: The average of the numbers Raises: ZeroDivisionError: If the list is empty \"\"\" return sum(numbers) / len(numbers) 2. Testing Learn to write tests for your code:\nunittest: Python’s built-in testing framework pytest: A more powerful testing framework Test-Driven Development: Write tests before code # Example unittest for a function import unittest def add(a, b): return a + b class TestAddFunction(unittest.TestCase): def test_add_positive_numbers(self): self.assertEqual(add(2, 3), 5) def test_add_negative_numbers(self): self.assertEqual(add(-1, -2), -3) def test_add_mixed_numbers(self): self.assertEqual(add(-1, 5), 4) if __name__ == '__main__': unittest.main() 3. Documentation Write clear documentation for your code:\nDocstrings: Document modules, classes, and functions README Files: Provide project overviews and usage instructions API Documentation: Generate reference documentation from docstrings 4. Version Control Master Git for better code management:\nTrack changes to your code Collaborate with others Create branches for features and fixes Use GitHub or similar platforms to host your code ","build-a-portfolio-of-projects#Build a Portfolio of Projects":"One of the best ways to continue learning Python is by building real projects:\n1. Start with Small Projects Begin with manageable projects that reinforce what you’ve learned:\nCalculator with a GUI To-do list application Weather app using a public API Simple text-based game 2. Progress to Intermediate Projects Challenge yourself with more complex applications:\nBlog or content management system E-commerce site Data dashboard Automated trading system Custom API 3. Contribute to Open Source Contributing to open-source projects helps you:\nLearn from experienced developers Practice reading and understanding complex codebases Get feedback on your code Build your professional network Look for projects with “good first issue” labels to get started.","exercises#Exercises":"Exercise 1: Create a personal learning plan based on this roadmap, identifying specific resources, projects, and timelines that match your interests.\nExercise 2: Find an open-source Python project related to your interests. Fork it, set it up locally, and identify a small issue or enhancement you could work on.\nExercise 3: Choose one of the specialized areas mentioned in this section (web development, data science, etc.) and create a small project that demonstrates the fundamental concepts of that area.\nExercise 4: Set up a proper development environment with a linter, formatter, and testing framework. Then refactor one of your earlier projects to follow best practices.\nHint for Exercise 1: Start by identifying your end goal (e.g., “I want to become a data scientist” or “I want to build web applications”). Then work backward to determine what skills you need to develop and what projects would help you practice those skills.\nRemember, programming is a skill that improves with consistent practice. Be patient with yourself, celebrate your progress, and enjoy the journey of becoming a proficient Python developer!","intermediate-python-topics#Intermediate Python Topics":"Once you’re comfortable with the basics, explore these intermediate topics:\n1. Advanced Data Structures Deepen your understanding of built-in data structures and learn when to use each:\nCollections Module: Learn about namedtuples, defaultdict, Counter, deque, etc. Specialized Data Structures: Explore sets, frozen sets, and their operations Advanced Dictionary Techniques: Dictionary comprehensions, merging dictionaries, etc. # Using defaultdict to count word occurrences from collections import defaultdict def count_words(text): words = text.lower().split() word_count = defaultdict(int) # Default value is 0 for any new key for word in words: clean_word = word.strip(\".,!?\\\"'()[]{}:;\") if clean_word: word_count[clean_word] += 1 return word_count # Using Counter (even simpler) from collections import Counter def count_words(text): words = [word.strip(\".,!?\\\"'()[]{}:;\") for word in text.lower().split()] words = [word for word in words if word] # Remove empty strings return Counter(words) 2. Functions and Functional Programming Expand your understanding of functions:\nLambda Functions: Create anonymous, inline functions Higher-Order Functions: Functions that take other functions as arguments Map, Filter, and Reduce: Process iterables using functional programming patterns Decorators: Modify or enhance the behavior of functions Generators and Iterators: Create memory-efficient sequences # Lambda function example double = lambda x: x * 2 print(double(5)) # 10 # Map example - apply a function to each item in an iterable numbers = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, numbers)) print(squared) # [1, 4, 9, 16, 25] # Filter example - filter items based on a condition even_numbers = list(filter(lambda x: x % 2 == 0, numbers)) print(even_numbers) # [2, 4] # Simple decorator example def log_function_call(func): def wrapper(*args, **kwargs): print(f\"Calling {func.__name__} with {args} and {kwargs}\") result = func(*args, **kwargs) print(f\"{func.__name__} returned {result}\") return result return wrapper @log_function_call def add(a, b): return a + b add(3, 5) # Outputs log messages and returns 8 3. Object-Oriented Programming (OOP) Master the principles of OOP in Python:\nClasses and Objects: Create your own data types with attributes and methods Inheritance: Create specialized classes from base classes Encapsulation: Control access to class attributes and methods Polymorphism: Use the same interface for different underlying forms Magic Methods: Customize class behavior with special methods like __init__, __str__, etc. # Example of a class hierarchy with inheritance class Animal: def __init__(self, name, species): self.name = name self.species = species def make_sound(self): pass def __str__(self): return f\"{self.name} the {self.species}\" class Dog(Animal): def __init__(self, name, breed): super().__init__(name, \"Dog\") self.breed = breed def make_sound(self): return \"Woof!\" class Cat(Animal): def __init__(self, name, color): super().__init__(name, \"Cat\") self.color = color def make_sound(self): return \"Meow!\" # Creating and using objects dog = Dog(\"Rex\", \"German Shepherd\") cat = Cat(\"Whiskers\", \"Tabby\") print(dog) # Rex the Dog print(cat) # Whiskers the Cat print(dog.make_sound()) # Woof! print(cat.make_sound()) # Meow! 4. File Operations and Data Handling Build on your basic file I/O knowledge:\nBinary Files: Read and write binary data CSV Processing: Advanced CSV operations with the csv module JSON and XML: Work with common data interchange formats Database Access: Connect to and query databases with Python Data Serialization: Use pickle and other serialization methods # Example: Reading a CSV file with headers and specific data types import csv def read_csv_with_types(filename): data = [] with open(filename, 'r', newline='') as file: reader = csv.DictReader(file) for row in reader: # Convert types as needed processed_row = { 'name': row['name'], 'age': int(row['age']), 'height': float(row['height']), 'is_student': row['is_student'].lower() == 'true' } data.append(processed_row) return data # Example: Working with JSON data import json def update_config(config_file, updates): # Read existing config with open(config_file, 'r') as file: config = json.load(file) # Update with new values config.update(updates) # Write back to file with open(config_file, 'w') as file: json.dump(config, file, indent=4) ","learning-path-roadmap#Learning Path Roadmap":"Here’s a suggested roadmap to guide your further learning:\nWeeks 1-4: Solidify Basics\nReview core concepts Practice with coding challenges Build small command-line applications Weeks 5-8: Intermediate Python\nLearn advanced data structures Study functions and functional programming Explore file operations and data handling Weeks 9-12: Object-Oriented Programming\nMaster classes and inheritance Practice design patterns Build object-oriented projects Months 4-6: Specialized Area\nChoose a specialization (web, data science, etc.) Complete online courses in your chosen area Start building projects in that domain Months 7-12: Advanced Projects\nDevelop a substantial portfolio project Contribute to open source Focus on best practices and professional skills Important: Your learning journey should be tailored to your interests and goals. Don’t hesitate to adjust this roadmap based on what excites you about Python programming.","solidify-your-core-knowledge#Solidify Your Core Knowledge":"Before diving into more advanced topics, make sure you have a solid grasp of the fundamentals:\n1. Practice Regularly Consistent practice is key to mastering programming. Here are some ways to practice:\nCoding Challenges: Websites like LeetCode, HackerRank, and CodeWars offer programming challenges of varying difficulty. Mini Projects: Build small applications that solve real problems you encounter. Modify Existing Code: Take code examples from this tutorial and modify them to add new features. # Example: Extend the contact manager from earlier to include: # - Editing existing contacts # - Deleting contacts # - Sorting contacts by name, email, etc. 2. Read and Analyze Code Reading other people’s code helps you learn new techniques and best practices:\nStudy open-source Python projects on GitHub Analyze the standard library code Review solutions to coding challenges after solving them yourself 3. Refine Your Debugging Skills Debugging is an essential skill for any programmer:\nLearn to use Python’s built-in debugger (pdb) Practice reading and understanding error messages Add strategic print() statements to track program flow Use logging instead of print statements for more complex projects # Basic debugging with print statements def calculate_average(numbers): print(f\"Input: {numbers}\") total = sum(numbers) print(f\"Sum: {total}\") average = total / len(numbers) print(f\"Average: {average}\") return average # Using Python's logging module (better for production code) import logging logging.basicConfig(level=logging.DEBUG) def calculate_average(numbers): logging.debug(f\"Input: {numbers}\") total = sum(numbers) logging.debug(f\"Sum: {total}\") average = total / len(numbers) logging.debug(f\"Average: {average}\") return average ","specialized-python-areas#Specialized Python Areas":"Depending on your interests, you might want to explore these specialized areas:\n1. Web Development Python is widely used for web development:\nWeb Frameworks:\nDjango: A high-level, full-stack framework Flask: A lightweight, flexible microframework FastAPI: Modern, fast framework for building APIs Web Scraping:\nBeautiful Soup: Parse HTML and XML documents Scrapy: Extract data from websites Selenium: Automate browser interactions # Simple Flask application from flask import Flask, render_template app = Flask(__name__) @app.route('/') def home(): return render_template('index.html', title='Home Page') @app.route('/about') def about(): return render_template('about.html', title='About Us') if __name__ == '__main__': app.run(debug=True) 2. Data Science and Analysis Python is the leading language for data science:\nNumPy: Work with large, multi-dimensional arrays and matrices Pandas: Analyze and manipulate structured data Matplotlib and Seaborn: Create visualizations Jupyter Notebooks: Interactive computing environment SciPy: Scientific computing tools # Basic data analysis with pandas import pandas as pd import matplotlib.pyplot as plt # Load data data = pd.read_csv('sales_data.csv') # Explore data print(data.head()) # First 5 rows print(data.describe()) # Statistical summary # Group by analysis monthly_sales = data.groupby('month')['sales'].sum() # Visualization monthly_sales.plot(kind='bar') plt.title('Monthly Sales') plt.xlabel('Month') plt.ylabel('Total Sales') plt.show() 3. Machine Learning Build on data science knowledge to create predictive models:\nScikit-learn: Machine learning algorithms TensorFlow and PyTorch: Deep learning frameworks Keras: High-level neural networks API NLTK and spaCy: Natural language processing # Simple machine learning example with scikit-learn from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score # Load dataset (X = features, y = target) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Create and train model model = RandomForestClassifier() model.fit(X_train, y_train) # Make predictions predictions = model.predict(X_test) # Evaluate model accuracy = accuracy_score(y_test, predictions) print(f\"Accuracy: {accuracy:.2f}\") 4. Automation and Scripting Python excels at automating repetitive tasks:\nOS Module: Interact with the operating system Subprocess Module: Run external commands and programs Automation Libraries: Automate browser with Selenium, GUI with PyAutoGUI Schedule and Cron: Run tasks at specific times Command-line Tools: Create CLI applications with argparse or click # Example: Batch rename files import os def batch_rename(directory, old_ext, new_ext): \"\"\"Rename all files with old_ext to new_ext in the given directory.\"\"\" for filename in os.listdir(directory): if filename.endswith(old_ext): base_name = os.path.splitext(filename)[0] old_file = os.path.join(directory, filename) new_file = os.path.join(directory, base_name + new_ext) os.rename(old_file, new_file) print(f\"Renamed: {old_file} -\u003e {new_file}\") # Example usage batch_rename(\"./images\", \".jpeg\", \".jpg\") ","stay-current-with-python#Stay Current with Python":"Python is constantly evolving, so stay up-to-date:\n1. Follow Python News Sources Python.org: The official Python website Python Weekly: Newsletter with Python news Real Python: Tutorials and articles Planet Python: Aggregator of Python blogs 2. Attend Python Events Local Python meetups Conferences like PyCon Online webinars and workshops 3. Keep Learning Follow online courses from platforms like Coursera, edX, or Udemy Read books on advanced Python topics Watch video tutorials on YouTube "},"title":"Next steps for Learning Python"},"/python/":{"data":{"":" Learn Python fundamentals, how Python can be used for different software engineering disciplines and integrate with different technologies Fundamentals: Python Basics Compose with just Markdown. Enrich with Shortcode components."},"title":"Python Roadmap"},"/tutorials/":{"data":{"":" Programming languages: Python Explore basics and use cases of Python programming language\nJavaScript Learn JavaScript and technologies around it\nGolang Learn Golang, it’s ecosystem and concurrency patterns\nJava Explore Java Programming Language, it’s frameworks and ecosystems\nKotlin Learn Kotlin and it’s ecosystem for backend development\nRust Learn Rust by doing high performing applications\nC# Explore C# Programming Language, and .NET framework\nRuby Compose with just Markdown. Enrich with Shortcode components.\nPHP Compose with just Markdown. Enrich with Shortcode components.\nFundamentals: Computer Science Fundamentals Simple and easy to use, yet powerful and feature-rich.\nOperating systems Learn how to interact with operating systems via command line\nDatabases Looks great on different screen sizes. Built-in dark mode support, with auto-switching based on user’s system preference.\nWeb Fundamentals: Computer Networks Learn the basics of computer networks, how it works, what are protocols and for which application they are used\nWeb Fundamentals Learn the basics of HTTP, the data transmission and the web pages mechanics\nWeb Services Build with GitHub Actions, and host for free on GitHub Pages. Alternatively it can be hosted on any static hosting service.\nEngineering NoSQL Databases Looks great on different screen sizes. Built-in dark mode support, with auto-switching based on user’s system preference.\nSecurity Create multi-language pages by just adding locales suffix to the Markdown file. Adding i18n support to your site is intuitive.\nArchitectural Patterns Syntax highlighting / Table of contents / SEO / RSS / LaTeX / Mermaid / Customizable / and more…\nPerformance Optimization Syntax highlighting / Table of contents / SEO / RSS / LaTeX / Mermaid / Customizable / and more…\nNetwork Programming Syntax highlighting / Table of contents / SEO / RSS / LaTeX / Mermaid / Customizable / and more…"},"title":"Tutorials"}}